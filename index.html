<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Atypical programmer | 做一个非典型程序员</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="写给典型的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="Atypical programmer">
<meta property="og:url" content="https://github.com/cstsinghua/index.html">
<meta property="og:site_name" content="Atypical programmer">
<meta property="og:description" content="写给典型的程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Atypical programmer">
<meta name="twitter:description" content="写给典型的程序员">
  
    <link rel="alternative" href="/atom.xml" title="Atypical programmer" type="application/atom+xml">
  
  <meta name="summary" content="写给典型的程序员">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Cstsinghua</h5>
        <a href="mailto:undefined" title="cstsinghua@126.com" class="mail">cstsinghua@126.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Android"  >
            <i class="icon icon-lg icon-android"></i>
            Android
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Java"  >
            <i class="icon icon-lg icon-coffee"></i>
            Java
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Python"  >
            <i class="icon icon-lg icon-product-hunt"></i>
            Python
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/杂项/"  >
            <i class="icon icon-lg icon-book"></i>
            杂项
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/cstsinghua" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://developer.android.com"  >
            <i class="icon icon-lg icon-link"></i>
            Android官网
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Atypical programmer &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Atypical programmer</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Atypical programmer</h1>
    <h5 class="subtitle">做一个非典型程序员</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <ul class="post-list">
  
    <li class="post-list-item">
  <article id="post-Github pages+Hexo+Nodejs搭建个人blog" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/16/Github pages+Hexo+Nodejs搭建个人blog/">Github pages+Hexo+Nodejs搭建个人blog</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搭建个人Blog/">搭建个人Blog</a></li></ul>
</div>
        <time datetime="2016-06-16T10:35:07.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-16
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个IT技术人员，自然离不开技术的积累，而技术的积累则通过文档或代码的形式呈现出来。好记性不如烂笔头，程序员应该乐于并擅于记录总结工作中遇到的各种问题、工作成果、奇思异想和感悟等。</p>
<p>程序员的世界是孤独的，但也是充满激情和阳光的。正是开源精神点亮了这一切。生命中最美丽的报偿之一便是帮助他人的同时，也帮助了自己 ─ 罗夫‧瓦尔多‧爱默生 </p>
<p>因此，将个人的经验和感悟与他人分享，成就的不仅仅是个人，更可以帮助其他人少走弯路。那么就开始分享的旅程吧！</p>
<h1 id="传统的笔记或者blog平台"><a href="#传统的笔记或者blog平台" class="headerlink" title="传统的笔记或者blog平台"></a>传统的笔记或者blog平台</h1><p>在本地可以用各种文档格式保存自己的技术积累，也可以采用一些市面上的blog平台作为载体来存储自己的技术文章，但这类方式存在一些弊端，这点你可以打开你的脑洞，想想有哪些，本人不是来挑起舌战的。</p>
<h1 id="Github-pages-Hexo-Nodejs搭建个人blog"><a href="#Github-pages-Hexo-Nodejs搭建个人blog" class="headerlink" title="Github pages+Hexo+Nodejs搭建个人blog"></a>Github pages+Hexo+Nodejs搭建个人blog</h1><p>好处和缺点这里就暂不提了，请自行google。(本文仅仅是提供一种搭建Blog的方式，不牵涉任何利益方！！！)</p>
<p>步骤如下：</p>
<ol>
<li>安装git：<a href="https://git-scm.com" title="git下载" target="_blank" rel="external">git下载</a>，注意：Windows平台需要下载对应的安装exe,安装之后后续的命令行操作需要在GitShell中打开而非Windows默认的命令行。</li>
<li>安装nodejs：<a href="https://nodejs.org" title="nodejs官网" target="_blank" rel="external">node.js官网</a>，注意：请根据自己主机的平台下载对应版本。</li>
<li>安装hexo及部署：<a href="https://hexo.io/" title="hexo官网" target="_blank" rel="external">hexo官网</a>，注意：安装 Hexo 相当简单。然而在安装前，您必须确保先完成步骤1和2。Hexo网站可以选择语言为简体中文，方便使用。查看其中的文档可以看到hexo的详细使用说明，so easy！</li>
</ol>
<p>重点阐述下步骤3的过程(hexo的详细信息可参加<a href="https://hexo.io/zh-cn/docs/index.html" title="hexo说明文档" target="_blank" rel="external">hexo说明文档</a>)：</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在Gitshell(已经安装了git并且将git加入到path环境变量中)输入：</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹(自行选定的文件夹folder)中新建所需要的文件。</p>
<blockquote>
<p>$ hexo init folder<br>$ cd folder<br>$ npm install</p>
</blockquote>
<p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p><strong>_config.yml</strong><br>网站的 配置 信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong><br>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line"> "name": "hexo-site",</span><br><span class="line"> "version": "0.0.0",</span><br><span class="line"> "private": true,</span><br><span class="line"> "hexo": &#123;</span><br><span class="line">	"version": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">	"hexo": "^3.0.0",</span><br><span class="line">	"hexo-generator-archive": "^0.1.0",</span><br><span class="line">	"hexo-generator-category": "^0.1.0",</span><br><span class="line">	"hexo-generator-index": "^0.1.0",</span><br><span class="line">	"hexo-generator-tag": "^0.1.0",</span><br><span class="line">	"hexo-renderer-ejs": "^0.1.0",</span><br><span class="line">	"hexo-renderer-stylus": "^0.2.0",</span><br><span class="line">	"hexo-renderer-marked": "^0.2.4",</span><br><span class="line">	"hexo-server": "^0.1.2"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>scaffolds</strong><br>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p><strong>source</strong><br>资源文件夹是存放用户资源的地方。除 <em>posts 文件夹之外，开头命名为 </em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong><br><a href="https://hexo.io/docs/themes.html" title="hexo主题" target="_blank" rel="external">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="本地启动server"><a href="#本地启动server" class="headerlink" title="本地启动server"></a>本地启动server</h2><p>该步骤可以检验安装是否ok。如果能成功，那么恭喜你离成功更近一步了。</p>
<p>在Gitshell中进入前面指定的folder(建立的站点的根目录)，输入：</p>
<blockquote>
<p>$ hexo server</p>
</blockquote>
<p>可以观察命令行的输出，然后通过浏览器打开<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>，成功的情况下则会看到默认的欢迎页面。</p>
<h2 id="部署到github-pages"><a href="#部署到github-pages" class="headerlink" title="部署到github pages"></a>部署到github pages</h2><p>(<a href="https://help.github.com/categories/github-pages-basics/" title="github pages介绍" target="_blank" rel="external">点击了解Github Pages</a>)</p>
<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p>
<blockquote>
<p>$ hexo deploy</p>
</blockquote>
<p>在开始之前，您必须先在站点的配置文件_config.yml(前面建立的folder目录下)中修改参数，一个正确的部署配置中至少要有 type 参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br></pre></td></tr></table></figure>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">  	repo:</span><br><span class="line">	type: heroku</span><br><span class="line">	repo:</span><br></pre></td></tr></table></figure>
<p>这里重点提及部署到Github pages的方法(步骤)。</p>
<p><strong>a.首先在Github上面创建一个新的Repository，仓库命名格式为yourname.github.io，注意：yourname是你自己定义的一个名称，后面的github.io是统一的，格式一定需要符合这个样式。</strong><br><strong>b.然后，配置文件_config.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:your_github_account/yourname.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>repo</td>
<td>库（Repository）地址</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息</td>
</tr>
</tbody>
</table>
<p>eg(我的Github账号是cstsinghua，而我新建的仓库名称是cstsinghua.github.io):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:cstsinghua/cstsinghua.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>注意：如果是建立项目网站，则branch需要修改为gh-pages，详细情况请参见<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="external">Github pages中User, Organization, and Project Pages的差异</a></p>
<p><strong>c.安装hexo的git插件<a href="https://github.com/hexojs/hexo-deployer-git" title="hexo的git插件">hexo-deployer-git</a></strong></p>
<blockquote>
<p>$ npm install hexo-deployer-git –save</p>
</blockquote>
<p><strong>d.部署前面建立的站点(folder下面的内容)：</strong></p>
<p>执行完，开始部署，即先hexo generate，然后hexo deploy。也可以一步到位：hexo d -g</p>
<blockquote>
<p>  $ hexo clean<br>    $ hexo generate<br>    $ hexo deploy</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>$ hexo d -g</p>
</blockquote>
<p>注意：在这一步可能报错，已知的一些错误可以参见<a href="https://hexo.io/zh-cn/docs/troubleshooting.html#Git-部署问题" target="_blank" rel="external">hexo git部署常见问题</a></p>
<p>另外，可能遇到SSH publickey接入问题，可以参见<a href="https://help.github.com/articles/generating-an-ssh-key/" title="创建github ssh key" target="_blank" rel="external">创建github SSH key</a>和<a href="https://github.com/settings/keys" title="github SSH key管理">github SSH key管理</a></p>
<h2 id="optional-重绑定域名"><a href="#optional-重绑定域名" class="headerlink" title="(optional)重绑定域名"></a>(optional)重绑定域名</h2><p>Custom domain redirects for GitHub Pages sites(将独立(个性)域名与GitHub Pages的空间域名绑定)</p>
<p>yourname.github.io的域名格式比较固定，那么是否可以设置一个个性化的域名呢，另外需要注意的是Github pages的容量受限于github的要求，目前是1GB(请参见<a href="https://help.github.com/articles/what-are-github-pages/" target="_blank" rel="external">https://help.github.com/articles/what-are-github-pages/</a>)。因此，建立一个独立的个性化(blog)网站(域名是个性化独立的，容量也可以调整)，在某些情况下还是有必要的(请参见<a href="https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/" title="github pages域名重定向" target="_blank" rel="external">github pages域名重定向</a>)。</p>
<ul>
<li><p>Github pages 设置：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如cstsinghua.me。</p>
</li>
<li><p>DNS设置：注册DNSpod，添加域名，不是必要的步骤，但是据说可以提高解析效率。本人没有测试。</p>
</li>
<li><p>在域名服务商，如net.cn中修改增加两条A记录，指向github pages 提供的 ip<br>  192.30.252.153<br>  192.30.252.154</p>
</li>
</ul>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/16/Github pages+Hexo+Nodejs搭建个人blog/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-ZXing开源项目实战" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/ZXing开源项目实战/">Zxing二维码开源库实战</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zxing/">Zxing</a></li></ul>
</div>
        <time datetime="2016-06-13T07:42:25.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="Zxing二维码开源库学习和优化"><a href="#Zxing二维码开源库学习和优化" class="headerlink" title="Zxing二维码开源库学习和优化"></a>Zxing二维码开源库学习和优化</h1><p>  本文对Google官方开源的二维码扫描库ZXing做一个总体概述，然后进行Android开发环境下的实战(二次)开发和优化，并用于生产项目。<br>  ZXing开源项目官方地址:<a href="https://github.com/zxing/zxing" title="ZXing">https://github.com/zxing/zxing</a></p>
<hr>
<h2 id="前期学习和准备"><a href="#前期学习和准备" class="headerlink" title="前期学习和准备"></a>前期学习和准备</h2><p> 各种百度和google，先了解二维码的技术概念和原理，他人经验和文章等等。以下摘自百度百科：</p>
<p> 国外对二维码技术的研究始于20世纪80年代末，在二维码符号表示技术研究方面已研制出多种码制，常见的有PDF417、QR Code、Code 49、Code 16K、Code One等。这些二维码的信息密度都比传统的一维码有了较大提高，如PDF417的信息密度是一维码CodeC39的20多倍。在二维码标准化研究方面，国际自动识别制造商协会（AIM）、美国标准化协会（ANSI）已完成了PDF417、QR Code、Code 49、Code 16K、Code One等码制的符号标准。国际标准技术委员会和国际电工委员会还成立了条码自动识别技术委员会（ISO/IEC/JTC1/SC31），已制定了QR Code的国际标准（ISO/IEC 18004：2000《自动识别与数据采集技术—条码符号技术规范—QR码》），起草了PDF417、Code 16K、Data Matrix、Maxi Code等二维码的ISO/IEC标准草案。在二维码设备开发研制、生产方面，美国、日本等国的设备制造商生产的识读设备、符号生成设备，已广泛应用于各类二维码应用系统。二维码作为一种全新的信息存储、传递和识别技术，自诞生之日起就得到了世界上许多国家的关注。美国、德国、日本等国家，不仅已将二维码技术应用于公安、外交、军事等部门对各类证件的管理，而且也将二维码应用于海关、税务等部门对各类报表和票据的管理，商业、交通运输等部门对商品及货物运输的管理、邮政部门对邮政包裹的管理、工业生产领域对工业生产线的自动化管理。</p>
<p> 我国对二维码技术的研究开始于1993年。中国物品编码中心对几种常用的二维码PDF417、QRCCode、Data Matrix、Maxi Code、Code 49、Code 16K、Code One的技术规范进行了翻译和跟踪研究。随着我国市场经济的不断完善和信息技术的迅速发展，国内对二维码这一新技术的需求与日俱增。中国物品编码中心在原国家质量技术监督局和国家有关部门的大力支持下，对二维码技术的研究不断深入。在消化国外相关技术资料的基础上，制定了两个二维码的国家标准：二维码网格矩阵码（SJ/T 11349-2006）和二维码紧密矩阵码（SJ/T 11350-2006），从而大大促进了我国具有自主知识产权技术的二维码的研发。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-下载ZXing并选择包"><a href="#1-下载ZXing并选择包" class="headerlink" title="1. 下载ZXing并选择包"></a>1. 下载ZXing并选择包</h3><blockquote>
<p>截止本文攥写之时，ZXing的最新版本为3.2.1，在Github网站上下载ZXing的主分支（zxing-master.zip），解压完成之后，目录树如下：<br><img src="http://172.20.154.39:8080/GodSDKBackground/ZXing-dirTree.png" alt="ZXing项目解压的目录层次"></p>
<p>以下对解压的目录结构(包含模块)的主要部分做一个概述(此处以3.2.1版本基准，不同的版本包含的模块可能稍有差异，请留意)：</p>
</blockquote>
<ul>
<li><p><strong>android</strong></p>
<p>  Android client Barcode Scanner,中文意为“条形扫码器”，下文简称BS。可作为独立的扫码APP使用。</p>
</li>
<li><p><strong>android-core</strong></p>
<p>   Android-related code shared among android, androidtest, glass，即android、androidtest和glass三个模块共享的android相关库，当前其实就是一个相机配置工具类(CameraConfigurationUtils.java).</p>
</li>
<li><p><strong>android-integration</strong></p>
<p>   Supports integration with Barcode Scanner via Intent，即通过Intent的方式提供一种便捷的途径将BS整合到用户的APP中。</p>
</li>
<li><p><strong>androidtest</strong></p>
<p>  Android test app, ZXing Test，即模拟调用方app(相当于用户APP的角色)，通过android-integration整合Barcode Scanner</p>
</li>
<li><p><strong>core</strong></p>
<p>  The core image decoding library, and test code.即核心的图片编解码库，整个条形码的核心处理库，另外还包括测试代码。</p>
</li>
<li><p>glass    </p>
<p>  Simple Google Glass application</p>
</li>
<li><p>zxingorg</p>
<p>  The source behind zxing.org</p>
</li>
<li><p>zxing.appspot.com</p>
<p>  The source behind web-based barcode generator at zxing.appspot.com</p>
</li>
<li><p>javase</p>
<p>  JavaSE-specific client code</p>
</li>
</ul>
<p>其中，与开发Android二维码扫码相关的模块有android、android-core、android-integration、androidtest和core模块。</p>
<p>androidtest、android-integration、android三个模块的关系图如下：</p>
<p><img src="http://172.20.154.39:8080/GodSDKBackground/Barcode_module_relationship.png" alt="模块关系图"></p>
<h3 id="2-试用并厘清ZXing项目的源码"><a href="#2-试用并厘清ZXing项目的源码" class="headerlink" title="2.试用并厘清ZXing项目的源码"></a>2.试用并厘清ZXing项目的源码</h3><ul>
<li><p>试用：</p>
<p>  用Eclipse导入(按照导入现有Android工程的方式)上面所述的androidtest模块，导入之后，源代码部分会报错。主要有以下两种错误：</p>
<ul>
<li><p>由于ZXing项目编写者采用的java编译版本不低于1.7.0，因此如果你的Eclipse的java编译版本设置为1.6.0或者更低版本时，将会报错，比如new ArrayList&lt;&gt;(),在1.6.0版本则不能省略具体的泛型类型，应该为new ArrayList<yourclass>()；</yourclass></p>
</li>
<li><p>引用了大量core模块、android-integration和android-core的类，因此需要将core模块的jar包(当然也可以直接copy源码)添加到工程的构建路径(core包的下载地址:<a href="http://repo1.maven.org/maven2/com/google/zxing/core/" title="ZXing的core包" target="_blank" rel="external">http://repo1.maven.org/maven2/com/google/zxing/core/</a>)，另外需要将android-integration和android-core的源码复制到工程中(新建对应的package，copy类)；</p>
<p>按照上面步骤处理完之后，则可以运行的测试APP诞生了。工程目录图如下：<br><img src="http://172.20.154.39:8080/GodSDKBackground/barcode_test_project.png" alt="ZXing试用工程目录"></p>
<p>运行并安装APK至手机或模拟器，测试APP界面如下图：</p>
<p><img src="http://172.20.154.39:8080/GodSDKBackground/barcode_test_app.png" alt="ZXing试用工程目录">    </p>
<p>可以体验扫码和生成二维码的功能。</p>
</li>
</ul>
</li>
<li><p>源码分析</p>
<p>  其实这里要关注的源码主要有四部分：core、android、android-integration和android-core，其中android-integration和android-core较为简单，这里不再赘述。而core涉及图片处理和二维码的理论技术，暂不做深入研究。</p>
<p>  android模块即BS，可以作为单独APP使用，是一个功能强大的条码扫描器，不仅支持多种类型的条码，还支持多国语言，分享二维码，查看扫描历史，反向扫描等功能。</p>
<p>  因此，这里主要就android模块进行分析阐述。导入Eclipse之后，android模块的包结构图如下：</p>
<p>  <img src="http://172.20.154.39:8080/GodSDKBackground/barcode_BS_Hierarchy.png" alt="BS包结构"></p>
<p>  如上图所示，BS主要包括下列组件：</p>
<ul>
<li><p>android：与CaptureActivity直接相关的核心组件。包含了发生震动管理器，闪光灯等等。</p>
</li>
<li><p>book：如果查询的结果是图书信息，用户可以选择查询该书的更进一步的详细信息，该包即包含了搜索与展示书籍的相关类。</p>
</li>
<li><p>camera/camera.open：摄像头相关组件，核心类是CameraManager</p>
</li>
<li><p>clipboard：剪贴板</p>
</li>
<li><p>encode：编码功能的各个组件集合。核心类为QRCodeEncoder，最终实施编码的是MultiFormatWriter类</p>
</li>
<li><p>history：扫描历史管理，核心类是HistoryManager</p>
</li>
<li><p>result：条码扫描的结果被分为不同的类型，所有的类型都定义在com.google.zxing.client.result.ParsedResultType中，对于不同的类型都有对应的处理方法：xxxResultHandler，所有的ResultHandler都包含在此包中。不同的xxxResultHandler还提供了扫描结果页面要展示几个button，每个button的文本以及需要绑定的事件等等。</p>
</li>
<li><p>result.supplement：对已经扫描并解码的结果做额外处理的工具集。比如扫描出来的是isbn号，如果在设置中选择了“检索更多信息”则会在扫描出isbn号之后自动去网上查询该书的信息，最后将书的信息展示出来，而如果没选中，则只会将isbn号码展示。</p>
</li>
<li><p>share：分享二维码功能，亦是编码功能的入口所在。</p>
</li>
<li><p>wifi：是WifiResultHandler的辅助类集合。如果扫描到的二维码是对wifi信息的编码，那么最终扫描结果页会展示一个“连接到网络”的按钮，点击此按钮就会自动尝试连接。该包中所包含的类则是链接网络所需的工具类。</p>
<p>打开BS，即进入扫描界面时，BS大致做了如下的事情：配置Camera并启动Camera、构建preview与扫描窗口、捕捉画面并解码、将解码结果交给不同ResultHandler去处理。下面逐一进行分析。</p>
</li>
</ul>
<ol>
<li><p>配置Camera并启动Camera</p>
<p> 启动Camera是在CaptureActivity.initCamera中进行的，最重要的几句代码是：</p>
<pre><code>cameraManager.openDriver(surfaceHolder);
// Creating the handler starts the preview, which can also throw a
// RuntimeException.
if (handler == null) {
    handler = new CaptureActivityHandler(this, decodeFormats,
            decodeHints, characterSet, cameraManager);
}
</code></pre><p> CameraManager是相机管理类，是BS中唯一与Camera打交道的类，CameraManager.openDriver主要做了三件事：</p>
<pre><code>/**
 * Opens the camera driver and initializes the hardware parameters.
 * 
 * @param holder
 *            The surface object which the camera will draw preview frames
 *            into.
 * @throws IOException
 *             Indicates the camera driver failed to open.
 */
public synchronized void openDriver(SurfaceHolder holder)
        throws IOException {
    Camera theCamera = camera;
    if (theCamera == null) {
        // 1. 获取手机背面的摄像头
        theCamera = OpenCameraInterface.open(requestedCameraId);
        if (theCamera == null) {
            throw new IOException();
        }
        camera = theCamera;
    }
    // 2. 设置摄像头预览view
    theCamera.setPreviewDisplay(holder);

    if (!initialized) {
        initialized = true;
        configManager.initFromCameraParameters(theCamera);
        if (requestedFramingRectWidth &gt; 0 &amp;&amp; requestedFramingRectHeight &gt; 0) {
            setManualFramingRect(requestedFramingRectWidth,
                    requestedFramingRectHeight);
            requestedFramingRectWidth = 0;
            requestedFramingRectHeight = 0;
        }
    }

    Camera.Parameters parameters = theCamera.getParameters();
    String parametersFlattened = parameters == null ? null : parameters
            .flatten(); // Save these, temporarily
    try {
        // 3. 读取配置并设置相机参数
        configManager.setDesiredCameraParameters(theCamera, false);
    } catch (RuntimeException re) {
        // Driver failed
        Log.w(TAG,
                &quot;Camera rejected parameters. Setting only minimal safe-mode parameters&quot;);
        Log.i(TAG, &quot;Resetting to saved camera params: &quot;
                + parametersFlattened);
        // Reset:
        if (parametersFlattened != null) {
            parameters = theCamera.getParameters();
            parameters.unflatten(parametersFlattened);
            try {
                theCamera.setParameters(parameters);
                configManager.setDesiredCameraParameters(theCamera, true);
            } catch (RuntimeException re2) {
                // Well, darn. Give up
                Log.w(TAG,
                        &quot;Camera rejected even safe-mode parameters! No configuration&quot;);
            }
        }
    }

}
</code></pre><p> CameraConfigurationManager是相机辅助类，主要用于设置相机的各类参数。核心方法有两个：</p>
<ul>
<li><p>initFromCameraParameters：计算了屏幕分辨率和当前最适合的相机像素</p>
</li>
<li><p>setDesiredCameraParameters：读取配置设置相机的对焦模式、闪光灯模式等等</p>
<p>CaptureActivityHandler类是一个针对扫描任务的Handler，可接收的message有启动扫描（restart_preview）、扫描成功（decode_succeeded）、扫描失败（decode_failed）等等。</p>
<p>在创建一个CaptureActivityHandler对象的时候也做了三件事：</p>
<p>  CaptureActivityHandler(CaptureActivity activity,</p>
<pre><code>           Collection&lt;BarcodeFormat&gt; decodeFormats,
           Map&lt;DecodeHintType,?&gt; baseHints,
           String characterSet,
           CameraManager cameraManager) {
  this.activity = activity;
  // 1. 启动扫描线程
  decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
      new ViewfinderResultPointCallback(activity.getViewfinderView()));
  decodeThread.start();
  state = State.SUCCESS;

  // Start ourselves capturing previews and decoding.
  this.cameraManager = cameraManager;
  // 2. 开启相机预览界面
  cameraManager.startPreview();
  // 3. 将preview回调函数与decodeHandler绑定、调用viewfinderView
  restartPreviewAndDecode();
}
</code></pre><p>restartPreviewAndDecode方法又调用了CameraManager.requestPreviewFrame：</p>
<p>  /**</p>
<ul>
<li>A single preview frame will be returned to the handler supplied. The data</li>
<li>will arrive as byte[] in the message.obj field, with width and height</li>
<li><p>encoded as message.arg1 and message.arg2, respectively.</p>
</li>
<li><p>1：将handler与preview回调函数绑定；<br></p>
</li>
<li>2：注册preview回调函数<br></li>
<li>综上，该函数的作用是当相机的预览界面准备就绪后就会调用hander向其发送传入的message</li>
<li>@param handler</li>
<li>The handler to send the message to.</li>
<li>@param message</li>
<li>The what field of the message to be sent.<br>*/<br>public synchronized void requestPreviewFrame(Handler handler, int message) {<br>Camera theCamera = camera;<br>if (theCamera != null &amp;&amp; previewing) {<br>previewCallback.setHandler(handler, message);<br>/ 绑定相机回调函数，当预览界面准备就绪后会回调Camera.PreviewCallback.onPreviewFrame<br>theCamera.setOneShotPreviewCallback(previewCallback);<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>2. 构建preview与扫描窗口

    首先相机有自己的preview界面，然后我们需要构造一个扫描窗口，引导用户将条码置于窗口中完成扫描。

    构造扫描窗口是在CaptureActivityHandler.restartPreviewAndDecode中，通过调用activity.drawViewfinder()来实现的。这里有个画扫描窗口的类叫ViewfinderView，该类也是想要改变扫描窗口风格所必须重构的一个类。

    重构ViewfinderView涉及Android的高级话题：自定义View及其属性，这里暂不赘述。

    相机的preview界面显示出来后即可开始扫描，所以需要监听preview是否已经显示这个事件，这就是Camera.PreviewCallback的作用。PreviewCallback.onPreviewFrame做的事便是当preview界面展示出来的时候向DecodeHandler发送一个decode消息，DecodeHandler收到该消息后会执行decode方法来解码。

    注意，检测并触发捕获画面动作的，是Camera.setOneShotPreviewCallback()这个方法。该函数被调用后，如果预览界面已经打开，就会将包含当前preview frame的byte数组传给回调函数，此时再向DecodeHandler发送decode消息。

3. 捕捉画面并解码

    具体参考DecodeHandler.decode方法。（本文只从宏观上对zxing进行分析，对于解码的原理暂不做介绍）

4. 将解码结果交给不同ResultHandler去处理

    当DecodeHandler.decode完成解码后会向CaptureActivityHandler发消息。如果编码成功则调用CaptureActivity.handleDecode方法对扫描到的结果进行分类处理。

    该方法中首先获取ResultHandler：

        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(
                this, rawResult);
    然后调用handleDecodeInternally和handleDecodeExternally对ResultHandler进行处理。谈到这两个方法，就不得不再分析一下    IntentSource。

        enum IntentSource {

          /**
           * 本地app向BS(Barcode Scanner)发起的启动指令
           * 比如在androidtest项目中，利用整合的android-integration对BS发起调用指令：com.google.zxing.client.android.SCAN
           * BS中该启动命令对应的Source类型便是NATIVE_APP_INTENT
           */
            NATIVE_APP_INTENT,

          /**
           * 打开BS的时候传入查询商品的url，与最终扫描到的product id结合进行查询
           * 两种url的形式不同
           */
          PRODUCT_SEARCH_LINK,
          ZXING_LINK,

          /**
           * 直接打开BS
           */
          NONE

        }

    结合CaptureActivity.onResume中的部分代码来理解：

        else if (dataString != null
                    &amp;&amp; dataString.contains(&quot;http://www.google&quot;)
                    &amp;&amp; dataString.contains(&quot;/m/products/scan&quot;)) {

                // Scan only products and send the result to mobile Product
                // Search.
                source = IntentSource.PRODUCT_SEARCH_LINK;
                sourceUrl = dataString;
                decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;

        } else if (isZXingURL(dataString)) {

            // Scan formats requested in query string (all formats if none
            // specified).
            // If a return URL is specified, send the results there.
            // Otherwise, handle it ourselves.
            source = IntentSource.ZXING_LINK;
            sourceUrl = dataString;
            Uri inputUri = Uri.parse(dataString);
            scanFromWebPageManager = new ScanFromWebPageManager(inputUri);
            decodeFormats = DecodeFormatManager
                    .parseDecodeFormats(inputUri);
            // Allow a sub-set of the hints to be specified by the caller.
            decodeHints = DecodeHintManager.parseDecodeHints(inputUri);

        }

    NATIVE_APP_INTENT和NONE很好理解，而PRODUCT_SEARCH_LINK和ZXING_LINK是指定查询商品的url（而不是交给zxing分析后再决定去哪里查询），将扫描出来的内容拼凑到url中，然后在浏览器中展示结果。

    理解了IntentSource，就容易看懂handleDecodeInternally其实就是将结果展示到界面上。handleDecodeExternally稍复杂些，当source == IntentSource.NATIVE_APP_INTENT时，BS会将扫描分析的结果存到Intent中返回给调用方app，因此调用方app在启动BS的时候一定要使用startActivityForResult。这一点可以在androidtest的IntentIntegrator.initiateScan方法的最后看到。
</code></pre><h3 id="3-BS优化"><a href="#3-BS优化" class="headerlink" title="3.BS优化"></a>3.BS优化</h3><p>BS可直接作为独立APP运行，但是项目中的很多功能我们并不需要，而且扫描的界面为横向，因此进行相关优化。接下来，我们在BS项目工程基础上，直接修改其中代码或者xml文件，达到修改扫码界面为竖屏且美化扫码界面的目的。</p>
<ol>
<li><p>修改BS默认的横屏为竖屏</p>
<p>针对ZXing3.2.1版本，这里一共需要6步，需要提醒的是：不同的ZXing版本需要的步骤可能有差异，因为里面的源代码逻辑有修改。因此，有的时候尽信书不如无书，本文的步骤可能仅适合ZXing3.2.1，如果在ZXing其他版本上完成以下六步无法实现竖屏，或者修改之后会出错，请仔细排查(可以断点调试跟踪)。其实，要实现竖屏，从原理上应该是共通的，主要包括Activity本身的方向(属性)设置，同时关联到相机的参数(如预览窗口)调整等方面。</p>
<ul>
<li><p>第一步：调整CaptureActivity的方向为竖屏显示</p>
<p>   修改工程的AndroidManifest.xml,CaptureActivity的android:screenOrientation属性，设置为portrait</p>
   <!-- 调整扫描activity为竖屏,step1.调整activity的方向为竖屏 -->
   <activity android:name=".CaptureActivity" android:cleartaskonlaunch="true" android:screenorientation="portrait" android:statenotneeded="true" android:theme="@style/CaptureTheme" android:windowsoftinputmode="stateAlwaysHidden">
</activity></li>
<li><p>第二步：调整相机预览界面方向</p>
<p>   在 CameraConfigurationManager.setDesiredCameraParameters 的最后(或第一行也可)增加如下代码：<br>   //调整扫描activity为竖屏,step2.调整相机预览界面方向<br>   camera.setDisplayOrientation(90);<br>   注意：调整相机preview的时钟方向与手机竖屏的自然方向一致。该方法必须在相机的startPreview之前被调用，</p>
<pre><code>在预览界面展示出来后设置是无效的。
</code></pre></li>
<li><p>第三步：调整扫描窗口尺寸</p>
<p>   修改 CameraManager.getFramingRectInPreview()方法中的部分代码：<br>   原代码段为：</p>
<pre><code>rect.left = rect.left * cameraResolution.x / screenResolution.x;
rect.right = rect.right * cameraResolution.x / screenResolution.x;
rect.top = rect.top * cameraResolution.y / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
framingRectInPreview = rect;
</code></pre><p>   修改后代码段为：</p>
<pre><code>/*
 * 调整扫描activity为竖屏,step3.调整扫描窗口尺寸
 * 由于修改了屏幕的初始方向，手机分辨率由原来的 width\*height 变为 height\*width
 * 形式，但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
 */
rect.left = rect.left * cameraResolution.y / screenResolution.x;
rect.right = rect.right * cameraResolution.y / screenResolution.x;
rect.top = rect.top * cameraResolution.x / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.x / screenResolution.y;
framingRectInPreview = rect;
</code></pre><p>   原因：由于修改了屏幕的初始方向，手机分辨率由原来的 width*height 变为 height*width 形式，</p>
<pre><code>但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
</code></pre></li>
<li><p>第四步：将扫描框设置为正方形</p>
<p>   修改 CameraManager.getFramingRect()方法中的部分代码：<br>   原代码段为：</p>
<pre><code>int width = findDesiredDimensionInRange(screenResolution.x,
        MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = findDesiredDimensionInRange(screenResolution.y,
        MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect);
</code></pre><p>   修改后代码段为：</p>
<pre><code>/*
  * 调整扫描activity为竖屏,step4.将扫描框设置为正方形
 */
//后面设置height = width的前提下，如x&gt;y时可能会导致topOffset为负值，因此需要对此进行修正，加入下面这行代码
int resolutionMin = Math.min(screenResolution.x, screenResolution.y);
int width = findDesiredDimensionInRange(resolutionMin,
MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = width;//宽度等于高度，即为正方形
Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect);
</code></pre></li>
<li><p>第五步：反转扫描到的图形</p>
<pre><code>修改 DecodeHandler.decode 方法，增加以下代码：
</code></pre><p>   private void decode(byte[] data, int width, int height) {</p>
<pre><code>long start = System.currentTimeMillis();
Result rawResult = null;

/*
 * 调整扫描activity为竖屏,step5.反转扫描到的图形
 */
// 新增反转数据代码开始
byte[] rotatedData = new byte[data.length];
for (int y = 0; y &lt; height; y++) {
    for (int x = 0; x &lt; width; x++)
        rotatedData[x * height + height - y - 1] = data[x + y * width];
}
int tmp = width;
width = height;
height = tmp;
// 新增代码结束

PlanarYUVLuminanceSource source = activity.getCameraManager()
        .buildLuminanceSource(rotatedData, width, height);
//...后续代码
</code></pre><p>   }</p>
</li>
<li><p>第六步：(关键)修改CaptureActivity的onresume方法</p>
<pre><code>完成以上五步后，在ZXing的某些版本上应该是可以实现竖屏了，但是在3.2.1版本上，由于在CaptureActivity
的onresume方法里面涉及到了修改activity的方向，因此需要针对性修改这部分代码。
原代码段为：
   if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
   true)) {
       setRequestedOrientation(getCurrentOrientation());
   } else {
       setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
   }
</code></pre><p>   修改后代码段为：</p>
<pre><code>if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
true)) {
    setRequestedOrientation(getCurrentOrientation());
} else {
    // setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
}
</code></pre><p>   同时，需要修改getCurrentOrientation方法：<br>   原方法为：</p>
<pre><code>private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
    default:
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
    }
}
</code></pre><p>   修改后为：</p>
<pre><code>private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        // return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
    default:
        // return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
    }
}
</code></pre></li>
</ul>
</li>
<li><p>美化扫描界面</p>
<p>原生的扫描界面比较朴素，如果需要做出更漂亮些的扫描界面，就必须重写ViewfinderView类(res/layout/capture.xml布局中使用该类作为扫描窗口界面)。这里，我们为了实现类微信或支付宝的扫描界面效果，在将扫码界面修改为竖屏的基础上，可以做如下修改：</p>
<ul>
<li><p>在ViewfinderView类添加变量：</p>
<pre><code>/**
 * 四个边角对应的宽度
 */
 private static final int CORNER_WIDTH = 8;

/**
 * 四个边角对应的长度
 */
private int ScreenRate;

/**
 * 手机的屏幕密度
 */
private static float density;

/**
 * 四个边角的颜色
 */
private final int cornerColor;

/**
 * 扫描框中的中间线的宽度
 */
private static final int MIDDLE_LINE_WIDTH = 2;

/**
 * 扫描框中的中间线的与扫描框左右的间隙
 */
private static final int MIDDLE_LINE_PADDING = 10;

/**
 * 中间那条线每次刷新移动的距离
 */
private static final int SPEEN_DISTANCE = 5;

/**
 * 中间滑动线的最顶端位置
 */
private int slideTop;

/**
 * 中间滑动线的最底端位置
 */
private int slideBottom;

boolean isFirst;
</code></pre></li>
<li><p>修改ViewfinderView类的构造方法和onDraw方法。注：对于Android自定义View，绘制的核心就是onDraw方法。</p>
<p> a.在构造方法中添加初始化或设置变量的值：</p>
<p>   // This constructor is used when the class is built from an XML resource.<br>   public ViewfinderView(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);

// Initialize these once for performance rather than calling them every
// time in onDraw().
paint = new Paint(Paint.ANTI_ALIAS_FLAG);
Resources resources = getResources();
maskColor = resources.getColor(R.color.viewfinder_mask);
resultColor = resources.getColor(R.color.result_view);
laserColor = resources.getColor(R.color.viewfinder_laser);

//设置添加的变量值--start
cornerColor = Color.GREEN;
density = context.getResources().getDisplayMetrics().density;  
//将像素转换成dp  
ScreenRate = (int)(20 * density);  
//设置添加的变量值--end

resultPointColor = resources.getColor(R.color.possible_result_points);
scannerAlpha = 0;
possibleResultPoints = new ArrayList&lt;&gt;(5);
lastPossibleResultPoints = null;
</code></pre><p>   }</p>
<p>b.修改onDraw方法中部分代码：</p>
<p>修改前代码段：</p>
<p>   if (resultBitmap != null) {</p>
<pre><code>// Draw the opaque result bitmap over the scanning rectangle
paint.setAlpha(CURRENT_POINT_OPACITY);
canvas.drawBitmap(resultBitmap, null, frame, paint);
</code></pre><p>   } else {</p>
<pre><code>// Draw a red &quot;laser scanner&quot; line through the middle to show
// decoding is active
paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&lt;ResultPoint&gt; currentPossible = possibleResultPoints;
List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&lt;&gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

// Request another update at the animation interval, but only
// repaint the laser line,
// not the entire viewfinder mask.
postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
        frame.top - POINT_SIZE, frame.right + POINT_SIZE,
        frame.bottom + POINT_SIZE);
</code></pre><p>   }</p>
<p>修改后代码段：</p>
<p>   if (resultBitmap != null) {<br>   // Draw the opaque result bitmap over the scanning rectangle<br>   paint.setAlpha(CURRENT_POINT_OPACITY);<br>   canvas.drawBitmap(resultBitmap, null, frame, paint);<br>   } else {</p>
<pre><code>// Draw a red &quot;laser scanner&quot; line through the middle to show
// decoding is active
/*paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);*/

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&lt;ResultPoint&gt; currentPossible = possibleResultPoints;
List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&lt;&gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

/*
 * 如下为了优化扫描框，绘制边角
 */
paint.setColor(cornerColor);
canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
        + ScreenRate, frame.bottom, paint);
canvas.drawRect(frame.left, frame.bottom - ScreenRate, frame.left
        + CORNER_WIDTH, frame.bottom, paint);
canvas.drawRect(frame.right - ScreenRate, frame.bottom
        - CORNER_WIDTH, frame.right, frame.bottom, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom
        - ScreenRate, frame.right, frame.bottom, paint);

/*
 * 如下绘制中间上下滚动的横线
 */
//初始化中间线滑动的最上边和最下边
if(!isFirst){
    isFirst = true;
    slideTop = frame.top;
    slideBottom = frame.bottom;
}

//绘制中间的线,每次刷新界面，中间的线往下移动SPEEN_DISTANCE
slideTop += SPEEN_DISTANCE;
if(slideTop &gt;= frame.bottom){
    slideTop = frame.top;
}
canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
            frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);
</code></pre></li>
</ul>
</li>
</ol>
<pre><code>            // Request another update at the animation interval, but only
            // repaint the laser line,
            // not the entire viewfinder mask.
            postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
                    frame.top - POINT_SIZE, frame.right + POINT_SIZE,
                    frame.bottom + POINT_SIZE);
        }

**注意**：上面的代码中，中间那根线微信是用的图片(图片可以自己制作，也可以反编译微信apk从中获取)，这里是画的线条，如果你想更加仿真点就将下面的代码：

    canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
                frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);



修改为：

    Rect lineRect = new Rect();  
    lineRect.left = frame.left;  
    lineRect.right = frame.right;  
    lineRect.top = slideTop;  
    lineRect.bottom = slideTop + 18;  
    canvas.drawBitmap(((BitmapDrawable)(getResources().getDrawable(R.drawable.qrcode_scan_line))).getBitmap(), null, lineRect, paint);  
</code></pre><h3 id="4-实战并整合"><a href="#4-实战并整合" class="headerlink" title="4.实战并整合"></a>4.实战并整合</h3><p>待续(实际使用中，一般都是应用APP包括了扫描功能，而不是将扫码功能单独作为一个APP，因此需要对BS工程进行简化，使其可以作为其他应用工程的依赖lib，并去除那些不需要的功能，然后就直接整合进APP。)</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/ZXing开源项目实战/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Eclipse动态调试指南" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Eclipse动态调试指南/">Eclipse动态调试Android应用指南</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态调试/">动态调试</a></li></ul>
</div>
        <time datetime="2016-06-13T07:41:13.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="Eclipse动态调试指南"><a href="#Eclipse动态调试指南" class="headerlink" title="Eclipse动态调试指南"></a>Eclipse动态调试指南</h1><p>本文对Eclipse进行动态调试做一个全面的讲解（动态调试还可以采用netbeans等工具，暂不阐述），旨在为广大只有apk而没有源代码的程序猿提供排查bug的另辟蹊径。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-反编译"><a href="#1-反编译" class="headerlink" title="1.反编译"></a>1.反编译</h2><p>对目标apk使用apktool反编译出可调试的smali代码到out文件夹，目前apktool最新的版本是2.0.1。</p>
<pre><code>e.g. java -jar apktool_2.0.1.jar d -d target.apk -o out
</code></pre><p>注意:-d参数是必须的，因为这样反编译出来的代码后缀均是java，因为只有java文件才能被eclipse/netbeans识别调试。</p>
<h2 id="2-设置调试标记"><a href="#2-设置调试标记" class="headerlink" title="2.设置调试标记"></a>2.设置调试标记</h2><p>在输出的out文件夹中，用文本编辑工具打开AndroidManifest.xml，在application节点中设置属性android:debuggable=”true”。</p>
<pre><code>e.g. &lt;application android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;com.boyaa.godsdk.core.MutiUnipayApplication&quot;&gt;
</code></pre><h2 id="3-在主Activity的onCreate事件中添加调试等待-可选"><a href="#3-在主Activity的onCreate事件中添加调试等待-可选" class="headerlink" title="3.在主Activity的onCreate事件中添加调试等待(可选)"></a>3.在主Activity的onCreate事件中添加调试等待(可选)</h2><p><strong>注意:如果不需要在程序的开头调试的话，建议忽略这一步。</strong></p>
<p>用文本编辑工具打开主类文件，找到onCreate方法，在第一句前插入invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V，记得添加a=0;//的前缀保持上下一致，结果如下：</p>
<pre><code>a=0;// # virtual methods
a=0;// .method protected onCreate(Landroid/os/Bundle;)V
a=0;//     invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V
a=0;// 
a=0;//     .locals 1
a=0;//     .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;
a=0;// 
a=0;//     .prologue
a=0;//     .line 11
a=0;//     invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V
</code></pre><h2 id="4-保存文件，用apktool重新编译打包为debug-apk"><a href="#4-保存文件，用apktool重新编译打包为debug-apk" class="headerlink" title="4.保存文件，用apktool重新编译打包为debug.apk"></a>4.保存文件，用apktool重新编译打包为debug.apk</h2><pre><code>e.g. java -jar apktool_2.0.1.jar b -d out -o debug.apk
</code></pre><h2 id="5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk"><a href="#5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk" class="headerlink" title="5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk"></a>5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk</h2><p>当然也可以直接采用JDK里面的签名工具通过命令行手动进行签名：<br>    e.g. “jarsigner” -keystore “C:\Users\CoulsonChen\Desktop\kop.keystore” -storepass “kop1122334” -keypass “kop1122334” “D:\t\125.apk” “kop” -sigalg SHA1withRSA -digestalg SHA1</p>
<h2 id="6-上传debug-sign-apk至手机或模拟器，然后安装并运行。"><a href="#6-上传debug-sign-apk至手机或模拟器，然后安装并运行。" class="headerlink" title="6.上传debug_sign.apk至手机或模拟器，然后安装并运行。"></a>6.上传debug_sign.apk至手机或模拟器，然后安装并运行。</h2><p>如果启用第3步，这时你会看到程序运行后停留在白屏界面，这时不要动设备和退出程序，因为程序现在是运行到刚才添加的waitForDebugger代码这里，这行代码的意思是一直挂起中，等待调试器。</p>
<p>如果未启用第3步，则apk正常运行(与普通安装apk无异)。</p>
<h2 id="7-启动eclipse，构建java项目"><a href="#7-启动eclipse，构建java项目" class="headerlink" title="7.启动eclipse，构建java项目"></a>7.启动eclipse，构建java项目</h2><ol>
<li>File -&gt; New -&gt; Project -&gt; Java Project -&gt; Next</li>
<li>Project Name随便起，Use default location选项去掉，Location选择第1步指定的out文件夹，然后Next</li>
<li>把smali文件夹设为Source Folder，然后Finish</li>
</ol>
<h2 id="8-在eclipse中，在需要关注的地方添加断点"><a href="#8-在eclipse中，在需要关注的地方添加断点" class="headerlink" title="8.在eclipse中，在需要关注的地方添加断点"></a>8.在eclipse中，在需要关注的地方添加断点</h2><p>设置断点示例：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-breakpoint.png" alt="设置断点示意图"></p>
<p>打开DDMS（路径在%android-sdks%\tools\ddms.bat）,如果在第6步中运行了修改后的程序，在DDMS的设备列表中会显示可以调试的程序。<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-DDMS.png" alt="DDMS的设备列表"></p>
<p>从上图可以看到，调试的端口为8608</p>
<h2 id="9-现在要做的就是把代码与调试程序关联即可"><a href="#9-现在要做的就是把代码与调试程序关联即可" class="headerlink" title="9.现在要做的就是把代码与调试程序关联即可"></a>9.现在要做的就是把代码与调试程序关联即可</h2><p>回到eclipse，配置远程调试</p>
<ol>
<li>菜单Run -&gt; Debug -&gt; Debug Configurations</li>
<li>双击Remote Java Application，Host处默认localhost就行，Port填第9步得到的8608，然后Apply -&gt; Debug。</li>
</ol>
<p>示意图：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-relation.png" alt="关联源码和程序"></p>
<h2 id="10-切换至debug视图"><a href="#10-切换至debug视图" class="headerlink" title="10.切换至debug视图"></a>10.切换至debug视图</h2><p>看到程序已经运行并中断在下一行可执行的代码了，相关的变量可以直接查看了。示意图：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-debug.png" alt="最终调试"></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Eclipse动态调试指南/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-apktool打包之后包体变大" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/apktool打包之后包体变大/">apktool打包之后apk包体变大</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apktool打包/">Apktool打包</a></li></ul>
</div>
        <time datetime="2016-06-13T07:40:18.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="apktool打包之后apk包体变大"><a href="#apktool打包之后apk包体变大" class="headerlink" title="apktool打包之后apk包体变大"></a>apktool打包之后apk包体变大</h1><p>原因：应该是apktool 2.0.3版本之后引入了两个字段</p>
<ul>
<li><p>compressionType: </p>
</li>
<li><p>doNotCompress:</p>
</li>
</ul>
<p>这两个字段会决定重新编译apk时哪些类型的文件不会压缩，从而影响最终生成的apk的包体大小。</p>
<ol>
<li>解决办法一：</li>
</ol>
<p>请对比apktool 2.0.1和2.1.1版本反编译之后目录下的apktool.yml文件：</p>
<p><strong>2.0.1：</strong><br><img src="http://i.imgur.com/IO5RRBr.png" alt=""></p>
<p><strong>2.1.1：</strong><br><img src="http://i.imgur.com/SOVelmB.png" alt=""></p>
<p>因此，可以动态调整doNotCompress字段中不压缩的文件类型(比如删除图中的- lua行)，来达到压缩的效果，从而使得包体大小保持与原有大小基本一致。</p>
<ol>
<li><p>解决办法二：<br> 既然apktool 2.0.1及其之下版本未引入doNotCompress字段，那么可以采用高版本的apktool释放的1.apk(framework)来作为apktool 2.0.1及其之下版本重编译时的框架依赖。这样可以解决2.0.1重编译依赖Android6.0系统特性的apk失败的问题。</p>
<p> 举例：首先用apktool 2.0.1反编译target.apk，然后将更高版本的apktool释放(反编译操作时候就会自动释放出来)的1.apk覆盖掉apktool 2.0.1的1.apk，1.apk文件一般放在Home_dir\apktool\framework\1.apk,其中Home_dir是操作系统的默认Home目录，windows平台可以打开cmd，提示的目录即为Home_dir。当然也可以采用Everything搜索等工具全局搜索下就知道其路径了。最后，用apktool 2.0.1版本重新编译target.apk反编译时生成的目录，即可编译成功。</p>
</li>
</ol>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/apktool打包之后包体变大/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Android热修复的思路" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Android热修复的思路/">Android热修复</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android热修复/">Android热修复</a></li></ul>
</div>
        <time datetime="2016-06-13T07:38:15.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="Android热修复的方式"><a href="#Android热修复的方式" class="headerlink" title="Android热修复的方式"></a>Android热修复的方式</h1><p>关于动态热修复，目前发现的思路集中在三点：</p>
<ul>
<li><p>方式1：既然是热修复，那么就是新的类替换掉旧的类，而java世界类的加载是通过类加载器来实现，而Android应用程序的默认类加载器PathClassLoader加载的时候其实是通过关联的DexFile来实现(动态加载的时候已经反复涉及，这里不再赘述)，当有多个Dex文件的时候，是按照dexElements中的顺序来执行，如果一旦加载到则返回该类，否则遍历查询dexElements中的所有元素，直到最终查询完，那么基于这个事实，则可以将新类的dex文件加载的时候对应的Element放置在最前面，这样PathClassLoader加载的时候就自然先加载到新类而不是旧的有问题的类，但是这种机制在多个mutildex时存在缺陷，具体请参见下面转发链接的阐述，另外一旦某个类已经被加载，则失效了，因为一旦被加载之后，PathClassLoader的loadClass已经直接返回class而不会去查询，这样使得往往下载修复包之后需要在下次启动才能加载。当然这个办法基于纯java实现，非侵入性，与平台无关；</p>
</li>
<li><p>方式2：基于阿里的AndFix开源项目，这个的出发点是另外一个角度，类被类加载器加载进来之后，那么其实本质还是虚拟机在管理，而根据java虚拟机包括Dalvik虚拟机的内存模型(可以查看我那本深入理解java虚拟机书籍相关章节)，类的class文件加载进来之后存放在方法区，那么既然已经认定这个类被加载了，怎么做到热修复，阿里的方式确实巧妙，因为java虚拟机本身是C++语言实现的，通过JNI的方式可以获取到方法区中方法的引用，修改方法内部的执行引用，具体的还需要更加深入研究，将方法的执行逻辑指向了新方法，这种情况下可以做到及时加载及时修复，不用重启应用，缺点是通过JNI方式，so的兼容性决定了适用性，不过阿里的做得已经不错，当然一旦Android平台的虚拟机内部实现改变，就需要重新修改so对应的C++代码，目前首选这个方式；</p>
<p>  另外，生成新旧dex的patch也是一个关键点，阿里提供了这样一个工具：AppPatch。生成patch的过程，大概是基于smali和baksmali，先加载新的和旧的两个dex文件得到所有的class，然后通过getImplementation()方法可对比他们的方法实现是否一致，将对比结果分成添加的方法/字段和修改的方法/字段分别保存起来，在重新生成的差异化dex文件时，根据对比结果在相应的方法或者字段前添加注解标志。要深入理解的话需要熟悉一下smali/baksmali的源码以及dalvik虚拟机的文件结构。</p>
</li>
</ul>
<ul>
<li>方式3：阿里的Dexposed开源项目，也是纯java实现，基于大名鼎鼎的 Xposed framework project开源项目，面向AOP切面编程的思想，目前还没有很深入研究，可能与方式1有些类似，也可能基于动态代理等方式来做到。不过目前这个项目只能适用于5.0以下系统，目前不建议使用。</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ol>
<li><p>关于方式1：</p>
<p> <a href="http://blog.csdn.net/lzyzsd/article/details/49843581" target="_blank" rel="external">http://blog.csdn.net/lzyzsd/article/details/49843581</a>，</p>
<p> <a href="https://github.com/jasonross/Nuwa">https://github.com/jasonross/Nuwa</a></p>
</li>
<li><p>关于方式2：</p>
<p> <a href="https://github.com/alibaba/AndFix" title="阿里的AndFix开源项目">https://github.com/alibaba/AndFix</a></p>
</li>
<li><p>关于方式3：</p>
<p> <a href="https://github.com/alibaba/dexposed" title="阿里的dexposed开源项目">https://github.com/alibaba/dexposed</a></p>
</li>
</ol>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Android热修复的思路/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Android动态加载机制" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Android动态加载机制/">Android动态加载机制</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态加载/">动态加载</a></li></ul>
</div>
        <time datetime="2016-06-13T07:36:18.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>在Android开发中，存在一些场景：</p>
<ol>
<li><p>在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？<br> 引用官方原文<a href="http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about" title="每个Dex的方法数不能超过65535" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about</a>：</p>
<pre><code>`Both these error conditions display a common number: 65,536. This number is significant in that it represents the total number of references that can be invoked by the code within a single Dalvik Executable (dex) bytecode file. If you have built an Android app and received this error, then congratulations, you have a lot of code! This document explains how to move past this limitation and continue building your app.`
</code></pre></li>
<li><p>众所周知，Android进行反编译APK获取其中的资源和代码相对比较容易，那么在某些特定场景和功能，开发者不希望其核心代码被他人轻易反编译破解，此时应该怎么办？安全方面的考虑，比如in-app purchase？</p>
</li>
<li>随着Android的发展，应用的功能越来越多，越来越复杂，其APK大小也跟随着膨胀，而APK的大小影响着用户的接受程度，许多应用市场也会限制上传包的大小，如何做到既减小APK的大小，同时又可以扩展更多功能？扩展考虑？</li>
<li>其他？热插拔？类似插件的机制？…</li>
</ol>
<p>以上的问题自然就引出一个概念，能不能动态地加载Android代码或者资源，甚至动态加载APK执行？</p>
<p>答案是肯定的！熟悉Java的朋友应该了解JVM可以动态加载类，核心思想是通过ClassLoader加载本地的或者从网络传输获得的类代码，从而可以在运行时动态加载类。Android平台的应用开发主要采用Java语言，而dalvik虚拟机的类加载机制类似于JVM。</p>
<p>本文先介绍JVM的类加载原理，讲述Java最基本的类加载机制，为Android类加载做铺垫。然后，重点介绍Android的类加载机制，及常见的实现方式。最后，在前面的基础上，扩展开来，从Android的类加载引申到更广泛的层面上，即动态加载机制(插件机制)、安全方面。从这里可以看到，整个发展历程成阶梯上升，前面的是基础也是基石，而越到后面才是实际开发中更常见的场景，也是更加复杂和综合的应用。概括之，<strong>Android的动态加载机制发展历程：普通的类(Class文件)加载-&gt;普通jar包(包含dex)加载-&gt;包含资源的jar加载-&gt;直接加载其他应用程序APK</strong>。</p>
<h1 id="2-JVM的类加载机制"><a href="#2-JVM的类加载机制" class="headerlink" title="2.JVM的类加载机制"></a>2.JVM的类加载机制</h1><p>Java的类(class)文件是通过类加载器来加载的，每一个类加载器，都拥有一个独立的类名称空间，因此，只有比较两类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>注意：上面提及的“相等”概念，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象关系判断等情况。</strong></p>
<h2 id="2-1-双亲委派模型"><a href="#2-1-双亲委派模型" class="headerlink" title="2.1 双亲委派模型"></a>2.1 双亲委派模型</h2><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器均有Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。</p>
<p>从Java程序员的角度来看，类加载器划分得更细致一些，绝大部分Java程序都会使用到一下3种系统提供的类加载器：</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader):这个类加载器负责将存放在<java_home>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可。</java_home></li>
<li>扩展类加载器(Extension ClassLoader)：该加载器由sun.misc.Launcher$ExtClassLoader实现，其负责加载<java_home>/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li>
<li>应用程序类加载器(Application ClassLoader)：该类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般也称它为系统类加载器。其负责加载用户类路径(ClassPath)上所指定的库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的关系一般如下图所示：<br><img src="http://i.imgur.com/YR2iX5b.png" alt="ClassLoader之间关系"></p>
<p>上图中的这种层次关系，被称为类加载器的双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合的关系来复用父类加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并被广发应用于之后的几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p><strong>双亲委派模型的工作过程：</strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p>
<p>类加载由类加载器的loadClass方法执行，而<strong>实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass方法之中</strong>，如下面代码(基于JDK 1.7版本的源码)所示，其逻辑为：<strong>先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法执行自定义的加载过程</strong>。</p>
<pre><code>/**
 * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The
 * default implementation of this method searches for classes in the
 * following order:
 *
 * &lt;p&gt;&lt;ol&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method
 *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class
 *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 *   class.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; If the class was found using the above steps, and the
 * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link
 * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.
 *
 * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override {@link
 * #findClass(String)}, rather than this method.  &lt;/p&gt;
 *
 * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 * {@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;} method
 * during the entire class loading process.
 *
 * @param  name
 *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
 *
 * @param  resolve
 *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class
 *
 * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
 *
 * @throws  ClassNotFoundException
 *          If the class could not be found
 */
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre><h2 id="2-2-类加载过程"><a href="#2-2-类加载过程" class="headerlink" title="2.2 类加载过程"></a>2.2 类加载过程</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)，这7个阶段顺序如下图所示：</p>
<p><img src="http://i.imgur.com/wwFyQk9.png" alt="ClassLoading process"></p>
<p>上图中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地执行，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也被称为动态绑定或晚期绑定)。</p>
<h1 id="3-Android中的类加载机制"><a href="#3-Android中的类加载机制" class="headerlink" title="3.Android中的类加载机制"></a>3.Android中的类加载机制</h1><p>Android的类加载机制与JVM的类加载机制类似。也采用了双亲委派模型。Android系统定义的ClassLoader相关类的架构如下图所示：</p>
<p><img src="http://i.imgur.com/FWdhXzZ.png" alt="Android的ClassLoader架构"></p>
<p>如上图所示，ClassLoader是整个类加载器的顶层类，其为抽象类，实现了类加载器所要求的通用架构。Android中提供了几个该类的具体实现类，比如dalvik.system.PathClassLoader，应用程序可以实现ClassLoader来提供加载类的特殊方式。</p>
<h2 id="3-1-Android中的主要类加载器介绍"><a href="#3-1-Android中的主要类加载器介绍" class="headerlink" title="3.1 Android中的主要类加载器介绍"></a>3.1 Android中的主要类加载器介绍</h2><p>从上图可知，java.lang.ClassLoader是类加载器的顶层类，dalvik.system.BaseDexClassLoader是为各种基于dex的类加载器的实现提供一个基本功能的基类。其子类dalvik.system.PathClassLoader和dalvik.system.DexClassLoader是我们关注的重点，负责具体的类加载。</p>
<ol>
<li><p><strong>dalvik.system.PathClassLoader</strong></p>
<p> Android源码的解释是：</p>
<pre><code>Provides a simple ClassLoader implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s).
</code></pre><p> 大意是，PathClassLoader可以加载包含在本地文件系统中的文件和目录列表中代码和资源，但是无法从网络加载类。Android本身采用该类加载器作为其系统的和应用程序的默认类加载器，换句话说，Android系统的框架层的类和应用程序默认情况下的类加载均有该类来完成。那么要实现自定义的类加载器，采用该类就不太可行了，那只能另辟蹊径。</p>
</li>
<li><p><strong>dalvik.system.DexClassLoader</strong><br> Android源码的解释是：</p>
<pre><code>A class loader that loads classes from .jar and .apk files containing a classes.dex entry. This can be used to execute code not installed as part of an application.

This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getCodeCacheDir() to create such a directory:

   File dexOutputDir = context.getCodeCacheDir();

Do not cache optimized classes on external storage. External storage does not provide access controls necessary to protect your application from code injection attacks.
</code></pre><p> 从上面说明不难看出，DexClassLoader可以从包含dex的jar或者apk文件中加载类和资源，用于加载应用程序非安装时附带的代码。这恰恰就是我们所需要的，因为我们希望在应用运行期间，动态地从文件系统或者从网络下载包含dex的文件，然后加载进内存执行。</p>
<p> <strong>请注意：DexClassLoader需要提供一个目录用于缓存优化的class文件，因此为了安全，请将该目录设置为应用程序私有的目录，不要采用外部存储目录。</strong></p>
<p> DexClassLoader有一个构造方法：</p>
<pre><code>public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)
</code></pre><p> 其中，dexPath为包含dex的jar或者apk的存放路径，optimizedDirectory代表存放优化的dex的目录，libraryPath代表本地代码存放的路径，parent指定父加载器，一般采用Context调用getClassLoader()获取并传入，如果传入null，则采用启动类加载器作为父加载器。</p>
<p> DexClassLoader负责加载类的方法仍是继承自ClassLoader的loadClass方法：</p>
<pre><code>Class&lt;?&gt; java.lang.ClassLoader.loadClass(String className) throws ClassNotFoundException
</code></pre></li>
</ol>
<h2 id="3-2-DexClassLoader加载类示例"><a href="#3-2-DexClassLoader加载类示例" class="headerlink" title="3.2 DexClassLoader加载类示例"></a>3.2 DexClassLoader加载类示例</h2><p>既然我们可以直接使用DexClassLoader来动态加载应用程序外部的dex，那么这个过程具体是怎样的呢，且看下文分解。</p>
<h3 id="3-2-1-DexClassLoader加载示例1"><a href="#3-2-1-DexClassLoader加载示例1" class="headerlink" title="3.2.1 DexClassLoader加载示例1"></a>3.2.1 DexClassLoader加载示例1</h3><p>本示例来自Google官方blog，具体地址为<a href="http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html" title="Custom Class Loading in Dalvik" target="_blank" rel="external">http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html</a>，源码也可以从该网址中的链接下载<a href="http://code.google.com/p/android-custom-class-loading-sample" title="sample下载" target="_blank" rel="external">http://code.google.com/p/android-custom-class-loading-sample</a>，本文另外提供一个地址下载(本文作者修改后在本地运行的版本，主要涉及修改里面的local.properties，配置本地的Android SDK tools的安装目录)，下载请点击：<a href="http://172.20.154.39:8080/android-custom-class-loading-sample.zip" title="Sample本地下载地址" target="_blank" rel="external">本地Sample下载</a></p>
<p>这里摘录其中的步骤，并做一个简单描述。</p>
<ol>
<li><p>代码结构：</p>
<p> 该应用程序包含三个类：</p>
<ul>
<li>com.example.dex.MainActivity: 调用库代码的UI组件</li>
<li>com.example.dex.LibraryInterface: 库代码API的接口定义</li>
<li><p>com.example.dex.lib.LibraryProvider: lib库的实现</p>
<p>lib库打包进第二个dex, 而剩下的类被装入主dex(也就是默认的dex)。下面的构建章节详细地阐述了怎么实现这个目的。当然，实际情况下的的打包的策略依赖于开发者实际要处理的特定场景。</p>
</li>
</ul>
</li>
<li><p>类加载和方法调用：</p>
<p> 包含lib库的第二个dex文件，存储在应用程序的assets目录。首先，第二个dex文件必须复制到类加载可以直接加载的文件路径(Android内核是Linux，则path的形式与普通的linux文件路径类似)，本示例代码采用应用APP的私有内部储存区域来存放该dex(从技术层面来说，外部存储也可以满足需求，但是考虑到安全性，建议保存在内部存储)。<br> 如下是MainActivity的代码片段。</p>
<pre><code>// Before the secondary dex file can be processed by the DexClassLoader,
// it has to be first copied from asset resource to a storage location.
File dexInternalStoragePath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE),
        SECONDARY_DEX_NAME);
...
BufferedInputStream bis = null;
OutputStream dexWriter = null;

static final int BUF_SIZE = 8 * 1024;
try {
    bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));
    dexWriter = new BufferedOutputStream(
        new FileOutputStream(dexInternalStoragePath));
    byte[] buf = new byte[BUF_SIZE];
    int len;
    while((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) {
        dexWriter.write(buf, 0, len);
    }
    dexWriter.close();
    bis.close();

} catch (. . .) {...}
</code></pre><p> 下一步，初始化创建一个DexClassLoader去加载从第二个dex中提取出来的库。有几种方式可以调用加载类的方法。在本示例中，类实例被强制转换成其实现的接口，这样就通过调用接口中定义的方法直接调用。这样的方式更方便，当然，通过反射获取Method，然后Method调用invoke方法也是可行，但反射更加复杂且比较慢。但利用反射也有其优点，即不需要第二个dex文件中的lib库实现特定的接口。</p>
<pre><code>// Internal storage where the DexClassLoader writes the optimized dex file to
final File optimizedDexOutputPath = getDir(&quot;outdex&quot;, Context.MODE_PRIVATE);

DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),
                                       optimizedDexOutputPath.getAbsolutePath(),
                                       null,
                                       getClassLoader());
Class libProviderClazz = null;
try {
    // Load the library.
    libProviderClazz =
        cl.loadClass(&quot;com.example.dex.lib.LibraryProvider&quot;);
    // Cast the return object to the library interface so that the
    // caller can directly invoke methods in the interface.
    // Alternatively, the caller can invoke methods through reflection,
    // which is more verbose. 
    LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();
    lib.showAwesomeToast(this, &quot;hello&quot;);
} catch (Exception e) { ... }
</code></pre></li>
<li><p>构建过程(build process)</p>
<p> 为了生成两个独立的dex文件，我们需要调整标准的构建过程。为了实现该技巧，可以简单地修改工程的Ant构建配置文件build.xml中到的”dex” target标签。</p>
<p> 修改后的”dex” target标签执行下列操作：</p>
</li>
</ol>
<pre><code>a. 创建两个存储目录，用于存储默认dex和第二个dex；

b. 选择性地从PROJECT_ROOT/bin/classes复制class文件至上面的两个目录；

    &lt;!-- Primary dex to include everything but the concrete library
             implementation. --&gt;
        &lt;copy todir=&quot;${out.classes.absolute.dir}.1&quot; &gt;
            &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;
                    &lt;exclude name=&quot;com/example/dex/lib/**&quot; /&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;
        &lt;!-- Secondary dex to include the concrete library implementation. --&gt;
        &lt;copy todir=&quot;${out.classes.absolute.dir}.2&quot; &gt;
            &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;
                    &lt;include name=&quot;com/example/dex/lib/**&quot; /&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;   

 c.将上述两个目录中的.class文件转换成两个独立的dex文件；

 d.将第二个dex文件添加到一个jar文件中，jar文件是DexClassLoader期望的输入格式(其实只要里面包含dex即可)。最后，存储该jar文件至工程的assets目录。

     &lt;!-- Package the output in the assets directory of the apk. --&gt;
        &lt;jar destfile=&quot;${asset.absolute.dir}/secondary_dex.jar&quot;
               basedir=&quot;${out.absolute.dir}/secondary_dex_dir&quot;
               includes=&quot;classes.dex&quot; /&gt;

为了达成上面的构建目的，需要在工程目录下执行&quot;ant debug&quot;或者&quot;ant release&quot;命令(前提是需要下载apache的[Ant构建工具](https://www.apache.org/dist/ant/ &quot;Ant&quot;)，且不能使用Eclipse的自动构建方式)。
</code></pre><h3 id="3-2-2-DexClassLoader加载示例2"><a href="#3-2-2-DexClassLoader加载示例2" class="headerlink" title="3.2.2 DexClassLoader加载示例2"></a>3.2.2 DexClassLoader加载示例2</h3><p>示例1主要是定制了ant的构建过程，这样在生成apk的时候已经对class文件加以分割，生成了独立的多个dex文件，并且自动地放入了apk的assets目录。运行时，非默认dex采用DexClassLoader加载。如果觉得修改Eclipse自动构建过程麻烦(主要是需要配置build.xml)，更直观的方式是，新建一个空工程，将lib库的包copy进去，编译该工程，会在工程的bin目录下生成代码相关的jar文件，再利用dex2jar工具将jar转换成第二个dex即可，将第二个dex放入工程的assets目录，其他步骤与示例1完全一致。或者，直接新建的工程，从生成的apk从提取dex(即第二个dex)，然后放入工程的assets目录，其他方面别无二样。</p>
<h3 id="3-3-DexClassLoader加载的缺点，类加载的进一步探索"><a href="#3-3-DexClassLoader加载的缺点，类加载的进一步探索" class="headerlink" title="3.3 DexClassLoader加载的缺点，类加载的进一步探索"></a>3.3 DexClassLoader加载的缺点，类加载的进一步探索</h3><p>从上面的示例和DexClassLoader的API不难发现，DexClassLoader加载类的时候必须知道dex path，而且需要指定存放优化的dex目录，这就是说，DexClassLoader工作前提是必须将<font color="red"><strong>dex存放在文件系统</strong></font>中，虽然可以存放在应用程序私有的目录中，但是一旦黑客绕过这道Android系统的文件权限管理的篱笆，那么就能获取到dex文件，然后反编译并获取其中的内容。所以，DexClassLoader这样的加载机制存在安全问题。那么，怎么样回避这个问题呢？</p>
<p>一个直观的方法，就是能不能直接对dex文件进行加密，这样即使保存在文件系统，其他人要想破解则必须先解密dex。但是，一旦加密dex，那么在加载的时候也必须先进行解密，解密的过程如果用java来完成，那仍然是不安全的。另外，优化的dex仍然需保存在文件系统中，这还是不可行。</p>
<p>从上面讲述的类加载的双亲委派模型可知，一个类加载器，先委派父类加载器去加载，如果无法加载，则调用自身的findClass方法去按照自定义方式加载类。关键就在于此，其实DexClassLoader替我们处理好了底层的封装细节，我们只是调用了DexClassLoader的loadClass方法而已。那么，要想突破DexClassLoader的缺陷，也就不得不深入研究下DexClassLoader本身的loadClass和findClass方法，从中寻找蛛丝马迹，抑或一种启发，进而编写属于我们自己的DexClassLoader。</p>
<p>其实，Android4.0版本增加了对内存中DEX数据的动态加载(稍后看源码可以确认这一点)，这样就克服了使用DexClassLoader时DEX以文件形式明文存放在存储设备上的缺点，内存中DEX数据可以来源于解密后的文件或者网络。这样就增加了DEX数据的安全性。但是DexClassLoader并没有暴露该种加载方式。开发者需要在JAVA层实现自己的Dex ClassLoader。本文提供两个Android源码下载的链接地址：</p>
<p>Android官方下载地址：<a href="https://android.googlesource.com" title="Android官方源码" target="_blank" rel="external">https://android.googlesource.com</a></p>
<p>Web在线浏览及下载地址：<a href="http://androidxref.com" title="Android源码web在线浏览和下载" target="_blank" rel="external">http://androidxref.com</a></p>
<ul>
<li><p>DexClassLoader的源码(下面基于ICS4.0.3的源码)：</p>
<pre><code>/**
 * A class loader that loads classes from {@code .jar} and {@code .apk} files
 * containing a {@code classes.dex} entry. This can be used to execute code not
 * installed as part of an application.
 *
 * &lt;p&gt;This class loader requires an application-private, writable directory to
 * cache optimized classes. Use {@code Context.getDir(String, int)} to create
 * such a directory: &lt;pre&gt;   {@code
 *   File dexOutputDir = context.getDir(&quot;dex&quot;, 0);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;
 * External storage does not provide access controls necessary to protect your
 * application from code injection attacks.
 */
public class DexClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code DexClassLoader} that finds interpreted and native
     * code.  Interpreted classes are found in a set of DEX files contained
     * in Jar or APK files.
     *
     * &lt;p&gt;The path lists are separated using the character specified by the
     * {@code path.separator} system property, which defaults to {@code :}.
     *
     * @param dexPath the list of jar/apk files containing classes and
     *     resources, delimited by {@code File.pathSeparator}, which
     *     defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     *     should be written; must not be {@code null}
     * @param libraryPath the list of directories containing native
     *     libraries, delimited by {@code File.pathSeparator}; may be
     *     {@code null}
     * @param parent the parent class loader
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}
</code></pre><p>可以看出，DexClassLoader本身没有任何逻辑，只是继承了BaseDexClassLoader，并提供了一个构造器而已。</p>
</li>
<li><p>BaseDexClassLoader源码：</p>
<pre><code>/**
 * Base class for common functionality between various dex-based
 * {@link ClassLoader} implementations.
 */
public class BaseDexClassLoader extends ClassLoader {
    /** originally specified path (just used for {@code toString()}) */
    private final String originalPath;

    /** structured lists of path elements */
    private final DexPathList pathList;

    /**
     * Constructs an instance.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     * should be written; may be {@code null}
     * @param libraryPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
    public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(parent);

        this.originalPath = dexPath;
        this.pathList =
            new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        Class clazz = pathList.findClass(name);

        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }

        return clazz;
    }

    @Override
    protected URL findResource(String name) {
        return pathList.findResource(name);
    }

    @Override
    protected Enumeration&lt;URL&gt; findResources(String name) {
        return pathList.findResources(name);
    }

    @Override
    public String findLibrary(String name) {
        return pathList.findLibrary(name);
    }

    /**
     * Returns package information for the given package.
     * Unfortunately, instances of this class don&apos;t really have this
     * information, and as a non-secure {@code ClassLoader}, it isn&apos;t
     * even required to, according to the spec. Yet, we want to
     * provide it, in order to make all those hopeful callers of
     * {@code myClass.getPackage().getName()} happy. Thus we construct
     * a {@code Package} object the first time it is being requested
     * and fill most of the fields with dummy values. The {@code
     * Package} object is then put into the {@code ClassLoader}&apos;s
     * package cache, so we see the same one next time. We don&apos;t
     * create {@code Package} objects for {@code null} arguments or
     * for the default package.
     *
     * &lt;p&gt;There is a limited chance that we end up with multiple
     * {@code Package} objects representing the same package: It can
     * happen when when a package is scattered across different JAR
     * files which were loaded by different {@code ClassLoader}
     * instances. This is rather unlikely, and given that this whole
     * thing is more or less a workaround, probably not worth the
     * effort to address.
     *
     * @param name the name of the class
     * @return the package information for the class, or {@code null}
     * if there is no package information available for it
     */
    @Override
    protected synchronized Package getPackage(String name) {
        if (name != null &amp;&amp; !name.isEmpty()) {
            Package pack = super.getPackage(name);

            if (pack == null) {
                pack = definePackage(name, &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;,
                        &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;, null);
            }

            return pack;
        }

        return null;
    }

    @Override
    public String toString() {
        return getClass().getName() + &quot;[&quot; + originalPath + &quot;]&quot;;
    }
}
</code></pre></li>
</ul>
<p>分析得之，BaseDexClassLoader覆写了ClassLoader的findClass方法(loadClass方法根据前面所述的双亲委派模型介绍可知是实现双亲委派模型的基础，官方是建议不要修改该方法，而覆写findClass方法)。findClass方法中其实是调用pathList.findClass(name)，而pathList是DexPathList类的实例，那么接着跟踪进入DexPathList的源码。</p>
<ul>
<li><p>DexPathList的源码(findClass方法)：</p>
<pre><code>/**
 * Finds the named class in one of the dex files pointed at by
 * this instance. This will find the one in the earliest listed
 * path element. If the class is found but has not yet been
 * defined, then this method will define it in the defining
 * context that this instance was constructed with.
 *
 * @return the named class or {@code null} if the class is not
 * found in any of the dex files
 */
public Class findClass(String name) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext);
            if (clazz != null) {
                return clazz;
            }
        }
    }

    return null;
}
</code></pre></li>
</ul>
<p>在这里，发现其实又调用DexFile dex.loadClassBinaryName(name, definingContext),根据进入DexFile的源码。</p>
<ul>
<li><p>DexFile的源码(loadClassBinaryName方法)：</p>
<pre><code>/**
 * Opens a DEX file from a given filename. This will usually be a ZIP/JAR
 * file with a &quot;classes.dex&quot; inside.
 *
 * The VM will generate the name of the corresponding file in
 * /data/dalvik-cache and open it, possibly creating or updating
 * it first if system permissions allow.  Don&apos;t pass in the name of
 * a file in /data/dalvik-cache, as the named file is expected to be
 * in its original (pre-dexopt) state.
 *
 * @param fileName
 *            the filename of the DEX file
 *
 * @throws IOException
 *             if an I/O error occurs, such as the file not being found or
 *             access rights missing for opening it
 */
public DexFile(String fileName) throws IOException {
    mCookie = openDexFile(fileName, null, 0);
    mFileName = fileName;
    guard.open(&quot;close&quot;);
    //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);
}
...
/**
 * See {@link #loadClass(String, ClassLoader)}.
 *
 * This takes a &quot;binary&quot; class name to better match ClassLoader semantics.
 *
 * @hide
 */
public Class loadClassBinaryName(String name, ClassLoader loader) {
    return defineClass(name, loader, mCookie);
}

private native static Class defineClass(String name, ClassLoader loader, int cookie);
</code></pre></li>
</ul>
<p>最终，通过JNI调用了本地方法defineClass(String name, ClassLoader loader, int cookie)。在实例化DexFile类的时候，在构造方法里面， 关键处为mCookie = openDexFile(fileName, null, 0)，这里即将dex文件打开并加装，而在DexFile里面还有几个方法：</p>
<pre><code>/*
 * Open a DEX file.  The value returned is a magic VM cookie.  On
 * failure, an IOException is thrown.
 */
native private static int openDexFile(String sourceName, String outputName,
    int flags) throws IOException;

/*
 * Open a DEX file based on a {@code byte[]}. The value returned
 * is a magic VM cookie. On failure, a RuntimeException is thrown.
 */
native private static int openDexFile(byte[] fileContents);

/*
 * Close DEX file.
 */
native private static void closeDexFile(int cookie);
</code></pre><p>上面这些本地方法实现是在/dalvik/vm/native/dalvik_system_DexFile.cpp里面。<br>native private static int openDexFile(byte[] fileContents)方法正是Android 4.0之后引入的，即前面所述的增加了对内存中DEX数据的动态加载。byte[] fileContents可以来自于网络或者解密dex文件。利用这一点，开发者可以解决DexClassLoader的缺点。</p>
<h4 id="3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1"><a href="#3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1" class="headerlink" title="3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1"></a>3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1</h4><p>通过上面内容，我们知道DexClassLoader自身加载类的逻辑实质上是通过DexFile类的loadClassBinaryName方法(该方法被隐藏)完成，而该方法最终调用dalvik_system_DexFile.cpp里面的本地方法defineClass来完成，同时DexFile的实例化调用了dalvik_system_DexFile.cpp里面的openDexFile方法来完成文件加载。</p>
<p>DexFile加载类的关键：defineClass和openDexFile方法，因为安全方面考虑，自然我们这里选择的openDexFile方法是openDexFile(byte[] fileContents)。</p>
<p>实现自定义的DexClassLoader，那么原理上我们可以通过反射调用DexFile的defineClass和openDexFile方法。首先，从本地获取或者从网络获取到dex文件的字节流byte[] fileContents，然后反射调用openDexFile(byte[] fileContents)获得magic VM cookie值，最后反射调用defineClass(String name, ClassLoader loader, int cookie)返回加载的Class。</p>
<h4 id="3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2"><a href="#3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2" class="headerlink" title="3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2"></a>3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2</h4><p>该方法参考<a href="http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf" title="JNI实现加载Dex" target="_blank" rel="external">http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf</a></p>
<p>自定义DexClassLoader方式1存在一个问题，即dex的字节流存在Java层，因此相对来说还是不够安全。这种需求下，就需要开发者直接通过JNI调用底层函数解析。在dalvik_system_DexFile.cpp中，定义了DalvikNativeMethod：</p>
<pre><code>const DalvikNativeMethod dvm_dalvik_system_DexFile[] = {
{ &quot;openDexFile&quot;,        &quot;(Ljava/lang/String;Ljava/lang/String;I)I&quot;,
    Dalvik_dalvik_system_DexFile_openDexFile },
{ &quot;openDexFile&quot;,        &quot;([B)I&quot;,
    Dalvik_dalvik_system_DexFile_openDexFile_bytearray },
{ &quot;closeDexFile&quot;,       &quot;(I)V&quot;,
    Dalvik_dalvik_system_DexFile_closeDexFile },
{ &quot;defineClass&quot;,        &quot;(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;&quot;,
    Dalvik_dalvik_system_DexFile_defineClass },
{ &quot;getClassNameList&quot;,   &quot;(I)[Ljava/lang/String;&quot;,
    Dalvik_dalvik_system_DexFile_getClassNameList },
{ &quot;isDexOptNeeded&quot;,     &quot;(Ljava/lang/String;)Z&quot;,
    Dalvik_dalvik_system_DexFile_isDexOptNeeded },
{ NULL, NULL, NULL },
</code></pre><p>};</p>
<ol>
<li><p>OnLoad method + dlsym获取Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法指针</p>
<pre><code>JNINativeMethod *dvm_dalvik_system_DexFile;
JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    void *ldvm = (void*)dlopen(&quot;libdvm.so&quot;, RTLD_LAZY);
    dvm_dalvik_system_DexFile = (JNINativeMethod*)dlsym(ldvm, &quot;dvm_dalvik_system_DexFile&quot;);
    void (*openDexFile)(const u4* args, JValue* pResult);
    lookup(openDexFile, &quot;dvm_dalvik_system_DexFile&quot;, &quot;([B)I&quot;, &amp;openDexFile);
}

int lookup (JNINativeMethod *table, const char *name, const char *sig, void (**fnPtrout)
    (u4 const *, union JValue *)) {
     int i = 0;
     while (table[i].name != NULL) {
     if ( (strcmp(name, table[i].name) == 0) &amp;&amp; (strcmp(sig, table[i].signature) == 0) ) {
     *fnPtrout = table[i].fnPtr;
     return 1;
     }
     i++;
     }
     return 0;
}
</code></pre></li>
<li><p>调用Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析Dex数据</p>
<pre><code>ArrayObject *ao; // header+dex content
u4 args[] = { (u4)ao };
JValue pResult ;
jint result ;
openDexFile(args, &amp;pResult);
result = (jint)pResult.l;
return result;
</code></pre></li>
<li><p>第三步实现JAVA层Dex ClassLoader完成类的加载：</p>
<pre><code>int cookie = openDexFile(...);
Class&lt;?&gt; cls = null;
String as[] = getClassNameList(cookie);
for(int z=0; z&lt;as.length; z++) {
 if(as[z].equals(&quot;com.immunapp.hes2013.MainActivity&quot;)) {
      cls=defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie );
} else {
     defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie );
}
</code></pre></li>
</ol>
<h4 id="3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3"><a href="#3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3" class="headerlink" title="3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3"></a>3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3</h4><p>该方式源自<a href="http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf" title="自修改Dalvik字节码加载dex" target="_blank" rel="external">http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf</a></p>
<p>自定义DexClassLoader方式2也存在确定，即只支持Android4.0以上系统，因为Android4.0系统才在底层引入了Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析。要想克服这个问题，就需要自修改Dalvik字节码(即按照上面dalvik_system_DexFile.cpp的逻辑，我们自定义实现其逻辑)。大致流程如下(由于本文作者对C++不熟悉，因此只能是浅尝辄止，有兴趣的开发者可以自行实践)。</p>
<ul>
<li><p>搜索内存查找DEX特征（dex\n035）</p>
<p>  读取/proc/self/maps文件获取dex map地址,它将以_SC_PAGESIZE内存页对齐, 相对Map开始地址偏移0x28</p>
</li>
<li><p>DEX格式解析(请参考<a href="https://source.android.com/tech/dalvik/dex-format.html" title="Dex格式解析" target="_blank" rel="external">https://source.android.com/tech/dalvik/dex-format.html</a>)</p>
</li>
<li><p>找到代码正确的位置</p>
<p>  第一步定位到具体类，第二步定位到具体方法，获取方法字节码相对data section偏移量。</p>
</li>
<li><p>解锁内存</p>
<p>  mprotect((unsigned char*)aligned,PROT_WRITE | PROT_READ, len);</p>
</li>
<li><p>修改相应的代码</p>
<p>  memcpy((unsigned char*)code_off,opcodes, len);</p>
</li>
</ul>
<p>这里提供一个示例，下载地址：<a href="http://172.20.154.39:8080/DemoActivity.zip" target="_blank" rel="external">自修改Dalvik字节码实现Dex加载Sample</a></p>
<h1 id="4-Android动态加载引申"><a href="#4-Android动态加载引申" class="headerlink" title="4.Android动态加载引申"></a>4.Android动态加载引申</h1><p>前面提到，Android动态加载机制的发展历程，随着需求的扩展，人们不仅仅满足于加载jar，还希望加载包含资源的jar甚至直接加载第三方APK，这样就带来更强的扩展性。我们知道，正常情况下，Android应用的APK需要安装注册，然后才能运行，怎样才能通过宿主程序打开别的APK呢，就如同通过安装运行一样。</p>
<p>很明显，前提仍然是类和资源的动态加载，即前面章节描述的内容。但是仅仅做到这些不够，还有很多问题需要解决：</p>
<ul>
<li>需加载的apk中的资源怎样引用？</li>
<li>需加载的apk的界面就算被加载，怎么与用户交互?</li>
<li>怎样管理加载的APK中的组件的生命周期？</li>
<li>…等等…</li>
</ul>
<p>需求产生动力，有了动力就有才能的发挥。聪明的人们自然会想到各种办法解决这些问题。当前，BAT等公司都有自己成熟的动态加载机制，但是不是开源的。而开源的加载机制方面，比较有影响的有：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" title="dynamic-load-apk地址">dynamic-load-apk</a>和360的<a href="https://github.com/Qihoo360/DroidPlugin" title="DroidPlugin开源项目">DroidPlugin</a>。</p>
<p>开发者如果对动态加载APK感兴趣，建议深入研究上述的开源项目，这里就不再赘述其中的原理了。里面很多思路值得借鉴，但同时还有很大的完善空间，发挥你的聪明才智，试试吧。</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Android动态加载机制/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Android安装APK详解" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Android安装APK详解/">Android安装APK详解</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APK安装/">APK安装</a></li></ul>
</div>
        <time datetime="2016-06-13T07:34:37.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>众所周知，Android应用最终是打包成.apk格式（其实就是一个压缩包），然后安装至手机并运行的。APK即Android Package的缩写，那么，Android安装应用APK的具体方式及其详细过程是怎样的呢？下面，我们逐一揭开里面的层层面纱。</p>
<h2 id="Android应用APK安装的方式"><a href="#Android应用APK安装的方式" class="headerlink" title="Android应用APK安装的方式"></a>Android应用APK安装的方式</h2><p>一般而言，Android应用安装有如下四种方式：</p>
<ol>
<li><strong>系统应用安装</strong>：开机时加载系统的APK和应用，没有安装界面；</li>
<li><strong>网络下载应用安装</strong>：通过各种market应用完成，没有安装界面；</li>
<li><strong>ADB工具安装</strong>：即通过Android的SDK开发tools里面的adb.exe程序安装，没有安装界面；</li>
<li><strong>第三方应用安装</strong>：通过SD卡里的APK文件安装(比如双击APK文件触发)，有安装界面，系统默认已经安装了一个安装卸载应用的程序，即由packageinstaller.apk应用处理安装及卸载过程的界面。<h2 id="Android-APK安装概述"><a href="#Android-APK安装概述" class="headerlink" title="Android APK安装概述"></a>Android APK安装概述</h2><h3 id="应用安装涉及到的目录"><a href="#应用安装涉及到的目录" class="headerlink" title="应用安装涉及到的目录"></a>应用安装涉及到的目录</h3></li>
</ol>
<ol>
<li>/system/app       ：系统自带的应用程序，获得adb root权限才能删除</li>
<li>/data/app         ：用户程序安装的目录。安装时把apk文件复制到此目录</li>
<li>/data/data        ：存放应用程序的数据</li>
<li>/data/dalvik-cache：将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,当然，ART–Android Runtime的可执行文件格式为oat，启用ART时，系统会执行dex文件转换至oat文件)   </li>
<li><p>/data/system      ：该目录下的packages.xml文件，类似于Windows的注册表，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。</p>
<p> /data/system/packages.xml中内容详解(这里列举的标签内容不一定完整，只是列举核心内容，packages.xml的完整定义详见官方文档)：<br> 该文件的根节点是<packages>…</packages>，内容树结构如下图所示：<br> <img src="http://i.imgur.com/9QZs6oN.png" alt="/data/system/packages.xml结构图"></p>
<p> (1)permissions标签定义了目前系统中定义的所有权限。主要分为两类：系统定义的（package属性为android）和APK定义的（package属性为APK的包名）。</p>
<p> (2)package代表一个APK的属性，它的属性含义如下（这里并未完全列出，如需了解全部属性，请查看官方文档）。</p>
<pre><code>name：APK的包名

codePath:安装路径。有/system/app系统APK和/data/app两种。/system/app存放系统出厂时预置的一些APK，/data/app存放用户安装的第三方APK。

system:如果APK被安装在/system/app下，system的值为true；安装在/data/app下面的话，值为true。

ts:时间戳

version:APK的版本号

sharedUserId/userId:Android系统启动一个普通的APK时，会为这个APK分配一个独立的UID，这就是userId。如果APK要和系统中其它APK使用相同的UID的话，那就是sharedUserId。关于共享UID，下面有更详细的描述。
</code></pre><p>  package的子标签perms:APK的AndroidManifest.xml文件中，每使用一个<uses-permission>标签，<perms>标签中就会增加一项。</perms></uses-permission></p>
<p> (3)<shared-user>代表一个共享UID，通常，共同实现一系列相似功能的APK共享一个UID。其子标签<perms>中的权限代表了这个共享UID的权限，所有使用的同一个共享UID的APK运行在同一进程中，这个进程的UID就是这个共享UID，这些APK都具有这个共享UID的权限。其属性包括：</perms></shared-user></p>
<pre><code>name:共享UID的名字，在APK的android:sharedUserId属性中使用。

userId：使用这个共享UID的所有APK运行时所在的进程的UID。
</code></pre></li>
</ol>
<h3 id="安装过程总述"><a href="#安装过程总述" class="headerlink" title="安装过程总述"></a>安装过程总述</h3><p>安卓系统安装一个应用时，系统大致会进行如下操作：</p>
<ol>
<li>复制APK安装包到data/app目录下，文件名会以应用的package命名；</li>
<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录(一般情况下，会先执行dexopt即dex文件的优化，将优化后的dex文件保存至该目录下)，并data/data目录下创建对应的应用数据目录(data/data目录可读可写)；</li>
<li>更新/data/system/packages.xml中的内容，将APK的信息加入进去。<h3 id="卸载过程概述"><a href="#卸载过程概述" class="headerlink" title="卸载过程概述"></a>卸载过程概述</h3>对照安装过程，卸载过程与之相逆：</li>
</ol>
<p>删除安装过程中在上述目录下创建的文件及目录。</p>
<h2 id="安装应用的过程代码解析"><a href="#安装应用的过程代码解析" class="headerlink" title="安装应用的过程代码解析"></a>安装应用的过程代码解析</h2><p>鉴于APK安装有四种方式，这里分别对各种方式下的安装详细过程进行代码级的解析。</p>
<h3 id="安装过程代码解析的前奏"><a href="#安装过程代码解析的前奏" class="headerlink" title="安装过程代码解析的前奏"></a>安装过程代码解析的前奏</h3><p><strong>注意：由于Android API迭代较快，版本众多，不过关于安装和卸载的逻辑核心（代码主干）是不变的，最新level级别的API可能会加入更多分支或细节完善代码，一般建议以低版本的API作为分析基础，这样便于更加快速地厘清代码流程和主干，本文以API level14的源码做切入点,引用源代码部分前面的数字表示行号，对应于源文件里面的行号</strong></p>
<p>我们知道，Android里面的包信息管理、安装和卸载等均是通过android/content/pm/PackageManager.java()这个类来完成的。而获取PackageManager的方式一般是：android/content/Context.getPackageManager()方法获取。</p>
<p>查看Context.java，可以发现Context类是抽象的，getPackageManager()也是抽象的。</p>
<pre><code>/**
 * Interface to global information about an application environment.  This is
 * an abstract class whose implementation is provided by
 * the Android system.  It
 * allows access to application-specific resources and classes, as well as
 * up-calls for application-level operations such as launching activities,
 * broadcasting and receiving intents, etc.
 */
51 public abstract class Context {
       ...
196       /** Return PackageManager instance to find global package information. */
197       public abstract PackageManager getPackageManager();
</code></pre><p>而Context的具体实现是android/app/ContextImpl.java里面的ContextImpl类，如下所示：</p>
<pre><code>/**
 * Common implementation of Context API, which provides the base
 * context object for Activity and other application components.
 */
138 class ContextImpl extends Context {
        ...
481        @Override
482        public PackageManager getPackageManager() {
483            if (mPackageManager != null) {
484                return mPackageManager;
485            }
486
487            IPackageManager pm = ActivityThread.getPackageManager();
488            if (pm != null) {
489               // Doesn&apos;t matter if we make more than one instance.
490                return (mPackageManager = new ApplicationPackageManager(this, pm));
491            }
492
493            return null;
494        }
</code></pre><p>可以看出，获取到的实际上是android/app/ApplicationPackageManager.java定义的ApplicationPackageManager类的实例。进入ApplicationPackageManager.java，代码如下：</p>
<pre><code>60    /*package*/
61    final class ApplicationPackageManager extends PackageManager {
        ...
723        ApplicationPackageManager(ContextImpl context,
724                          IPackageManager pm) {
725            mContext = context;
726            mPM = pm;
727        }
        ...
934        @Override
935        public void installPackage(Uri packageURI, IPackageInstallObserver observer, int flags,
936                                   String installerPackageName) {
937            try {
938                mPM.installPackage(packageURI, observer, flags, installerPackageName);
939            } catch (RemoteException e) {
940                // Should never happen!
941            }
942        }
943
944        @Override
945        public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer,
946                int flags, String installerPackageName, Uri verificationURI,
947                ManifestDigest manifestDigest) {
948            try {
949                mPM.installPackageWithVerification(packageURI, observer, flags, installerPackageName,
950                        verificationURI, manifestDigest);
951            } catch (RemoteException e) {
952                // Should never happen!
953            }
954        }
955
956        @Override
957        public void verifyPendingInstall(int id, int response) {
958            try {
959                mPM.verifyPendingInstall(id, response);
960            } catch (RemoteException e) {
961                // Should never happen!
962            }
963        }
        ...
1226    private final IPackageManager mPM;
</code></pre><p>进入ApplicationPackageManager，其继承了PackageManager，这里其实采用了组合模式，其实ApplicationPackageManager的installPackage方法内部是调用内部组合变量mPM的installPackage方法，其实其他继承自PackageManager的方法的内部逻辑也都是实际调用了mPM变量的对应方法。而mPM变量是在ApplicationPackageManager的构造方法传入(726行，mPM = pm;)，因此回滚到Context.java的487行(IPackageManager pm = ActivityThread.getPackageManager();),这里的pm就是最终执行安装或者其他操作的对象。跟踪下去，android/app/ActivityThread.java：</p>
<pre><code>114    /**
115     * This manages the execution of the main thread in an
116     * application process, scheduling and executing activities,
117     * broadcasts, and other operations on it as the activity
118     * manager requests.
119     *
120     * {@hide}
121     */
122    public final class ActivityThread {
        ...
1395    public static IPackageManager getPackageManager() {
1396        if (sPackageManager != null) {
1397            //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);
1398            return sPackageManager;
1399        }
1400        IBinder b = ServiceManager.getService(&quot;package&quot;);
1401        //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);
1402        sPackageManager = IPackageManager.Stub.asInterface(b);
1403        //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);
1404        return sPackageManager;
1405    }
1406    
</code></pre><p>通过上面代码可以发现，最终返回的IPackageManager的实例对象是通过绑定系统的package服务获取到的，熟悉Android的朋友应该清楚，这实际就是调用PackageManager对应的service来完成。至此，可以明确PackageManager类的安装等等操作实际是通过com/android、server/pm/PackageManagerService.java中定义的类PackageManagerService来完成，其详细代码如下：</p>
<pre><code>140        /**
141         * Keep track of all those .apks everywhere.
142         * 
143         * This is very central to the platform&apos;s security; please run the unit
144         * tests whenever making modifications here:
145         * 
146        mmm frameworks/base/tests/AndroidTests
147        adb install -r -f out/target/product/passion/data/app/AndroidTests.apk
148        adb shell am instrument -w -e class com.android.unit_tests.PackageManagerTests com.android.unit_tests/android.test.InstrumentationTestRunner
149         * 
150         * {@hide}
151         */
152        public class PackageManagerService extends IPackageManager.Stub {
            ...
439            class PackageHandler extends Handler {
440                private boolean mBound = false;
441                final ArrayList&lt;HandlerParams&gt; mPendingInstalls =
442                    new ArrayList&lt;HandlerParams&gt;();
443
444                private boolean connectToService() {
445                    if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Trying to bind to&quot; +
446                            &quot; DefaultContainerService&quot;);
447                    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
448                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
449                    if (mContext.bindService(service, mDefContainerConn,
450                            Context.BIND_AUTO_CREATE)) {
451                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
452                        mBound = true;
453                        return true;
454                    }
455                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
456                    return false;
457                }
458
459                private void disconnectService() {
460                    mContainerService = null;
461                    mBound = false;
462                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
463                    mContext.unbindService(mDefContainerConn);
464                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
465                }
466
467                PackageHandler(Looper looper) {
468                    super(looper);
469                }
470
471                public void handleMessage(Message msg) {
472                    try {
473                        doHandleMessage(msg);
474                    } finally {
475                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
476                    }
477                }
478                
479                void doHandleMessage(Message msg) {
480                    switch (msg.what) {
481                        case INIT_COPY: {
482                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy&quot;);
483                            HandlerParams params = (HandlerParams) msg.obj;
484                            int idx = mPendingInstalls.size();
485                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;idx=&quot; + idx);
486                            // If a bind was already initiated we dont really
487                            // need to do anything. The pending install
488                            // will be processed later on.
489                            if (!mBound) {
490                                // If this is the only one pending we might
491                                // have to bind to the service again.
492                                if (!connectToService()) {
493                                    Slog.e(TAG, &quot;Failed to bind to media container service&quot;);
494                                    params.serviceError();
495                                    return;
496                                } else {
497                                    // Once we bind to the service, the first
498                                    // pending request will be processed.
499                                    mPendingInstalls.add(idx, params);
500                                }
501                            } else {
502                                mPendingInstalls.add(idx, params);
503                                // Already bound to the service. Just make
504                                // sure we trigger off processing the first request.
505                                if (idx == 0) {
506                                    mHandler.sendEmptyMessage(MCS_BOUND);
507                                }
508                            }
509                            break;
510                        }
511                        case MCS_BOUND: {
512                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);
513                            if (msg.obj != null) {
514                                mContainerService = (IMediaContainerService) msg.obj;
515                            }
516                            if (mContainerService == null) {
517                                // Something seriously wrong. Bail out
518                                Slog.e(TAG, &quot;Cannot bind to media container service&quot;);
519                                for (HandlerParams params : mPendingInstalls) {
520                                    mPendingInstalls.remove(0);
521                                    // Indicate service bind error
522                                    params.serviceError();
523                                }
524                                mPendingInstalls.clear();
525                            } else if (mPendingInstalls.size() &gt; 0) {
526                                HandlerParams params = mPendingInstalls.get(0);
527                                if (params != null) {
528                                    if (params.startCopy()) {
529                                        // We are done...  look for more work or to
530                                        // go idle.
531                                        if (DEBUG_SD_INSTALL) Log.i(TAG,
532                                                &quot;Checking for more work or unbind...&quot;);
533                                        // Delete pending install
534                                        if (mPendingInstalls.size() &gt; 0) {
535                                            mPendingInstalls.remove(0);
536                                        }
537                                        if (mPendingInstalls.size() == 0) {
538                                            if (mBound) {
539                                                if (DEBUG_SD_INSTALL) Log.i(TAG,
540                                                        &quot;Posting delayed MCS_UNBIND&quot;);
541                                                removeMessages(MCS_UNBIND);
542                                                Message ubmsg = obtainMessage(MCS_UNBIND);
543                                                // Unbind after a little delay, to avoid
544                                                // continual thrashing.
545                                                sendMessageDelayed(ubmsg, 10000);
546                                            }
547                                        } else {
548                                            // There are more pending requests in queue.
549                                            // Just post MCS_BOUND message to trigger processing
550                                            // of next pending install.
551                                            if (DEBUG_SD_INSTALL) Log.i(TAG,
552                                                    &quot;Posting MCS_BOUND for next woek&quot;);
553                                            mHandler.sendEmptyMessage(MCS_BOUND);
554                                        }
555                                    }
556                                }
557                            } else {
558                                // Should never happen ideally.
559                                Slog.w(TAG, &quot;Empty queue&quot;);
560                            }
561                            break;
562                        }
563                        case MCS_RECONNECT: {
564                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_reconnect&quot;);
565                            if (mPendingInstalls.size() &gt; 0) {
566                                if (mBound) {
567                                    disconnectService();
568                                }
569                                if (!connectToService()) {
570                                    Slog.e(TAG, &quot;Failed to bind to media container service&quot;);
571                                    for (HandlerParams params : mPendingInstalls) {
572                                        mPendingInstalls.remove(0);
573                                        // Indicate service bind error
574                                        params.serviceError();
575                                    }
576                                    mPendingInstalls.clear();
577                                }
578                            }
579                            break;
580                        }
581                        case MCS_UNBIND: {
582                            // If there is no actual work left, then time to unbind.
583                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_unbind&quot;);
584
585                            if (mPendingInstalls.size() == 0 &amp;&amp; mPendingVerification.size() == 0) {
586                                if (mBound) {
587                                    if (DEBUG_INSTALL) Slog.i(TAG, &quot;calling disconnectService()&quot;);
588
589                                    disconnectService();
590                                }
591                            } else if (mPendingInstalls.size() &gt; 0) {
592                                // There are more pending requests in queue.
593                                // Just post MCS_BOUND message to trigger processing
594                                // of next pending install.
595                                mHandler.sendEmptyMessage(MCS_BOUND);
596                            }
597
598                            break;
599                        }
600                        case MCS_GIVE_UP: {
601                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_giveup too many retries&quot;);
602                            mPendingInstalls.remove(0);
603                            break;
604                        }
605                        case SEND_PENDING_BROADCAST: {
606                            String packages[];
607                            ArrayList&lt;String&gt; components[];
608                            int size = 0;
609                            int uids[];
610                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
611                            synchronized (mPackages) {
612                                if (mPendingBroadcasts == null) {
613                                    return;
614                                }
615                                size = mPendingBroadcasts.size();
616                                if (size &lt;= 0) {
617                                    // Nothing to be done. Just return
618                                    return;
619                                }
620                                packages = new String[size];
621                                components = new ArrayList[size];
622                                uids = new int[size];
623                                Iterator&lt;HashMap.Entry&lt;String, ArrayList&lt;String&gt;&gt;&gt;
624                                        it = mPendingBroadcasts.entrySet().iterator();
625                                int i = 0;
626                                while (it.hasNext() &amp;&amp; i &lt; size) {
627                                    HashMap.Entry&lt;String, ArrayList&lt;String&gt;&gt; ent = it.next();
628                                    packages[i] = ent.getKey();
629                                    components[i] = ent.getValue();
630                                    PackageSetting ps = mSettings.mPackages.get(ent.getKey());
631                                    uids[i] = (ps != null) ? ps.userId : -1;
632                                    i++;
633                                }
634                                size = i;
635                                mPendingBroadcasts.clear();
636                            }
637                            // Send broadcasts
638                            for (int i = 0; i &lt; size; i++) {
639                                sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
640                            }
641                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
642                            break;
643                        }
644                        case START_CLEANING_PACKAGE: {
645                            String packageName = (String)msg.obj;
646                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
647                            synchronized (mPackages) {
648                                if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
649                                    mSettings.mPackagesToBeCleaned.add(packageName);
650                                }
651                            }
652                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
653                            startCleaningPackages();
654                        } break;
655                        case POST_INSTALL: {
656                            if (DEBUG_INSTALL) Log.v(TAG, &quot;Handling post-install for &quot; + msg.arg1);
657                            PostInstallData data = mRunningInstalls.get(msg.arg1);
658                            mRunningInstalls.delete(msg.arg1);
659                            boolean deleteOld = false;
660
661                            if (data != null) {
662                                InstallArgs args = data.args;
663                                PackageInstalledInfo res = data.res;
664
665                                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
666                                    res.removedInfo.sendBroadcast(false, true);
667                                    Bundle extras = new Bundle(1);
668                                    extras.putInt(Intent.EXTRA_UID, res.uid);
669                                    final boolean update = res.removedInfo.removedPackage != null;
670                                    if (update) {
671                                        extras.putBoolean(Intent.EXTRA_REPLACING, true);
672                                    }
673                                    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,
674                                            res.pkg.applicationInfo.packageName,
675                                            extras, null, null);
676                                    if (update) {
677                                        sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,
678                                                res.pkg.applicationInfo.packageName,
679                                                extras, null, null);
680                                        sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,
681                                                null, null,
682                                                res.pkg.applicationInfo.packageName, null);
683                                    }
684                                    if (res.removedInfo.args != null) {
685                                        // Remove the replaced package&apos;s older resources safely now
686                                        deleteOld = true;
687                                    }
688                                }
689                                // Force a gc to clear up things
690                                Runtime.getRuntime().gc();
691                                // We delete after a gc for applications  on sdcard.
692                                if (deleteOld) {
693                                    synchronized (mInstallLock) {
694                                        res.removedInfo.args.doPostDeleteLI(true);
695                                    }
696                                }
697                                if (args.observer != null) {
698                                    try {
699                                        args.observer.packageInstalled(res.name, res.returnCode);
700                                    } catch (RemoteException e) {
701                                        Slog.i(TAG, &quot;Observer no longer exists.&quot;);
702                                    }
703                                }
704                            } else {
705                                Slog.e(TAG, &quot;Bogus post-install token &quot; + msg.arg1);
706                            }
707                        } break;
708                        case UPDATED_MEDIA_STATUS: {
709                            if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Got message UPDATED_MEDIA_STATUS&quot;);
710                            boolean reportStatus = msg.arg1 == 1;
711                            boolean doGc = msg.arg2 == 1;
712                            if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;reportStatus=&quot; + reportStatus + &quot;, doGc = &quot; + doGc);
713                            if (doGc) {
714                                // Force a gc to clear up stale containers.
715                                Runtime.getRuntime().gc();
716                            }
717                            if (msg.obj != null) {
718                                @SuppressWarnings(&quot;unchecked&quot;)
719                                Set&lt;SdInstallArgs&gt; args = (Set&lt;SdInstallArgs&gt;) msg.obj;
720                                if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Unloading all containers&quot;);
721                                // Unload containers
722                                unloadAllContainers(args);
723                            }
724                            if (reportStatus) {
725                                try {
726                                    if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Invoking MountService call back&quot;);
727                                    PackageHelper.getMountService().finishMediaUpdate();
728                                } catch (RemoteException e) {
729                                    Log.e(TAG, &quot;MountService not running?&quot;);
730                                }
731                            }
732                        } break;
733                        case WRITE_SETTINGS: {
734                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
735                            synchronized (mPackages) {
736                                removeMessages(WRITE_SETTINGS);
737                                removeMessages(WRITE_STOPPED_PACKAGES);
738                                mSettings.writeLPr();
739                            }
740                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
741                        } break;
742                        case WRITE_STOPPED_PACKAGES: {
743                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
744                            synchronized (mPackages) {
745                                removeMessages(WRITE_STOPPED_PACKAGES);
746                                mSettings.writeStoppedLPr();
747                            }
748                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
749                        } break;
750                        case CHECK_PENDING_VERIFICATION: {
751                            final int verificationId = msg.arg1;
752                            final PackageVerificationState state = mPendingVerification.get(verificationId);
753
754                            if (state != null) {
755                                final InstallArgs args = state.getInstallArgs();
756                                Slog.i(TAG, &quot;Verification timed out for &quot; + args.packageURI.toString());
757                                mPendingVerification.remove(verificationId);
758
759                                int ret = PackageManager.INSTALL_FAILED_VERIFICATION_TIMEOUT;
760                                processPendingInstall(args, ret);
761
762                                mHandler.sendEmptyMessage(MCS_UNBIND);
763                            }
764
765                            break;
766                        }
767                        case PACKAGE_VERIFIED: {
768                            final int verificationId = msg.arg1;
769
770                            final PackageVerificationState state = mPendingVerification.get(verificationId);
771                            if (state == null) {
772                                Slog.w(TAG, &quot;Invalid verification token &quot; + verificationId + &quot; received&quot;);
773                                break;
774                            }
775
776                            final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
777
778                            state.setVerifierResponse(response.callerUid, response.code);
779
780                            if (state.isVerificationComplete()) {
781                                mPendingVerification.remove(verificationId);
782
783                                final InstallArgs args = state.getInstallArgs();
784
785                                int ret;
786                                if (state.isInstallAllowed()) {
787                                    ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
788                                    try {
789                                        ret = args.copyApk(mContainerService, true);
790                                    } catch (RemoteException e) {
791                                        Slog.e(TAG, &quot;Could not contact the ContainerService&quot;);
792                                    }
793                                } else {
794                                    ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
795                                }
796
797                                processPendingInstall(args, ret);
798
799                                mHandler.sendEmptyMessage(MCS_UNBIND);
800                            }
801
802                            break;
803                        }
804                    }
805                }
806            }
            ...
            ...
831            public static final IPackageManager main(Context context, boolean factoryTest,
832                    boolean onlyCore) {
833                PackageManagerService m = new PackageManagerService(context, factoryTest, onlyCore);
834                ServiceManager.addService(&quot;package&quot;, m);
835                return m;
836            }
            ...
            ...
860         public PackageManagerService(Context context, boolean factoryTest, boolean onlyCore) {
861             EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,
862                     SystemClock.uptimeMillis());
863 
864             if (mSdkVersion &lt;= 0) {
865                 Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);
866             }
867 
868             mContext = context;
869             mFactoryTest = factoryTest;
870             mOnlyCore = onlyCore;
871             mNoDexOpt = &quot;eng&quot;.equals(SystemProperties.get(&quot;ro.build.type&quot;));
872             mMetrics = new DisplayMetrics();
873             mSettings = new Settings();
874             mSettings.addSharedUserLPw(&quot;android.uid.system&quot;,
875                     Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
876             mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;,
877                     MULTIPLE_APPLICATION_UIDS
878                             ? RADIO_UID : FIRST_APPLICATION_UID,
879                     ApplicationInfo.FLAG_SYSTEM);
880             mSettings.addSharedUserLPw(&quot;android.uid.log&quot;,
881                     MULTIPLE_APPLICATION_UIDS
882                             ? LOG_UID : FIRST_APPLICATION_UID,
883                     ApplicationInfo.FLAG_SYSTEM);
884             mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;,
885                     MULTIPLE_APPLICATION_UIDS
886                             ? NFC_UID : FIRST_APPLICATION_UID,
887                     ApplicationInfo.FLAG_SYSTEM);
888 
889             String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;);
890             if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) {
891                 if (&quot;*&quot;.equals(separateProcesses)) {
892                     mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;
893                     mSeparateProcesses = null;
894                     Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;);
895                 } else {
896                     mDefParseFlags = 0;
897                     mSeparateProcesses = separateProcesses.split(&quot;,&quot;);
898                     Slog.w(TAG, &quot;Running with debug.separate_processes: &quot;
899                             + separateProcesses);
900                 }
901             } else {
902                 mDefParseFlags = 0;
903                 mSeparateProcesses = null;
904             }
905 
906             mInstaller = new Installer();
907 
908             WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
909             Display d = wm.getDefaultDisplay();
910             d.getMetrics(mMetrics);
911 
912             synchronized (mInstallLock) {
913             // writer
914             synchronized (mPackages) {
915                 mHandlerThread.start();
916                 mHandler = new PackageHandler(mHandlerThread.getLooper());
917 
918                 File dataDir = Environment.getDataDirectory();
919                 mAppDataDir = new File(dataDir, &quot;data&quot;);
920                 mUserAppDataDir = new File(dataDir, &quot;user&quot;);
921                 mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);
922 
923                 mUserManager = new UserManager(mInstaller, mUserAppDataDir);
924 
925                 readPermissions();
926 
927                 mRestoredSettings = mSettings.readLPw();
928                 long startTime = SystemClock.uptimeMillis();
929 
930                 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,
931                         startTime);
932 
933                 // Set flag to monitor and not change apk file paths when
934                 // scanning install directories.
935                 int scanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;
936                 if (mNoDexOpt) {
937                     Slog.w(TAG, &quot;Running ENG build: no pre-dexopt!&quot;);
938                     scanMode |= SCAN_NO_DEX;
939                 }
940 
941                 final HashSet&lt;String&gt; libFiles = new HashSet&lt;String&gt;();
942 
943                 mFrameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);
944                 mDalvikCacheDir = new File(dataDir, &quot;dalvik-cache&quot;);
945 
946                 boolean didDexOpt = false;
947 
948                 /**
949                  * Out of paranoia, ensure that everything in the boot class
950                  * path has been dexed.
951                  */
952                 String bootClassPath = System.getProperty(&quot;java.boot.class.path&quot;);
953                 if (bootClassPath != null) {
954                     String[] paths = splitString(bootClassPath, &apos;:&apos;);
955                     for (int i=0; i&lt;paths.length; i++) {
956                         try {
957                             if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
958                                 libFiles.add(paths[i]);
959                                 mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true);
960                                 didDexOpt = true;
961                             }
962                         } catch (FileNotFoundException e) {
963                             Slog.w(TAG, &quot;Boot class path not found: &quot; + paths[i]);
964                         } catch (IOException e) {
965                             Slog.w(TAG, &quot;Cannot dexopt &quot; + paths[i] + &quot;; is it an APK or JAR? &quot;
966                                     + e.getMessage());
967                         }
968                     }
969                 } else {
970                     Slog.w(TAG, &quot;No BOOTCLASSPATH found!&quot;);
971                 }
972 
973                 /**
974                  * Also ensure all external libraries have had dexopt run on them.
975                  */
976                 if (mSharedLibraries.size() &gt; 0) {
977                     Iterator&lt;String&gt; libs = mSharedLibraries.values().iterator();
978                     while (libs.hasNext()) {
979                         String lib = libs.next();
980                         try {
981                             if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
982                                 libFiles.add(lib);
983                                 mInstaller.dexopt(lib, Process.SYSTEM_UID, true);
984                                 didDexOpt = true;
985                             }
986                         } catch (FileNotFoundException e) {
987                             Slog.w(TAG, &quot;Library not found: &quot; + lib);
988                         } catch (IOException e) {
989                             Slog.w(TAG, &quot;Cannot dexopt &quot; + lib + &quot;; is it an APK or JAR? &quot;
990                                     + e.getMessage());
991                         }
992                     }
993                 }
994 
995                 // Gross hack for now: we know this file doesn&apos;t contain any
996                 // code, so don&apos;t dexopt it to avoid the resulting log spew.
997                 libFiles.add(mFrameworkDir.getPath() + &quot;/framework-res.apk&quot;);
998 
999                 /**
1000                 * And there are a number of commands implemented in Java, which
1001                 * we currently need to do the dexopt on so that they can be
1002                 * run from a non-root shell.
1003                 */
1004                String[] frameworkFiles = mFrameworkDir.list();
1005                if (frameworkFiles != null) {
1006                    for (int i=0; i&lt;frameworkFiles.length; i++) {
1007                        File libPath = new File(mFrameworkDir, frameworkFiles[i]);
1008                        String path = libPath.getPath();
1009                        // Skip the file if we alrady did it.
1010                        if (libFiles.contains(path)) {
1011                            continue;
1012                        }
1013                        // Skip the file if it is not a type we want to dexopt.
1014                        if (!path.endsWith(&quot;.apk&quot;) &amp;&amp; !path.endsWith(&quot;.jar&quot;)) {
1015                            continue;
1016                        }
1017                        try {
1018                            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
1019                                mInstaller.dexopt(path, Process.SYSTEM_UID, true);
1020                                didDexOpt = true;
1021                            }
1022                        } catch (FileNotFoundException e) {
1023                            Slog.w(TAG, &quot;Jar not found: &quot; + path);
1024                        } catch (IOException e) {
1025                            Slog.w(TAG, &quot;Exception reading jar: &quot; + path, e);
1026                        }
1027                    }
1028                }
1029
1030                if (didDexOpt) {
1031                    // If we had to do a dexopt of one of the previous
1032                    // things, then something on the system has changed.
1033                    // Consider this significant, and wipe away all other
1034                    // existing dexopt files to ensure we don&apos;t leave any
1035                    // dangling around.
1036                    String[] files = mDalvikCacheDir.list();
1037                    if (files != null) {
1038                        for (int i=0; i&lt;files.length; i++) {
1039                            String fn = files[i];
1040                            if (fn.startsWith(&quot;data@app@&quot;)
1041                                    || fn.startsWith(&quot;data@app-private@&quot;)) {
1042                                Slog.i(TAG, &quot;Pruning dalvik file: &quot; + fn);
1043                                (new File(mDalvikCacheDir, fn)).delete();
1044                            }
1045                        }
1046                    }
1047                }
1048
1049                // Find base frameworks (resource packages without code).
1050                mFrameworkInstallObserver = new AppDirObserver(
1051                    mFrameworkDir.getPath(), OBSERVER_EVENTS, true);
1052                mFrameworkInstallObserver.startWatching();
1053                scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM
1054                        | PackageParser.PARSE_IS_SYSTEM_DIR,
1055                        scanMode | SCAN_NO_DEX, 0);
1056                
1057                // Collect all system packages.
1058                mSystemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);
1059                mSystemInstallObserver = new AppDirObserver(
1060                    mSystemAppDir.getPath(), OBSERVER_EVENTS, true);
1061                mSystemInstallObserver.startWatching();
1062                scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM
1063                        | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);
1064                
1065                // Collect all vendor packages.
1066                mVendorAppDir = new File(&quot;/vendor/app&quot;);
1067                mVendorInstallObserver = new AppDirObserver(
1068                    mVendorAppDir.getPath(), OBSERVER_EVENTS, true);
1069                mVendorInstallObserver.startWatching();
1070                scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM
1071                        | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);
1072
1073                if (DEBUG_UPGRADE) Log.v(TAG, &quot;Running installd update commands&quot;);
1074                mInstaller.moveFiles();
1075
1076                // Prune any system packages that no longer exist.
1077                if (!mOnlyCore) {
1078                    Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();
1079                    while (psit.hasNext()) {
1080                        PackageSetting ps = psit.next();
1081                        if ((ps.pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) != 0
1082                                &amp;&amp; !mPackages.containsKey(ps.name)
1083                                &amp;&amp; !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
1084                            psit.remove();
1085                            String msg = &quot;System package &quot; + ps.name
1086                                    + &quot; no longer exists; wiping its data&quot;;
1087                            reportSettingsProblem(Log.WARN, msg);
1088                            mInstaller.remove(ps.name, 0);
1089                            mUserManager.removePackageForAllUsers(ps.name);
1090                        }
1091                    }
1092                }
1093                
1094                mAppInstallDir = new File(dataDir, &quot;app&quot;);
1095                //look for any incomplete package installations
1096                ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();
1097                //clean up list
1098                for(int i = 0; i &lt; deletePkgsList.size(); i++) {
1099                    //clean up here
1100                    cleanupInstallFailedPackage(deletePkgsList.get(i));
1101                }
1102                //delete tmp files
1103                deleteTempPackageFiles();
1104
1105                if (!mOnlyCore) {
1106                    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,
1107                            SystemClock.uptimeMillis());
1108                    mAppInstallObserver = new AppDirObserver(
1109                        mAppInstallDir.getPath(), OBSERVER_EVENTS, false);
1110                    mAppInstallObserver.startWatching();
1111                    scanDirLI(mAppInstallDir, 0, scanMode, 0);
1112        
1113                    mDrmAppInstallObserver = new AppDirObserver(
1114                        mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false);
1115                    mDrmAppInstallObserver.startWatching();
1116                    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,
1117                            scanMode, 0);
1118                } else {
1119                    mAppInstallObserver = null;
1120                    mDrmAppInstallObserver = null;
1121                }
1122
1123                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,
1124                        SystemClock.uptimeMillis());
1125                Slog.i(TAG, &quot;Time to scan packages: &quot;
1126                        + ((SystemClock.uptimeMillis()-startTime)/1000f)
1127                        + &quot; seconds&quot;);
1128
1129                // If the platform SDK has changed since the last time we booted,
1130                // we need to re-grant app permission to catch any new ones that
1131                // appear.  This is really a hack, and means that apps can in some
1132                // cases get permissions that the user didn&apos;t initially explicitly
1133                // allow...  it would be nice to have some better way to handle
1134                // this situation.
1135                final boolean regrantPermissions = mSettings.mInternalSdkPlatform
1136                        != mSdkVersion;
1137                if (regrantPermissions) Slog.i(TAG, &quot;Platform changed from &quot;
1138                        + mSettings.mInternalSdkPlatform + &quot; to &quot; + mSdkVersion
1139                        + &quot;; regranting permissions for internal storage&quot;);
1140                mSettings.mInternalSdkPlatform = mSdkVersion;
1141                
1142                updatePermissionsLPw(null, null, true, regrantPermissions, regrantPermissions);
1143
1144                // can downgrade to reader
1145                mSettings.writeLPr();
1146
1147                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,
1148                        SystemClock.uptimeMillis());
1149
1150                // Now after opening every single application zip, make sure they
1151                // are all flushed.  Not really needed, but keeps things nice and
1152                // tidy.
1153                Runtime.getRuntime().gc();
1154
1155                mRequiredVerifierPackage = getRequiredVerifierLPr();
1156            } // synchronized (mPackages)
1157            } // synchronized (mInstallLock)
1158        }
            ...
</code></pre><p>仔细分析上述代码，主要分两个部分：PackageManagerService的构造方法(启动流程)（860-1158行）、PackageHandler的逻辑(439-806行)。PackageManagerService是在系统启动阶段由systemserver启动的一个java层服务，用来管理/system/framework，/system/app，/data/app，/data/app-private等目录下的apk文件，PackageManagerService的启动流程主要包括：</p>
<p><img src="http://i.imgur.com/aXWwlfs.png" alt="PackageManagerService init"></p>
<p>以下是PackageManagerService主要的工作内容：</p>
<ol>
<li>建立java层的installer与c层的installd的socket联接，使得在上层的install,remove,dexopt等功能最终由installd在底层实现；</li>
<li>建立PackageHandler消息循环，用于处理外部的apk安装请求消息，如adb install,packageinstaller安装apk时会发送消息；</li>
<li><p>解析/system/etc/permission下xml文件(framework/base/data/etc/)，包括platform.xml和系统支持的各种硬件模块的feature.主要工作：</p>
<p> (1)建立底层user ids和group ids 同上层permissions之间的映射；可以指定一个权限与几个组ID对应。当一个APK被授予这个权限时，它也同时属于这几个组。</p>
<p> (2)给一些底层用户分配权限，如给shell授予各种permission权限；把一个权限赋予一个UID，当进程使用这个UID运行时，就具备了这个权限。</p>
<p> (3) library,系统增加的一些应用需要link的扩展jar库；</p>
<p> (4) feature,系统每增加一个硬件，都要添加相应的feature.将解析结果放入mSystemPermissions,mSharedLibraries,mSettings.mPermissions,mAvailableFeatures等几个集合中供系统查询和权限配置使用</p>
</li>
<li>检查/data/system/packages.xml是否存在，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通过apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。</li>
<li>检查BootClassPath，mSharedLibraries及/system/framework下的jar是否需要dexopt，需要的则通过dexopt进行优化；</li>
<li>启动AppDirObserver线程监测/system/framework,/system/app,/data/app,/data/app-private目录的事件,主要监听add和remove事件。对于目录监听底层通过inotify机制实现，inotify 是一种文件系统的变化通知机制，如文件增加、删除等事件可以立刻让用户态得知,它为用户态监视文件系统的变化提供了强大的支持。当有add event时调用scanPackageLI(File , int , int)处理；当有remove event时调用removePackageLI()处理;</li>
<li>对于以上几个目录下的apk逐个解析，主要是解析每个apk的AndroidMa-nifest.xml文件，处理asset/res等资源文件，建立起每个apk的配置结构信息，并将每个apk的配置信息添加到全局列表进行管理。调用installer.install()进行安装工作,检查apk里的dex文件是否需要再优化,如果需要优化则通过辅助工具dexopt进行优化处理；将解析出的componet添加到pkg的对应列表里；对apk进行签名和证书校验,进行完整性验证。</li>
<li><p>将解析的每个apk的信息保存到packages.xml和packages.list文件里，packages.list记录了如下数据：pkgName，userId，debugFlag，dataPath（包的数据路径）。</p>
<h3 id="开机安装过程代码解析"><a href="#开机安装过程代码解析" class="headerlink" title="开机安装过程代码解析"></a>开机安装过程代码解析</h3><p>有了上面的认识，接下来分析安装的过程就比较轻松了(均围绕PackageManagerService.java展开)。开机安装过程的代码流程如下：</p>
</li>
<li><p>扫描各目录(/system/framework、/system/app、/vendor/app、/data/app/、/data/app-private)下的jar包或安装包：</p>
<p>  a.扫描安装“/system/framework”目录下的jar包(1049-1055行);</p>
<p>  b.扫描安装系统/system/app的应用程序(1057-1063行);</p>
<p>  c.制造商的目录下/vendor/app应用包(1065-1071行);</p>
<p>  d.扫描“/data/app”目录，即用户安装的第三方应用(1108-1111行);</p>
<p>  e.扫描” data\app-private”目录，即安装DRM保护的APK文件（一个受保护的歌曲或受保护的视频是使用DRM保护的文件）（1113-1117行）。</p>
</li>
<li><p>扫描目录关键方法的代码清单：</p>
<pre><code>2732        private void scanDirLI(File dir, int flags, int scanMode, long currentTime) {
2733            String[] files = dir.list();
2734            if (files == null) {
2735                Log.d(TAG, &quot;No files in app dir &quot; + dir);
2736                return;
2737            }
2738
2739            if (DEBUG_PACKAGE_SCANNING) {
2740                Log.d(TAG, &quot;Scanning app dir &quot; + dir);
2741            }
2742
2743            int i;
2744            for (i=0; i&lt;files.length; i++) {
2745                File file = new File(dir, files[i]);
2746                if (!isPackageFilename(files[i])) {
2747                    // Ignore entries which are not apk&apos;s
2748                    continue;
2749                }
2750                PackageParser.Package pkg = scanPackageLI(file,
2751                        flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);
2752                // Don&apos;t mess around with apps in system partition.
2753                if (pkg == null &amp;&amp; (flags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;
2754                        mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {
2755                    // Delete the apk
2756                    Slog.w(TAG, &quot;Cleaning up failed install of &quot; + file);
2757                    file.delete();
2758                }
2759            }
2760        }
</code></pre></li>
<li><p>从上面扫描方法的代码中可以看出实质是调用了scanPackageLI(File scanFile,<br>int parseFlags, int scanMode, long currentTime) ，其代码在2814-2923行定义。分析其代码，发现最终实质是调用scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime)。而后者这个方法代码定义在3106-3905行之间，前面一段主要是各种校验和检查，关键部分代码为：</p>
<pre><code>3495        //invoke installer to do the actual installation
3496        int ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,
3497                pkg.applicationInfo.uid);
3498        if (ret &lt; 0) {
3499            // Error from installer
3500            mLastScanError = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
3501            return null;
3502        }
3503        // Create data directories for all users
3504        mUserManager.installPackageForAllUsers(pkgName, pkg.applicationInfo.uid);
</code></pre><p> 不难看出，mInstaller.install是真正执行安装之处。而看看mInstaller的定义：</p>
<pre><code>258  // Used for priviledge escalation.  MUST NOT BE CALLED WITH mPackages
259  // LOCK HELD.  Can be called with mInstallLock held.
260  final Installer mInstaller;
</code></pre><p> 查看com/android/server/pm/Installer.java，其代码相对比较少，分析起来比较容易，其install方法调用了execute(String cmd)方法，而execute(String cmd)又调用transaction(cmd)：</p>
<pre><code>148        private synchronized String transaction(String cmd) {
149        if (!connect()) {
150            Slog.e(TAG, &quot;connection failed&quot;);
151            return &quot;-1&quot;;
152        }
153
154        if (!writeCommand(cmd)) {
155            /*
156             * If installd died and restarted in the background (unlikely but
157             * possible) we&apos;ll fail on the next write (this one). Try to
158             * reconnect and write the command one more time before giving up.
159             */
160            Slog.e(TAG, &quot;write command failed? reconnect!&quot;);
161            if (!connect() || !writeCommand(cmd)) {
162                return &quot;-1&quot;;
163            }
164        }
165        if (LOCAL_DEBUG) {
166            Slog.i(TAG, &quot;send: &apos;&quot; + cmd + &quot;&apos;&quot;);
167        }
168        if (readReply()) {
169            String s = new String(buf, 0, buflen);
170            if (LOCAL_DEBUG) {
171                Slog.i(TAG, &quot;recv: &apos;&quot; + s + &quot;&apos;&quot;);
172            }
173            return s;
174        } else {
175            if (LOCAL_DEBUG) {
176                Slog.i(TAG, &quot;fail&quot;);
177            }
178            return &quot;-1&quot;;
179        }
180    }
</code></pre><p> 首先是149行的connect方法：</p>
<pre><code>43        private boolean connect() {
44            if (mSocket != null) {
45                return true;
46            }
47            Slog.i(TAG, &quot;connecting...&quot;);
48            try {
49                mSocket = new LocalSocket();
50
51                LocalSocketAddress address = new LocalSocketAddress(&quot;installd&quot;,
52                        LocalSocketAddress.Namespace.RESERVED);
53
54                mSocket.connect(address);
55
56                mIn = mSocket.getInputStream();
57                mOut = mSocket.getOutputStream();
58            } catch (IOException ex) {
59                disconnect();
60                return false;
61            }
62            return true;
63        }
</code></pre><p> 到这里已经很清楚了，实则是通过socket连接到本地方法，即指挥installd在C语言的文件中完成工作。</p>
<h3 id="网络下载应用安装过程代码解析"><a href="#网络下载应用安装过程代码解析" class="headerlink" title="网络下载应用安装过程代码解析"></a>网络下载应用安装过程代码解析</h3><p>当从网络上下载APK完成后，自动调用Packagemanager的安装方法installPackage。如前面所述，最终是调用PackageManagerService的installPackage方法。如下：</p>
<pre><code>4882        /* Called when a downloaded package installation has been confirmed by the user */
4883        public void installPackage(
4884                final Uri packageURI, final IPackageInstallObserver observer, final int flags) {
4885            installPackage(packageURI, observer, flags, null);
4886        }
4887
4888        /* Called when a downloaded package installation has been confirmed by the user */
4889        public void installPackage(
4890                final Uri packageURI, final IPackageInstallObserver observer, final int flags,
4891                final String installerPackageName) {
4892            installPackageWithVerification(packageURI, observer, flags, installerPackageName, null,
4893                    null);
4894        }
4895
4896        @Override
4897        public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer,
4898                int flags, String installerPackageName, Uri verificationURI,
4899                ManifestDigest manifestDigest) {
4900            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
4901
4902            final int uid = Binder.getCallingUid();
4903
4904            final int filteredFlags;
4905
4906            if (uid == Process.SHELL_UID || uid == 0) {
4907                if (DEBUG_INSTALL) {
4908                    Slog.v(TAG, &quot;Install from ADB&quot;);
4909                }
4910                filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;
4911            } else {
4912                filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;
4913            }
4914
4915            final Message msg = mHandler.obtainMessage(INIT_COPY);
4916            msg.obj = new InstallParams(packageURI, observer, filteredFlags, installerPackageName,
4917                    verificationURI, manifestDigest);
4918            mHandler.sendMessage(msg);
4919        }
</code></pre></li>
</ol>
<p>可以发现，调用之后进入到4945-4918行，通过PackageHandler的实例mhandler.sendMessage（msg）把信息发给继承Handler的类HandleMessage()方法。在前面章节已经介绍了PackageManagerService中PackageHandler的定义。HandleMessage()把信息发给doHandleMessage()方法,方法中用switch语句进行判定传来Message进行分支处理。这里传入的消息的msg.what是INIT_COPY，进入到INIT_COPY分支，可以看到，一旦成功绑定了com.android.defcontainer.DefaultContainerService服务，则进入506行–mHandler.sendEmptyMessage(MCS_BOUND);此时进入doHandleMessage方法的switch语句的MCS_BOUND分支，跟踪进去，关键代码：</p>
<pre><code>528     if (params.startCopy()) {
</code></pre><p>params是PackageManagerService中内部抽象类HandlerParams的子类InstallParams(参见上面4916行)的实例，HandlerParams代码清单：</p>
<pre><code>5202    private abstract class HandlerParams {
5203        private static final int MAX_RETRIES = 4;
5204
5205        /**
5206         * Number of times startCopy() has been attempted and had a non-fatal
5207         * error.
5208         */
5209        private int mRetries = 0;
5210
5211        final boolean startCopy() {
5212            boolean res;
5213            try {
5214                if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy&quot;);
5215
5216                if (++mRetries &gt; MAX_RETRIES) {
5217                    Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);
5218                    mHandler.sendEmptyMessage(MCS_GIVE_UP);
5219                    handleServiceError();
5220                    return false;
5221                } else {
5222                    handleStartCopy();
5223                    res = true;
5224                }
5225            } catch (RemoteException e) {
5226                if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);
5227                mHandler.sendEmptyMessage(MCS_RECONNECT);
5228                res = false;
5229            }
5230            handleReturnCode();
5231            return res;
5232        }
5233
5234        final void serviceError() {
5235            if (DEBUG_INSTALL) Slog.i(TAG, &quot;serviceError&quot;);
5236            handleServiceError();
5237            handleReturnCode();
5238        }
5239
5240        abstract void handleStartCopy() throws RemoteException;
5241        abstract void handleServiceError();
5242        abstract void handleReturnCode();
5243    }
5244
</code></pre><p>startCopy()方法中关键代码是先调用handleStartCopy()方法，再调用handleReturnCode()方法(由子类实现，这里即InstallParams的handleStartCopy()方法和handleReturnCode()方法)，handleStartCopy()代码较多，但是前面基本是校验相关逻辑，关键部分在：</p>
<pre><code>5557    } else {
5558        /*
5559         * No package verification is enabled, so immediately start
5560         * the remote call to initiate copy using temporary file.
5561         */
5562        ret = args.copyApk(mContainerService, true);
5563    }
</code></pre><p>args是抽象类InstallArgs的子类实现类SdInstallArgs(安装在SD卡时)或FileInstallArgs(非安装在)的实例对象，copyApk是负责将下载的APK文件copy到/data/app目录下。而handleReturnCode方法如下：</p>
<pre><code>5569    @Override
5570    void handleReturnCode() {
5571        // If mArgs is null, then MCS couldn&apos;t be reached. When it
5572        // reconnects, it will try again to install. At that point, this
5573        // will succeed.
5574        if (mArgs != null) {
5575            processPendingInstall(mArgs, mRet);
5576        }
5577    }
</code></pre><p>这时可以清楚的看见processPendingInstall()被调用。其代码为：</p>
<pre><code>5129    private void processPendingInstall(final InstallArgs args, final int currentStatus) {
5130        // Queue up an async operation since the package installation may take a little while.
5131        mHandler.post(new Runnable() {
5132            public void run() {
5133                mHandler.removeCallbacks(this);
5134                 // Result object to be returned
5135                PackageInstalledInfo res = new PackageInstalledInfo();
5136                res.returnCode = currentStatus;
5137                res.uid = -1;
5138                res.pkg = null;
5139                res.removedInfo = new PackageRemovedInfo();
5140                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
5141                    args.doPreInstall(res.returnCode);
5142                    synchronized (mInstallLock) {
5143                        installPackageLI(args, true, res);
5144                    }
5145                    args.doPostInstall(res.returnCode);
5146                }
5147
5148                // A restore should be performed at this point if (a) the install
5149                // succeeded, (b) the operation is not an update, and (c) the new
5150                // package has a backupAgent defined.
5151                final boolean update = res.removedInfo.removedPackage != null;
5152                boolean doRestore = (!update
5153                        &amp;&amp; res.pkg != null
5154                        &amp;&amp; res.pkg.applicationInfo.backupAgentName != null);
5155
5156                // Set up the post-install work request bookkeeping.  This will be used
5157                // and cleaned up by the post-install event handling regardless of whether
5158                // there&apos;s a restore pass performed.  Token values are &gt;= 1.
5159                int token;
5160                if (mNextInstallToken &lt; 0) mNextInstallToken = 1;
5161                token = mNextInstallToken++;
5162
5163                PostInstallData data = new PostInstallData(args, res);
5164                mRunningInstalls.put(token, data);
5165                if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token);
5166
5167                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) {
5168                    // Pass responsibility to the Backup Manager.  It will perform a
5169                    // restore if appropriate, then pass responsibility back to the
5170                    // Package Manager to run the post-install observer callbacks
5171                    // and broadcasts.
5172                    IBackupManager bm = IBackupManager.Stub.asInterface(
5173                            ServiceManager.getService(Context.BACKUP_SERVICE));
5174                    if (bm != null) {
5175                        if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token
5176                                + &quot; to BM for possible restore&quot;);
5177                        try {
5178                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
5179                        } catch (RemoteException e) {
5180                            // can&apos;t happen; the backup manager is local
5181                        } catch (Exception e) {
5182                            Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e);
5183                            doRestore = false;
5184                        }
5185                    } else {
5186                        Slog.e(TAG, &quot;Backup Manager not found!&quot;);
5187                        doRestore = false;
5188                    }
5189                }
5190
5191                if (!doRestore) {
5192                    // No restore possible, or the Backup Manager was mysteriously not
5193                    // available -- just fire the post-install work request directly.
5194                    if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);
5195                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
5196                    mHandler.sendMessage(msg);
5197                }
5198            }
5199        });
5200    }
</code></pre><p>关键部分代码为5140-5146行：</p>
<pre><code>5140                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
5141                    args.doPreInstall(res.returnCode);
5142                    synchronized (mInstallLock) {
5143                        installPackageLI(args, true, res);
5144                    }
5145                    args.doPostInstall(res.returnCode);
5146                }
</code></pre><p>这里installPackageLI(args, true, res)的代码为：</p>
<pre><code>5573    private void installPackageLI(InstallArgs args,
5574            boolean newInstall, PackageInstalledInfo res) {
5575        int pFlags = args.flags;
5576        String installerPackageName = args.installerPackageName;
5577        File tmpPackageFile = new File(args.getCodePath());
5578        boolean forwardLocked = ((pFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0);
5579        boolean onSd = ((pFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0);
5580        boolean replace = false;
5581        int scanMode = (onSd ? 0 : SCAN_MONITOR) | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE
5582                | (newInstall ? SCAN_NEW_INSTALL : 0);
5583        // Result object to be returned
5584        res.returnCode = PackageManager.INSTALL_SUCCEEDED;
5585
5586        // Retrieve PackageSettings and parse package
5587        int parseFlags = PackageParser.PARSE_CHATTY |
5588        (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) |
5589        (onSd ? PackageParser.PARSE_ON_SDCARD : 0);
5590        parseFlags |= mDefParseFlags;
5591        PackageParser pp = new PackageParser(tmpPackageFile.getPath());
5592        pp.setSeparateProcesses(mSeparateProcesses);
5593        final PackageParser.Package pkg = pp.parsePackage(tmpPackageFile,
5594                null, mMetrics, parseFlags);
5595        if (pkg == null) {
5596            res.returnCode = pp.getParseError();
5597            return;
5598        }
5599        String pkgName = res.name = pkg.packageName;
5600        if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) {
5601            if ((pFlags&amp;PackageManager.INSTALL_ALLOW_TEST) == 0) {
5602                res.returnCode = PackageManager.INSTALL_FAILED_TEST_ONLY;
5603                return;
5604            }
5605        }
5606        if (GET_CERTIFICATES &amp;&amp; !pp.collectCertificates(pkg, parseFlags)) {
5607            res.returnCode = pp.getParseError();
5608            return;
5609        }
5610
5611        /* If the installer passed in a manifest digest, compare it now. */
5612        if (args.manifestDigest != null) {
5613            if (DEBUG_INSTALL) {
5614                final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;
5615                        : pkg.manifestDigest.toString();
5616                Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;
5617                        + parsedManifest);
5618            }
5619
5620            if (!args.manifestDigest.equals(pkg.manifestDigest)) {
5621                res.returnCode = PackageManager.INSTALL_FAILED_PACKAGE_CHANGED;
5622                return;
5623            }
5624        } else if (DEBUG_INSTALL) {
5625            final String parsedManifest = pkg.manifestDigest == null
5626                    ? &quot;null&quot; : pkg.manifestDigest.toString();
5627            Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);
5628        }
5629
5630        // Get rid of all references to package scan path via parser.
5631        pp = null;
5632        String oldCodePath = null;
5633        boolean systemApp = false;
5634        synchronized (mPackages) {
5635            // Check if installing already existing package
5636            if ((pFlags&amp;PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
5637                String oldName = mSettings.mRenamedPackages.get(pkgName);
5638                if (pkg.mOriginalPackages != null
5639                        &amp;&amp; pkg.mOriginalPackages.contains(oldName)
5640                        &amp;&amp; mPackages.containsKey(oldName)) {
5641                    // This package is derived from an original package,
5642                    // and this device has been updating from that original
5643                    // name.  We must continue using the original name, so
5644                    // rename the new package here.
5645                    pkg.setPackageName(oldName);
5646                    pkgName = pkg.packageName;
5647                    replace = true;
5648                } else if (mPackages.containsKey(pkgName)) {
5649                    // This package, under its official name, already exists
5650                    // on the device; we should replace it.
5651                    replace = true;
5652                }
5653            }
5654            PackageSetting ps = mSettings.mPackages.get(pkgName);
5655            if (ps != null) {
5656                oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
5657                if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) {
5658                    systemApp = (ps.pkg.applicationInfo.flags &amp;
5659                            ApplicationInfo.FLAG_SYSTEM) != 0;
5660                }
5661            }
5662        }
5663
5664        if (systemApp &amp;&amp; onSd) {
5665            // Disable updates to system apps on sdcard
5666            Slog.w(TAG, &quot;Cannot install updates to system apps on sdcard&quot;);
5667            res.returnCode = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
5668            return;
5669        }
5670
5671        if (!args.doRename(res.returnCode, pkgName, oldCodePath)) {
5672            res.returnCode = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
5673            return;
5674        }
5675        // Set application objects path explicitly after the rename
5676        setApplicationInfoPaths(pkg, args.getCodePath(), args.getResourcePath());
5677        pkg.applicationInfo.nativeLibraryDir = args.getNativeLibraryPath();
5678        if (replace) {
5679            replacePackageLI(pkg, parseFlags, scanMode,
5680                    installerPackageName, res);
5681        } else {
5682            installNewPackageLI(pkg, parseFlags, scanMode,
5683                    installerPackageName,res);
5684        }
5685    }
</code></pre><p>关键部分在最后的5678-5684行，如果是重复安装则调用replacePackageLI，负责调用installNewPackageLI(pkg, parseFlags, scanMode,installerPackageName,res);这里以installNewPackageLI为例：</p>
<pre><code>6259    /*
6260     * Install a non-existing package.
6261     */
6262    private void installNewPackageLI(PackageParser.Package pkg,
6263            int parseFlags,
6264            int scanMode,
6265            String installerPackageName, PackageInstalledInfo res) {
6266        // Remember this for later, in case we need to rollback this install
6267        String pkgName = pkg.packageName;
6268
6269        boolean dataDirExists = getDataPathForPackage(pkg.packageName, 0).exists();
6270        res.name = pkgName;
6271        synchronized(mPackages) {
6272            if (mSettings.mRenamedPackages.containsKey(pkgName)) {
6273                // A package with the same name is already installed, though
6274                // it has been renamed to an older name.  The package we
6275                // are trying to install should be installed as an update to
6276                // the existing one, but that has not been requested, so bail.
6277                Slog.w(TAG, &quot;Attempt to re-install &quot; + pkgName
6278                        + &quot; without first uninstalling package running as &quot;
6279                        + mSettings.mRenamedPackages.get(pkgName));
6280                res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
6281                return;
6282            }
6283            if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
6284                // Don&apos;t allow installation over an existing package with the same name.
6285                Slog.w(TAG, &quot;Attempt to re-install &quot; + pkgName
6286                        + &quot; without first uninstalling.&quot;);
6287                res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
6288                return;
6289            }
6290        }
6291        mLastScanError = PackageManager.INSTALL_SUCCEEDED;
6292        PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode,
6293                System.currentTimeMillis());
6294        if (newPackage == null) {
6295            Slog.w(TAG, &quot;Package couldn&apos;t be installed in &quot; + pkg.mPath);
6296            if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
6297                res.returnCode = PackageManager.INSTALL_FAILED_INVALID_APK;
6298            }
6299        } else {
6300            updateSettingsLI(newPackage,
6301                    installerPackageName,
6302                    res);
6303            // delete the partially installed application. the data directory will have to be
6304            // restored if it was already existing
6305            if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
6306                // remove package from internal structures.  Note that we want deletePackageX to
6307                // delete the package data and cache directories that it created in
6308                // scanPackageLocked, unless those directories existed before we even tried to
6309                // install.
6310                deletePackageLI(
6311                        pkgName, false,
6312                        dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,
6313                                res.removedInfo, true);
6314            }
6315        }
6316    }
</code></pre><p>关键代码部分为：</p>
<pre><code>6292        PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode,
6293                System.currentTimeMillis());
</code></pre><p>最终回到了和开机安装一样的地方，与开机方式安装调用统一方法scanPackageLI。后续步骤则完全一致了。</p>
<h3 id="从ADB工具安装过程代码解析"><a href="#从ADB工具安装过程代码解析" class="headerlink" title="从ADB工具安装过程代码解析"></a>从ADB工具安装过程代码解析</h3><p>通过adb命令方式，真实的入口其实是com/android/commands/pm/Pm.java，其中showUsage方法为使用方法说明：</p>
<pre><code>1111    private static void showUsage() {
1112        System.err.println(&quot;usage: pm list packages [-f] [-d] [-e] [-s] [-e] [-u] [FILTER]&quot;);
1113        System.err.println(&quot;       pm list permission-groups&quot;);
1114        System.err.println(&quot;       pm list permissions [-g] [-f] [-d] [-u] [GROUP]&quot;);
1115        System.err.println(&quot;       pm list instrumentation [-f] [TARGET-PACKAGE]&quot;);
1116        System.err.println(&quot;       pm list features&quot;);
1117        System.err.println(&quot;       pm list libraries&quot;);
1118        System.err.println(&quot;       pm path PACKAGE&quot;);
1119        System.err.println(&quot;       pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] [-s] [-f] PATH&quot;);
1120        System.err.println(&quot;       pm uninstall [-k] PACKAGE&quot;);
1121        System.err.println(&quot;       pm clear PACKAGE&quot;);
1122        System.err.println(&quot;       pm enable PACKAGE_OR_COMPONENT&quot;);
1123        System.err.println(&quot;       pm disable PACKAGE_OR_COMPONENT&quot;);
1124        System.err.println(&quot;       pm disable-user PACKAGE_OR_COMPONENT&quot;);
1125        System.err.println(&quot;       pm set-install-location [0/auto] [1/internal] [2/external]&quot;);
1126        System.err.println(&quot;       pm get-install-location&quot;);
1127        System.err.println(&quot;       pm createUser USER_NAME&quot;);
1128        System.err.println(&quot;       pm removeUser USER_ID&quot;);
1129        System.err.println(&quot;&quot;);
1130        System.err.println(&quot;pm list packages: prints all packages, optionally only&quot;);
1131        System.err.println(&quot;  those whose package name contains the text in FILTER.  Options:&quot;);
1132        System.err.println(&quot;    -f: see their associated file.&quot;);
1133        System.err.println(&quot;    -d: filter to only show disbled packages.&quot;);
1134        System.err.println(&quot;    -e: filter to only show enabled packages.&quot;);
1135        System.err.println(&quot;    -s: filter to only show system packages.&quot;);
1136        System.err.println(&quot;    -3: filter to only show third party packages.&quot;);
1137        System.err.println(&quot;    -u: also include uninstalled packages.&quot;);
            ...
</code></pre><p>而安装时调用的方法即runInstall(),方法内的关键代码为：</p>
<pre><code>798        PackageInstallObserver obs = new PackageInstallObserver();
799        try {
800            mPm.installPackageWithVerification(apkURI, obs, installFlags, installerPackageName,
801                    verificationURI, null);
802
803            synchronized (obs) {
804                while (!obs.finished) {
805                    try {
806                        obs.wait();
807                    } catch (InterruptedException e) {
808                    }
809                }
810                if (obs.result == PackageManager.INSTALL_SUCCEEDED) {
811                    System.out.println(&quot;Success&quot;);
812                } else {
813                    System.err.println(&quot;Failure [&quot;
814                            + installFailureToString(obs.result)
815                            + &quot;]&quot;);
816                }
817            }
818        } catch (RemoteException e) {
819            System.err.println(e.toString());
820            System.err.println(PM_NOT_RUNNING_ERR);
821        }
</code></pre><p>可以看出，实则调用mPm变量的installPackageWithVerification方法。mPm变量为IPackageManager接口的实现类的对象，通过78行，不难发现，其实又是绑定远程的PackageManagerService来完成具体的操作，此时就回到与网络下载的地方了，后续步骤可参加网络下载部分的分析。</p>
<pre><code>53        public final class Pm {
54            IPackageManager mPm;
55
56            private WeakHashMap&lt;String, Resources&gt; mResourceCache
57                    = new WeakHashMap&lt;String, Resources&gt;();
58
59            private String[] mArgs;
60            private int mNextArg;
61            private String mCurArgData;
62
63            private static final String PM_NOT_RUNNING_ERR =
64                &quot;Error: Could not access the Package Manager.  Is the system running?&quot;;
65            private static final int ROOT_UID = 0;
66
67            public static void main(String[] args) {
68                new Pm().run(args);
69            }
70
71            public void run(String[] args) {
72                boolean validCommand = false;
73                if (args.length &lt; 1) {
74                    showUsage();
75                    return;
76                }
77
78                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(&quot;package&quot;));
79                if (mPm == null) {
80                    System.err.println(PM_NOT_RUNNING_ERR);
81                    return;
82                }
</code></pre><h3 id="通过第三方应用从SD卡安装的过程代码分析"><a href="#通过第三方应用从SD卡安装的过程代码分析" class="headerlink" title="通过第三方应用从SD卡安装的过程代码分析"></a>通过第三方应用从SD卡安装的过程代码分析</h3><p>这其实相当于在PackagManager之上提供一个更便捷的方式给用户安装APK，系统上层的源码中有一个类(Activity)com/android/packageinstaller/PackageInstallerActivity.java，通过它可以便捷地使UI方式安装APK。PackageInstallerActivity的oncreate方法如下(本文的采用的版本可能与读者的版本不同，所以行号和代码细节会有差异，请注意)：</p>
<pre><code>235        @Override
236        protected void onCreate(Bundle icicle) {
237            super.onCreate(icicle);
238            //get intent information
239            final Intent intent = getIntent();
240            mPackageURI = intent.getData();
241            mPm = getPackageManager();
242            mPkgInfo = PackageUtil.getPackageInfo(mPackageURI);
243            
244            // Check for parse errors
245            if(mPkgInfo == null) {
246                Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;);
247                showDialogInner(DLG_PACKAGE_ERROR);
248                return;
249            }
250            
251            //set view
252            requestWindowFeature(Window.FEATURE_NO_TITLE);
253            setContentView(R.layout.install_start);
254            mInstallConfirm = findViewById(R.id.install_confirm_panel);
255            mInstallConfirm.setVisibility(View.INVISIBLE);
256            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this,
257                    mPkgInfo.applicationInfo, mPackageURI);
258            PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);
259           //check setting
260            if(!isInstallingUnknownAppsAllowed()) {
261                //ask user to enable setting first
262                showDialogInner(DLG_UNKNOWN_APPS);
263                return;
264            }
265            initiateInstall();
266        }
</code></pre><p>如265行所示，进入initiateInstall方法，跟踪可以发现，又进入startInstallConfirm()方法，这主要是弹出对话框，让用户确认是否安装，如果确认，那么即进入：</p>
<pre><code>273        public void onClick(View v) {
274        if(v == mOk) {
275            // Start subactivity to actually install the application
276            Intent newIntent = new Intent();
277            newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
278                    mPkgInfo.applicationInfo);
279            newIntent.setData(mPackageURI);
280            newIntent.setClass(this, InstallAppProgress.class);
281            String installerPackageName = getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME);
282            if (installerPackageName != null) {
283                newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName);
284            }
285            if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI);
286            startActivity(newIntent);
287            finish();
288        } else if(v == mCancel) {
289            // Cancel and finish
290            finish();
291        }
292    }
</code></pre><p>确认后，打开新的activity：InstallAppProgress，com/android/packageinstaller/InstallAppProgress．java的关键代码：</p>
<pre><code>126        @Override
127        public void onCreate(Bundle icicle) {
128            super.onCreate(icicle);
129            Intent intent = getIntent();
130            mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);
131            mPackageURI = intent.getData();
132            initView();
133        }
        ...
176        public void initView() {
177            requestWindowFeature(Window.FEATURE_NO_TITLE);
178            setContentView(R.layout.op_progress);
179            int installFlags = 0;
180            PackageManager pm = getPackageManager();
181            try {
182                PackageInfo pi = pm.getPackageInfo(mAppInfo.packageName, 
183                        PackageManager.GET_UNINSTALLED_PACKAGES);
184                if(pi != null) {
185                    installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;
186                }
187            } catch (NameNotFoundException e) {
188            }
189            if((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING )!= 0) {
190                Log.w(TAG, &quot;Replacing package:&quot; + mAppInfo.packageName);
191            }
192            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, mAppInfo,
193                    mPackageURI);
194            mLabel = as.label;
195            PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);
196            mStatusTextView = (TextView)findViewById(R.id.center_text);
197            mStatusTextView.setText(R.string.installing);
198            mProgressBar = (ProgressBar) findViewById(R.id.progress_bar);
199            mProgressBar.setIndeterminate(true);
200            // Hide button till progress is being displayed
201            mOkPanel = (View)findViewById(R.id.buttons_panel);
202            mDoneButton = (Button)findViewById(R.id.done_button);
203            mLaunchButton = (Button)findViewById(R.id.launch_button);
204            mOkPanel.setVisibility(View.INVISIBLE);
205
206            String installerPackageName = getIntent().getStringExtra(
207                    Intent.EXTRA_INSTALLER_PACKAGE_NAME);
208            PackageInstallObserver observer = new PackageInstallObserver();
209            pm.installPackage(mPackageURI, observer, installFlags, installerPackageName);
210        }
</code></pre><p>如上所示，209行则是执行安装的地方，不难发现，这里是pm对象在180行获取，到这里，又回到和网络下载一样的地方了，后续步骤可以参见网络下载安装部分解析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>安装和卸载都是通过PackageManager，实质上是实现了PackageManager的远程服务PackageManagerService来完成具体的操作，所有细节和逻辑均可以在PackageManagerService中跟踪查看；</li>
<li>所有安装方式殊途同归，最终就回到PackageManagerService中，然后调用底层本地代码的installd来完成。</li>
</ol>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Android安装APK详解/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Android studio动态调试指南" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Android studio动态调试指南/">Android studio动态调试</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态调试/">动态调试</a></li></ul>
</div>
        <time datetime="2016-06-13T07:25:56.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h2 id="Android-studio动态调试"><a href="#Android-studio动态调试" class="headerlink" title="Android studio动态调试"></a>Android studio动态调试</h2><p>Android studio动态调试实际上是基于Smali Debugging，而Smali Debugging基于开源的Android反编译工具apktool。</p>
<p><strong>SmaliDebugging has been marked as deprecated in 2.0.3, and will be removed in 2.1. Alternative tool(s) will be linked on 2.1 release.</strong> </p>
<p>Apktool makes possible to debug smali code step by step, watch variables, set breakpoints, etc.</p>
<p>本文出自apktool官方网站说明<a href="http://ibotpeaches.github.io/Apktool/documentation/" title="smali debugging" target="_blank" rel="external">http://ibotpeaches.github.io/Apktool/documentation/</a></p>
<h2 id="General-information-概述"><a href="#General-information-概述" class="headerlink" title="General information(概述)"></a>General information(概述)</h2><ul>
<li>Generally we need several things to run Java debugging session: </li>
</ul>
<pre><code>1. debugger server (usually Java VM)
2. debugger client (usually IDE like IntelliJ, Eclipse or Netbeans)
3. client must have sources of debugged application
4. server must have binaries compiled with debugging symbols referencing these sources
5. sources must be java files with at least package and class definitions, to properly connect them with debugging symbols
</code></pre><ul>
<li>In our particular situation we have: <ol>
<li>server: Monitor (Previously DDMS), part of Android SDK, standard for debugging Android applications - explained here</li>
<li>client: any JPDA client - most of decent IDEs have support for this protocol.</li>
<li>sources: smali code modified by apktool to satisfy above requirements (“.java” extension, class declaration, etc.). Apktool modifies them when decoding apk in debug mode.</li>
<li>binaries: when building apk in debug mode, apktool removes original symbols and adds new, which are referencing smali code (line numbers, registers/variables, etc.)</li>
</ol>
</li>
</ul>
<p><em>*Info</em>:* </p>
<pre><code>To successfully run debug sessions, the apk must be both decoded and built in debug mode. Decoding with debug decodes the application differently to allow the debug rebuild option to inject lines allowing the debugger to identify variables and types.-d / --debug
</code></pre><h2 id="General-instructions-一般性步骤"><a href="#General-instructions-一般性步骤" class="headerlink" title="General instructions(一般性步骤)"></a>General instructions(一般性步骤)</h2><p>Above information is enough to debug smali code using apktool, but if you aren’t familiar with DDMS and Java debugging, then you probably still don’t know how to do it. Below are simple instructions for doing it using IntelliJ or Netbeans. </p>
<ol>
<li>Decode apk in debug mode: $ apktool d -d -o out app.apk</li>
<li>Build new apk in debug mode: $ apktool b -d out</li>
<li>Sign, install and run new apk.</li>
<li><strong>Follow sub-instructions below depending on IDE.</strong><h3 id="IntelliJ-Android-Studio-instructions-针对Android-studio的操作步骤"><a href="#IntelliJ-Android-Studio-instructions-针对Android-studio的操作步骤" class="headerlink" title="IntelliJ (Android Studio) instructions(针对Android studio的操作步骤)"></a>IntelliJ (Android Studio) instructions(针对Android studio的操作步骤)</h3></li>
</ol>
<ol>
<li>In IntelliJ add new Java Module Project selecting the “out” directory as project location and the “smali” subdirectory as content root dir.</li>
</ol>
<ol>
<li>Run Monitor (Android SDK /tools folder), find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”.</li>
</ol>
<ol>
<li>In IntelliJ: Debug -&gt; Edit Configurations. Since this is a new project, you will have to create a Debugger.</li>
</ol>
<ol>
<li>Create a Remote Debugger, with the settings on “Attach” and setting the Port to 8700 (Or whatever Monitor said). The rest of fields should be ok, click “Ok”.</li>
</ol>
<ol>
<li>Start the debugging session. You will see some info in a log and debugging buttons will show up in top panel.</li>
</ol>
<ol>
<li>Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”.</li>
</ol>
<ol>
<li>Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc.</li>
</ol>
<h3 id="Netbeans-instructions-针对Netbeans的操作步骤"><a href="#Netbeans-instructions-针对Netbeans的操作步骤" class="headerlink" title="Netbeans instructions(针对Netbeans的操作步骤)"></a>Netbeans instructions(针对Netbeans的操作步骤)</h3><ol>
<li>In Netbeans add new Java Project with Existing Sources, select “out” directory as project root and “smali” subdirectory as sources dir.</li>
</ol>
<ol>
<li>Run DDMS, find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”.</li>
</ol>
<ol>
<li>In Netbeans: Debug -&gt; Attach Debugger -&gt; select JPDA and set Port to 8700 (or whatever you saw in previous step). Rest of fields should be ok, click “Ok”.</li>
</ol>
<ol>
<li>Debugging session should start: you will see some info in a log and debugging buttons will show up in top panel.</li>
</ol>
<ol>
<li>Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”.</li>
</ol>
<ol>
<li>Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc.</li>
</ol>
<h2 id="Limitations-Issues-限制和已知问题"><a href="#Limitations-Issues-限制和已知问题" class="headerlink" title="Limitations/Issues(限制和已知问题)"></a>Limitations/Issues(限制和已知问题)</h2><p>Because IDE doesn’t have full sources, it doesn’t know about class members and such.<br>Variables watching works because most of data could be read from memory (objects in Java know about their types), but if for example, you watch an object and it has some nulled member, then you won’t see, what type this member is.</p>
<h1 id="apktool-2-1-0之后版本动态调试-适用于Android-studio"><a href="#apktool-2-1-0之后版本动态调试-适用于Android-studio" class="headerlink" title="apktool 2.1.0之后版本动态调试(适用于Android studio)"></a>apktool 2.1.0之后版本动态调试(适用于Android studio)</h1><p>官方地址参见<a href="https://github.com/JesusFreke/smali/wiki/smalidea">https://github.com/JesusFreke/smali/wiki/smalidea</a></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Android studio动态调试指南/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Android APK瘦身初探" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Android APK瘦身初探/">Android APK瘦身策略</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APK瘦身/">APK瘦身</a></li></ul>
</div>
        <time datetime="2016-06-13T06:34:28.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>随着Android技术的发展，以及用户需求的井喷，Android应用的APK大小也随着越来越“胖”，APK在安装和更新之前都需要经过网络将其下载到手机，如果APK越大消耗的流量就会越多，特别是对于使用移动网络的用户来讲，消耗流量越多就代表需要花更多的钱去购买流量。同时一些第三方应用商城也会对上传的APK大小有限制，所以为了能够让产品能够更受商城和用户欢迎，APK瘦身是第一步，更小的APK标示着更多地用户愿意去下载和体验。因此，APK瘦身大有必要！</p>
<h1 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h1><p>Android应用的APK文件其实就是一个压缩文件，可以用常规的压缩软件打开，查看其目录结构。为了能够减小APK的大小，首先需要知道APK由哪些部分构成，然后针对每个部分做相应的优化工作，下图是一个APK解压后的文件结构（各APK的结构核心内容是一致的，差异化的文件暂不关注）:</p>
<p><img src="http://i.imgur.com/nfreQFu.png" alt="APK目录结构"></p>
<p>各文件的介绍如下：</p>
<ul>
<li><p>classes.dex：classes.dex是java源码编译后生成的java字节码文件。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。Android模拟器中提供了一个dex文件的反编译工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，找到要查看的dex文件，执行dexdump xxx.dex（或者从压缩文件取出dex文件，直接在PC上面找到dexdump.exe的路径，然后执行命令）。另外Dedexer是一个反编译dex文件的开源工具，需要自己编译源代码。而当前，还有比如dex2jar甚至封装好的GUI的工具(比如安卓逆向助手等等)可以反编译dex文件为jar文件，再利用jd-gui工具打开jar文件，就可以阅读java源代码了。</p>
</li>
<li><p>resources.arsc：编译后的二进制资源文件</p>
</li>
<li><p>AndroidManifest.xml：清单文件，该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过压缩的，可以通过AXMLPrinter2工具解开，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml</p>
</li>
<li><p>proguard.cfg：代码混淆配置文件(上图中暂无包括混淆配置)；</p>
</li>
<li><p>project.properties：标示APK的target sdk和依赖关系，这里的依赖关系指示的是该APK依赖到了哪些工程(上图中暂无包括依赖配置)；</p>
</li>
<li><p>assets：assets目录可以存放一些配置文件（比如webview本地资源、图片资源、音视频等等），这些文件的内容在程序运行过程中可以通过相关的API（android.content.res.AssetManager）获得。</p>
</li>
<li><p>lib：lib目录下的子目录armeabi存放的是一些so文件。这个地方多讲几句，都是在开发过程中摸索出来的。eclipse在打包的时候会根据文件名的命名规则（lib**.so）去打包so文件，开头和结尾必须分别为“lib”和“.so”，否则是不会打包到apk文件中的。其他非eclipse开发环境没有测试过。如果你是用SDK和NDK开发的话，这部分很重要，甚至可以通过把一些不是so文件的文件通过改名打包到apk中，具体能干些什么那就看你想干什么了，呵呵呵！</p>
</li>
<li><p>META-INF：META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。</p>
</li>
<li><p>res：res目录存放资源文件。包括图片、字符串、raw文件夹下面的音频文件、各种xml文件等等。</p>
</li>
</ul>
<h1 id="优化探讨"><a href="#优化探讨" class="headerlink" title="优化探讨"></a>优化探讨</h1><p>从前面的目录结构图分析可知，<strong>APK中classes.dex、lib、资源文件是大头，APK瘦身主要就是优化这三类</strong>，关于这三种类型的文件比较成熟的优化方法有：</p>
<ul>
<li><p><strong>classes.dex:</strong>这是减少apk文件至关重要的第一步。你要对自己的代码了如子掌。你要移除掉所有无用处的dependency libraries，让你的代码一天比一天优秀，持续地优化你的代码。总而言之，保持一个简洁，最新的代码基础是减少apk文件至关重要的一环。当然，从零开始一个项目并为这个项目保持一份简洁的代码基础很容易。项目越老，这个工作就越困难。事实上，拥有一大段历史背景的项目必须要去处理各种死代码和无用代码。还好有许多的开发工具可以帮我们来做这些事情……Proguard 是一个很强悍的工具，它可以帮你在代码编译时对代码进行混淆，优化和压缩。它有一个专门用来减少apk文件大小的功能叫做 tree-shaking。Proguard 会遍历你的所有代码然后找出无用处的代码。所有这些不可达（或者不需要）的代码都会在生成最终的apk文件之前被清除掉。Proguard 也会重命名你的类属性，类和接口，然整个代码尽可能地保持轻量级水平。也许现在你会认为 Proguard 是一个相当有效地工具。但是能力越大，责任也就越大。现在许多开发这认为Proguard有点让人不省心，因为它会重度依赖反射。哪些类或者属性需要被处理或者不能处理都要开发者对Proguard进行配置。但通过代码混淆，删掉不必要的jar包和代码可实现dex文件的优化；</p>
</li>
<li><p><strong>lib:</strong>一个硬件设备对应一个架构（mips、arm或者x86），只保留与设备架构相关的库文件夹（主流的架构都是arm的，mips属于小众，默认也是支持arm的so的，但x86的不支持），这样可以大大降低lib文件夹的大小；</p>
</li>
<li><p><strong>资源文件：</strong>Proguard 只会对 Java 代码起作用，那么对哪些资源文件呢？比如一张图片 my_image 在 res/drawable 文件夹中，没有被使用，Proguard 只会移除掉 R 类中的引用，但是图片依然还在文件夹中。Lint 一个静态的代码分析器，你只需通过调用 ./gradlew lint这个简单地命令它就能帮你检查所有无用的资源文件。它在检测完之后会提供一份详细的资源文件清单，并将无用的资源列在“UnusedResources: Unused resources” 区域之下。只要你不通过反射来反问这些无用资源，你就可以放心地移除这些文件了。Lint 会分析资源文件(比如 /res 文件夹下面的文件) ，但是会跳过 assets 文件 ( /assets 文件夹下面的文件)。事实上assets 文件是可以通过它们的文件名直接访问的，而不需要通过Java引用或者XML引用。因此，Lint 也不能判定某个 asset 文件在项目中是否有用。这全取决于开发者对这个文件夹的维护了。如果你没有使用某个asset 文件，那么你就可以直接清除这个文件。通过Lint工具扫描代码中没有使用到的静态资源。</p>
</li>
</ul>
<p>上面介绍的三种类型文件的优化方案的确能够在一定程度上减小APK的大小，但在最近做项目的过程中经过研究发现还可以更进一步优化APK的大小，具体方案如下：</p>
<ul>
<li><p>多分辨率适配：这里的水很深，网上也有很多文章介绍经验（比如一套图、一套布局，多套dimens.xml文件，在使用最小资源的情况下搞定多分辨率适配），Android官网也有专门的篇章介绍，详细研究可以参看；</p>
</li>
<li><p>预置数据：和游戏一样，程序和数据分离，进入模块时下载预置数据（下载的策略需要注重用户体验，在需要使用数据的地方下载）；</p>
</li>
<li><p>图片资源：压缩优化图片资源（<strong>图片资源的优化原则是：在不降低图片效果、保证APK显示效果的前提下缩小图片文件的大小。</strong>），或者使用新的图片格式，Aapt（Android Asset Packaging Tool）就内置了 保真图像压缩算法。例如，一个只需 256 色的真彩PNG图片会被aapt 通过一个颜色调色板转化成一个 8-bit PNG 文件。这可以帮助你减少图片文件的大小。当然你还可以通过Google查找相应的优化工具，比如 压缩png图片的常用工具有tinypng（<a href="https://tinypng.com" title="tinypng官网" target="_blank" rel="external">https://tinypng.com</a>）、pngquant（<a href="https://pngquant.org/" title="pngquant官网" target="_blank" rel="external">https://pngquant.org/</a>）、ImageAlpha 和 ImageOptim 等。还有一种只在Android平台上存在的图片文件也可以优化，它就是 9-patches。就目前所了解的情况，还没发现针对这类图片文件的高效优化工具。然而你只需要求你的设计师将它的可扩展区域和内容区域尽可能地减少即可。这不但可以减少资源文件的大小，还能使得以后资源文件的维护变得更加简单。你可以从中选择一个适合你的工具。而<strong>Android支持的新式的图片格式webP</strong>，下面详细介绍图片资源优化(压缩)的方案。</p>
</li>
</ul>
<h2 id="图片压缩工具介绍"><a href="#图片压缩工具介绍" class="headerlink" title="图片压缩工具介绍"></a>图片压缩工具介绍</h2><p><strong>1.tinypng：</strong></p>
<p>tinypng是一个支持压缩png和jpg图片格式的网站（<a href="https://tinypng.com" title="tinypng官网" target="_blank" rel="external">https://tinypng.com</a>），通过其独特的算法（通过一种叫“量化”的技术，把原本png文件的24位真彩色压缩为8位的索引演示，是一种矢量压缩方法，把颜色值用数值123等代替。）可以实现在无损压缩的情况下图片文件大小缩小到原来的30%-50%甚至更多。</p>
<p>tinypng的缺点是在压缩某些带有过渡效果（带alpha值）的图片时，图片会失真，这种图片可以将png图片转换为下面介绍的webP格式，可以在保证图片质量的前提下大幅缩小图片的大小。需要说明的是：tinypng支持png和jpg图片的压缩，并且也支持9图的压缩。</p>
<p>tinypng提供了开放接口供开发者开发属于自己的压缩工具，不过这是付费服务，对于普通用户来说，tinypng为每个用户提供的每月图片免费压缩数量（目前是500张/月）已经足够了。</p>
<p><strong>2.使用webP图片格式：</strong></p>
<p>WebP是谷歌研发出来的一种图片数据格式，它是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。目前很多公司已经将webP技术运用到Android APP中，比如FaceBook、腾讯、淘宝。webP相比于png最明显的问题是加载稍慢，不过现在的智能设备硬件配置越来越高，这都不是事儿。</p>
<p> 假如你打算在 App 中使用 WebP，除了 Android4.0 以上提供的原生支持外，其他版本以可以使用官方提供的解析库webp-android-backport编译成so使用。</p>
<p> 通常UI提供的图片都是png或者jpg格式，我们可以通过智图或者isparta将其它格式的图片转换成webP格式，isparta可实现批量转换，墙裂推荐！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>APK瘦身是一个系统工程，不可能一蹴而就，而且与APK的体验及功能等密切相关，不能顾此失彼，既要保证APK和画面的质量，又要尽量减少APK的体积，因此，需要综合考虑各个因素，做出更优的策略。</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/Android APK瘦身初探/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-python安装第三方包错误解决" class="article article-type-post" itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/python安装第三方包错误解决/">python安装某些第三方包报错解决办法</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安装第三方包/">安装第三方包</a></li></ul>
</div>
        <time datetime="2016-06-13T01:57:02.000Z" itemprop="datePublished" class="post-tiem">
  2016-06-13
</time>
      </div>
      <div class="post-content" id="post-content" itemprop="postContent" >
        
          <h1 id="1-python安装某些第三方包报错vcvarsall-bat"><a href="#1-python安装某些第三方包报错vcvarsall-bat" class="headerlink" title="1. python安装某些第三方包报错vcvarsall.bat"></a>1. <strong>python安装某些第三方包报错vcvarsall.bat</strong></h1><p>原因：python安装某些第三方包(这里主要针对Windows平台)，主要是涉及系统底层和本地代码库时，需要C编译环境，Windows平台下，python本身是通过VC的编译环境编译的，不同的python版本对应不同的VC的动态库，同事，第三方库可能是采用其他编译器（比如GNU C、Cygwin、MinGW等）编译扩展的C代码。</p>
<p>Mingw官方链接：<a href="http://sourceforge.net/projects/mingw/" title="Mingw官网链接" target="_blank" rel="external">http://sourceforge.net/projects/mingw/</a></p>
<p>官方说明：python3的安装包的构建主要是通过内置的Distutils工具来完成(<a href="https://docs.python.org/3.4/install/" title="Building Extensions: Tips and Tricks" target="_blank" rel="external">https://docs.python.org/3.4/install/</a>)</p>
<pre><code>Whenever possible, the Distutils try to use the configuration information made available by the Python 
interpreter used to run the setup.py script. For example, the same compiler and linker flags used to compile 
Python will also be used for compiling extensions. Usually this will work well, but in complicated situations 
this might be inappropriate. This section discusses how to override the usual Distutils behaviour.
</code></pre><p>解决方案：</p>
<ol>
<li>安装python对应版本的VC编译器，可以直接安装整个visual studio；</li>
<li><p>如果不想整个安装VC，则可以选择安装MinGW（并将其安装后的bin等目录加入到系统path），然后配置python分发包的默认编译工具，<br>即在python安装目录的Lib\distutils目录下(比如安装的python3.4版本，那么即似C:\Python34\Lib\distutils)，新建distutils.cfg文件(如果已有，则直接编辑之)。打开该文件，在前面添加如下内容。</p>
<pre><code>[build]
compiler=mingw32
</code></pre><p> 上述设置之后python distutils构建带C扩展的库或者安装C扩展的库之时，全部都切换至设置的编译器，如果只是想修改某一次的构建或者安装时使用的编译器，则可以在构建或者安装的时候加上参数，如：</p>
<pre><code>python setup.py build --compiler=mingw32 install
</code></pre></li>
</ol>
<h1 id="2-安装某些包时报错，类似”collect2-exe-error-ld-returned-1-exit-status”，"><a href="#2-安装某些包时报错，类似”collect2-exe-error-ld-returned-1-exit-status”，" class="headerlink" title="2.安装某些包时报错，类似”collect2.exe: error: ld returned 1 exit status”，"></a>2.<strong>安装某些包时报错，类似”collect2.exe: error: ld returned 1 exit status”，</strong></h1><pre><code>C:\Python27\libs/libpython27.a(dmmes01026.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos;
C:\Python27\libs/libpython27.a(dmmes00281.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos;
C:\Python27\libs/libpython27.a(dmmes00105.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos;
C:\Python27\libs/libpython27.a(dmmes00253.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos;
C:\Python27\libs/libpython27.a(dmmes00227.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos;
C:\Python27\libs/libpython27.a(dmmes00712.o):(.idata$7+0x0): more undefined references to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; follow
collect2.exe: error: ld returned 1 exit status
</code></pre><p>原因：和问题1本质一样，由于Windows平台下的python编译器本身由VC环境编译，其生成的pythonxx.dll(xx是版本号，比如27、34)和pythonxx.lib等可能与需要安装的第三方库（采用Cygwin、MinGW等编译器(环境)生成并发布）无法兼容.</p>
<p>解决方案：<br>    To create Python extensions, you need to link against the Python library. Unfortunately, most Python distributions are provided with  Pythonxx.lib, a library in Microsoft Visual C++ format. GCC expects a.a file (libpythonxx.a to be precise.). Here’s how to convert  pythonxx.lib to libpythonxx.a:</p>
<p><strong>a.</strong>Download pexport (from here or <a href="http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/" target="_blank" rel="external">http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/</a>).</p>
<p><strong>b.</strong>Get  pythonxx.dll (it should be somewhere on your harddrive).</p>
<p><strong>c.</strong>Run : pexports pythonxx.dll &gt; pythonxx.def This will extract all symbols from pythonxx.dll and write them into pythonxx.def.</p>
<p><strong>d.</strong>Run : dlltool –dllname pythonxx.dll –def pythonxx.def –output-lib libpythonxx.a This will create libpythonxx.a (dlltool is part of MinGW utilities).<br>Copy libpythonxx.a to c:\pythonxx\libs\ (in the same directory as  pythonxx.lib).<br>This trick should work for all Python versions, including future releases of Python. You can also use this trick to convert other libraries.</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2016/06/13/python安装第三方包错误解决/" class="post-more waves-effect waves-button waves-light">MORE</a>
      </div>
    

  </article>


</li>
  
  </ul>
  
    <nav id="page-nav">
      <div class="inner">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
      </div>
    </nav>
  


    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Atypical programmer",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "https://github.com/cstsinghua/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
