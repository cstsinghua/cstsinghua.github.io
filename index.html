<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Atypical programmer | 做一个非典型程序员</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="写给典型的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="Atypical programmer">
<meta property="og:url" content="http://cstsinghua.github.io/index.html">
<meta property="og:site_name" content="Atypical programmer">
<meta property="og:description" content="写给典型的程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Atypical programmer">
<meta name="twitter:description" content="写给典型的程序员">
  
    <link rel="alternative" href="/atom.xml" title="Atypical programmer" type="application/atom+xml">
  
  <meta name="summary" content="写给典型的程序员">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Cstsinghua</h5>
        <a href="mailto:undefined" title="cstsinghua@126.com" class="mail">cstsinghua@126.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Android"  >
            <i class="icon icon-lg icon-android"></i>
            Android
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Java"  >
            <i class="icon icon-lg icon-coffee"></i>
            Java
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/Python"  >
            <i class="icon icon-lg icon-product-hunt"></i>
            Python
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/NodeJS"  >
            <i class="icon icon-lg icon-shield"></i>
            NodeJS
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/categories/杂项/"  >
            <i class="icon icon-lg icon-book"></i>
            杂项
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags/"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/sitemap.xml"  >
            <i class="icon icon-lg icon-sitemap"></i>
            Sitemap
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/cstsinghua" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://developer.android.com"  >
            <i class="icon icon-lg icon-link"></i>
            Android官网
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Atypical programmer &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Atypical programmer</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Atypical programmer</h1>
    <h5 class="subtitle">
         
        做一个非典型程序员
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-npm常用命令" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/11/04/npm常用命令/">npm常用命令</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-11-04T03:53:47.000Z" itemprop="datePublished" class="post-time">
  2016-11-04
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/">NodeJS</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/npm/">npm</a></li></ul></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>npm常用命令介绍<br>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NodeJS/">NodeJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/常用/">常用</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Android知识体系及新手如何快速入门" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/09/12/Android知识体系及新手如何快速入门/">Android知识体系及新手如何快速入门</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-09-12T06:25:13.000Z" itemprop="datePublished" class="post-time">
  2016-09-12
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/学习/">学习</a></li></ul></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>Android知识体系及新手如何快速入门<br>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入门/">入门</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新手/">新手</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/路线图/">路线图</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Eclipse常用快捷键" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/14/Eclipse常用快捷键/">Eclipse常用快捷键</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-14T09:30:18.000Z" itemprop="datePublished" class="post-time">
  2016-07-14
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/Tools使用/">Tools使用</a></li></ul></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>Eclipse常用的快捷键总结<br>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Eclipse/">Eclipse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/常用/">常用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/快捷键/">快捷键</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Android-studio常用快捷键" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/13/Android-studio常用快捷键/">Android studio常用快捷键</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-13T10:07:19.000Z" itemprop="datePublished" class="post-time">
  2016-07-13
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/Tools/">Tools</a></li></ul></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>Android studio常用的快捷键<br>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-studio/">Android studio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/快捷键/">快捷键</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-删除Windows下的超长路径目录" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/08/删除Windows下的超长路径目录/">删除Windows下的超长路径目录</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-08T02:28:12.000Z" itemprop="datePublished" class="post-time">
  2016-07-08
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Python/">Python</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="删除超长路径文件或者目录"><a href="#删除超长路径文件或者目录" class="headerlink" title="删除超长路径文件或者目录"></a>删除超长路径文件或者目录</h1><p>在Windows操作系统，由于使用目录工具不当或者在使用某些编程工具时生成目录时(比如反复在同一目录下导入同一个工程)常常会产生多层递归模式，导致产生多级超长目录结构，而无法用Windows可视化右键模式进行删除，市面上的很多文件删除工具，如360强力删除、unlocker删除都无济于事，真是一件恼人的事情。</p>
<p>其实，windows系统自身便带有相关的命令行工具可以用来删除，操作过程如下：</p>
<ol>
<li>比如D盘下面如存在D:\blog\node_modules\a\b\c......多层嵌套的目录；</li>
<li>通过cmd命令行输入cd命令进入上述目录；</li>
<li>mkdir tempDir这个为空目录结构；</li>
<li>robocopy /mir tempDir a；//<strong>tempDir是步骤3创建的空目录名称，而a则是D:\blog\node_modules\目录下的直接子目录即a</strong></li>
<li>上面执行完毕之后，便可以删除目录了</li>
</ol>
<p>但是在某些情况下，执行robocopy命令在中途就可能停止，又不得不重新执行该命令，直到目录完全被删除为止。因此可以写批处理文件来循环操作，当然也可以采用简单的python脚本来执行。</p>
<h1 id="采用python脚本循环删除超长目录"><a href="#采用python脚本循环删除超长目录" class="headerlink" title="采用python脚本循环删除超长目录"></a>采用python脚本循环删除超长目录</h1><p>示例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="string">'''</span><br><span class="line">1.比如无法删除的超长目录为D:\blog\node_modules\a\b\c\...\...；</span><br><span class="line">2.执行完毕之后，目录变成D:\blog\node_modules，后面的a\b\c\...\...则会被删除；</span><br><span class="line">'''</span></span><br><span class="line">os.chdir(<span class="string">r"D:\blog\node_modules"</span>)</span><br><span class="line">os.mkdir(<span class="string">r"D:\blog\node_modules\tempDir"</span>)<span class="comment">#创建临时的空目录</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    result = os.system(<span class="string">"Robocopy.exe tempDir a /MIR"</span>)</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">os.rmdir(<span class="string">r"D:\blog\node_modules\tempDir"</span>)<span class="comment">#删除之前创建的临时目录</span></span><br></pre></td></tr></table></figure></p>
<p><strong>note：os.system(“Robocopy.exe tempDir a /MIR”)中tempDir是步骤创建的空目录名称，而a则是D:\blog\node_modules\目录下的直接子目录即a，实际使用时需要修改成你自己的目录</strong></p>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/">Windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/删除/">删除</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/超长目录/">超长目录</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Protocol Buffers使用说明" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/01/Protocol Buffers使用说明/">Protocol Buffers使用说明</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-01T02:09:43.000Z" itemprop="datePublished" class="post-time">
  2016-07-01
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Protocol-Buffers简介"><a href="#Protocol-Buffers简介" class="headerlink" title="Protocol Buffers简介"></a>Protocol Buffers简介</h1><p>Protocol Buffers是一种数据交换格式，用于结构化数据的读写，类似于序列化机制。在线客服系统里面Message的body部分其实就是具有结构化的数据，因此可以采用Protocol Buffers来实现各平台和语言之间的消息传输。Protocol Buffers特点以及与XML、各语言的序列化机制等的比较，可以后续展开，这里不赘述！此处重点说明其如何使用，特别是针对java(Android)平台。</p>
<p>Github地址：<a href="https://github.com/google/protobuf" target="_blank" rel="external">https://github.com/google/protobuf</a></p>
<p>官方地址：<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external"> https://developers.google.com/protocol-buffers/</a></p>
<h1 id="Protocol-Buffers的使用"><a href="#Protocol-Buffers的使用" class="headerlink" title="Protocol Buffers的使用"></a>Protocol Buffers的使用</h1><p>Protocol Buffers分为如下几个步骤</p>
<h2 id="1-Defining-Your-Protocol-Format-定义数据交换的协议格式"><a href="#1-Defining-Your-Protocol-Format-定义数据交换的协议格式" class="headerlink" title="1. Defining Your Protocol Format(定义数据交换的协议格式)"></a>1. <strong>Defining Your Protocol Format(定义数据交换的协议格式)</strong></h2><p>简单来说，就是类似于定义面向对象语言中的类，其相当于一个数据结构，对应用程序中要交换的数据做一个定义，包括各种字段的声明等等。其文件扩展名为.proto。对于.proto文件如何定义和其语法规范，请详细阅读<a href="https://developers.google.com/protocol-buffers/docs/proto3" title="Protocol Buffer Language Guide" target="_blank" rel="external">Protocol Buffer Language Guide</a>。这里是proto3版本(最新版本，建议采用)，proto2的也可以参阅<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">proto2 Language Guide</a></p>
<p>.proto示例(addressbook.proto)：</p>
<pre><code>//
// Note: START and END tags are used in comments to define sections used in
// tutorials.  They are not part of the syntax for Protocol Buffers.
//
// To get an in-depth walkthrough of this file and the related examples, see:
// https://developers.google.com/protocol-buffers/docs/tutorials

// [START declaration]
syntax = &quot;proto3&quot;;
package tutorial;
// [END declaration]

// [START java_declaration]
option java_package = &quot;com.example.tutorial&quot;;
option java_outer_classname = &quot;AddressBookProtos&quot;;
// [END java_declaration]

// [START csharp_declaration]
option csharp_namespace = &quot;Google.Protobuf.Examples.AddressBook&quot;;
// [END csharp_declaration]

// [START messages]
message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;
}

// Our address book file is just one of these.
message AddressBook {
  repeated Person people = 1;
}
// [END messages]
</code></pre><h2 id="2-Protocol-Compiler-Installation-获取protoc可执行二进制文件"><a href="#2-Protocol-Compiler-Installation-获取protoc可执行二进制文件" class="headerlink" title="2. Protocol Compiler Installation(获取protoc可执行二进制文件)"></a>2. <strong>Protocol Compiler Installation(获取protoc可执行二进制文件)</strong></h2><p>可以在Github和其官方地址上看到相关的说明，但是个人觉得其让人不觉明历，通俗来说，这一步就是要生成一个可执行的protoc二进制文件(在windows平台下即protoc.exe)。这里以Windows平台为例说明(后续如无特殊说明，均默认是Windows平台)。建议直接使用Google提供的已经编译好的二进制可执行文件(<a href="http://repo1.maven.org/maven2/com/google/protobuf/protoc/" title="protoc可执行二进制文件下载" target="_blank" rel="external">http://repo1.maven.org/maven2/com/google/protobuf/protoc/</a>)，建议选择最新版本下载(根据自己操作系统的平台选择对应版本)。想要自己编译生成也可以，不过会遇到各种坑，感兴趣的童鞋可以尝试之<a href="https://github.com/google/protobuf/releases" title="下载protocol buffer源码包" target="_blank" rel="external">protocol buffer源码包</a>。</p>
<p>protoc.exe是干什么的呢？其用来编译用户定义的数据结构即步骤1中编写的.proto文件，详细参见步骤3.</p>
<h2 id="3-Compiling-Your-Protocol-Buffers-编译Protocol-Buffers，即编译-proto文件"><a href="#3-Compiling-Your-Protocol-Buffers-编译Protocol-Buffers，即编译-proto文件" class="headerlink" title="3.  Compiling Your Protocol Buffers(编译Protocol Buffers，即编译.proto文件)"></a>3.  <strong>Compiling Your Protocol Buffers(编译Protocol Buffers，即编译.proto文件)</strong></h2><p>即用步骤2得到的protoc可执行二进制文件编译步骤1所得的.proto文件，最终生成语言相关的类(代码)。这里以java语言为例：其命令格式如下：</p>
<pre><code>protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto
</code></pre><p>eg:</p>
<pre><code>D:\protobuf-3.0.0-beta-2\src&gt;protoc.exe -I=D:\protobuf-3.0.0-beta-2\src --java_out=D:\kefu D:\protob
uf-3.0.0-beta-2\src\boyim.proto
</code></pre><p>如上，进入命令行，protoc即protoc可执行二进制文件，指定$SRC_DIR：源目录 (一般情况下即你的应用程序所在目录 – 如果不提供的话，则默认为当前工作目录即当前命令行的目录)；$DST_DIR：目标目录(你所期望生成的代码存放的目录; 通常情况下与源目录一致)；$SRC_DIR/addressbook.proto：即.proto文件的路径. </p>
<p>因为这里是生成java类, 因此使用 –java_out 选项 ， 类似的选项可以用于其它支持的语言.<br>对于addressbook.proto示例，这会在目标目录下生成 com/example/tutorial/AddressBookProtos.java文件.可以查看该文件，与普通的javaBean相似，包含了很多setters/getters方法，另外有一个builder方法，用于方便构造类对象。</p>
<h2 id="4-Protobuf-Runtime-Installation-生成Protocol-Buffer-API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中"><a href="#4-Protobuf-Runtime-Installation-生成Protocol-Buffer-API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中" class="headerlink" title="4. Protobuf Runtime Installation(生成Protocol Buffer API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中)"></a>4. <strong>Protobuf Runtime Installation(生成Protocol Buffer API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中)</strong></h2><p>对于java语言而言，就是生成一个Protocol Buffer API的jar包，应用里面导入该jar包即可，其他语言类似。那么如何生成这个API库呢？</p>
<p>官方说明可以参见<a href="https://github.com/google/protobuf/tree/master/java" target="_blank" rel="external">Protobuf Runtime Installation</a></p>
<p>这里简化说明(建议使用maven来完成安装)：</p>
<h3 id="4-1-安装maven-注意需要安装JDK1-7及其以上版本"><a href="#4-1-安装maven-注意需要安装JDK1-7及其以上版本" class="headerlink" title="4.1 安装maven(注意需要安装JDK1.7及其以上版本)"></a>4.1 安装maven(注意需要安装JDK1.7及其以上版本)</h3><p>maven下载地址(目前最新版本3.3.9)，<a href="http://maven.apache.org/" title="maven下载地址" target="_blank" rel="external">http://maven.apache.org/</a>。下载之后解压，然后将解压后得到的目录路径添加到系统path中，这样使得可以直接在命令行使用mvn命令。</p>
<h3 id="4-2-下载protocol-buffer源码包"><a href="#4-2-下载protocol-buffer源码包" class="headerlink" title="4.2 下载protocol buffer源码包"></a>4.2 下载protocol buffer源码包</h3><p><a href="https://github.com/google/protobuf/releases" title="下载protocol buffer源码包" target="_blank" rel="external">protocol buffer源码包</a>。注意：这里下载的版本必须与步骤2中protoc可执行二进制文件的版本一致，要查看protoc可执行二进制文件的版本，可以在命令行输入protoc –version。下载之后，解压，找到对应语言目录(java)，如下图：</p>
<p><img src="http://i.imgur.com/hqbfZFn.png" alt=""></p>
<p>从命令行进入java目录。</p>
<p><strong>注意1：</strong>步骤2下载二进制可执行文件之后需要将二进制可执行文件改名为protoc.exe(Windows平台)，并且放置在如下目录(下载的protocol buffer源码包解压目录下的src子目录下)：</p>
<p><img src="http://i.imgur.com/4Qdnw7s.png" alt=""></p>
<p><strong>注意2：</strong>需要将java目录下的pom.xml(即maven执行所依据的文件，类似于ant构建时候的build.xml)中添加编码格式，否则构建会采用操作系统默认的编码，Windows平台中文的话是GBK，而我们在Android平台采用的是UTF_8。添加部分代码如下：</p>
<pre><code>&lt;!-- pom.xml --&gt;
&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
&lt;/properties&gt;
</code></pre><p><img src="http://i.imgur.com/q5WtQgd.png" alt=""></p>
<h3 id="4-3-Run-the-tests-先测试运行，看看是否配置ok"><a href="#4-3-Run-the-tests-先测试运行，看看是否配置ok" class="headerlink" title="4.3 Run the tests(先测试运行，看看是否配置ok)"></a>4.3 Run the tests(先测试运行，看看是否配置ok)</h3><p>在命令输入：</p>
<pre><code>mvn test
</code></pre><p>确保成功再进行下一步。</p>
<h3 id="4-4-生成jar包"><a href="#4-4-生成jar包" class="headerlink" title="4.4 生成jar包"></a>4.4 生成jar包</h3><p>在命令输入：</p>
<pre><code>mvn package
</code></pre><p>生成的jar包放置在java目录的子目录target下面。</p>
<p><img src="http://i.imgur.com/dLL5Os3.png" alt=""></p>
<h2 id="5-Parsing-and-Serialization-解析和序列化"><a href="#5-Parsing-and-Serialization-解析和序列化" class="headerlink" title="5. Parsing and Serialization(解析和序列化)"></a>5. <strong>Parsing and Serialization(解析和序列化)</strong></h2><p>这一步也就是最终我们在应用程序里面对数据进行解析读写等直观的操作，也是我们最关心的部分。</p>
<p>将步骤3生成的java类复制进工程中(注意必须在其定义的包名结构下)，同时将步骤4生成的jar导入到工程中。</p>
<p>对于步骤3生成的类，利用 protocol buffer的二进制格式，每个类均具有所选择类型的写和读消息功能。即可以进行解析和序列化操作。这里列举几个：</p>
<pre><code>byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes.

static Type(定义的类，比如步骤1中的Person) parseFrom(byte[] data);: parses a message from the given byte array.

void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream.

static Type(定义的类，比如步骤1中的Person) parseFrom(InputStream input);: reads and parses a message from an InputStream.
</code></pre><p>事实上，每个类包含有大量的解析和序列化的方法。 请参照<a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message" target="_blank" rel="external"> Message API reference</a>进行详细查阅。</p>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Protocol-Buffers/">Protocol Buffers</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Github pages+Hexo+Nodejs搭建个人blog" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/16/Github pages+Hexo+Nodejs搭建个人blog/">Github pages+Hexo+Nodejs搭建个人blog</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-06-16T10:35:07.000Z" itemprop="datePublished" class="post-time">
  2016-06-16
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/杂项/">杂项</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个IT技术人员，自然离不开技术的积累，而技术的积累则通过文档或代码的形式呈现出来。好记性不如烂笔头，程序员应该乐于并擅于记录总结工作中遇到的各种问题、工作成果、奇思异想和感悟等。</p>
<p>程序员的世界是孤独的，但也是充满激情和阳光的。正是开源精神点亮了这一切。生命中最美丽的报偿之一便是帮助他人的同时，也帮助了自己 ─ 罗夫‧瓦尔多‧爱默生 </p>
<p>因此，将个人的经验和感悟与他人分享，成就的不仅仅是个人，更可以帮助其他人少走弯路。那么就开始分享的旅程吧！</p>
<h1 id="传统的笔记或者blog平台"><a href="#传统的笔记或者blog平台" class="headerlink" title="传统的笔记或者blog平台"></a>传统的笔记或者blog平台</h1><p>在本地可以用各种文档格式保存自己的技术积累，也可以采用一些市面上的blog平台作为载体来存储自己的技术文章，但这类方式存在一些弊端，这点你可以打开你的脑洞，想想有哪些，本人不是来挑起舌战的。</p>
<h1 id="Github-pages-Hexo-Nodejs搭建个人blog"><a href="#Github-pages-Hexo-Nodejs搭建个人blog" class="headerlink" title="Github pages+Hexo+Nodejs搭建个人blog"></a>Github pages+Hexo+Nodejs搭建个人blog</h1><p>好处和缺点这里就暂不提了，请自行google。(本文仅仅是提供一种搭建Blog的方式，不牵涉任何利益方！！！)</p>
<p>步骤如下：</p>
<ol>
<li>安装git：<a href="https://git-scm.com" title="git下载" target="_blank" rel="external">git下载</a>，注意：Windows平台需要下载对应的安装exe,安装之后后续的命令行操作需要在GitShell中打开而非Windows默认的命令行。不过，建议直接下载<a href="https://desktop.github.com/" title="Github桌面版" target="_blank" rel="external">Github windows客户端</a>，安装的时候会创建GitShell(正是下文提及的GitShell)和GitHub GUI工具。</li>
<li>安装nodejs：<a href="https://nodejs.org" title="nodejs官网" target="_blank" rel="external">node.js官网</a>，注意：请根据自己主机的平台下载对应版本。</li>
<li>安装hexo及部署：<a href="https://hexo.io/" title="hexo官网" target="_blank" rel="external">hexo官网</a>，注意：安装 Hexo 相当简单。然而在安装前，您必须确保先完成步骤1和2。Hexo网站可以选择语言为简体中文，方便使用。查看其中的文档可以看到hexo的详细使用说明，so easy！</li>
</ol>
<p>重点阐述下步骤3的过程(hexo的详细信息可参加<a href="https://hexo.io/zh-cn/docs/index.html" title="hexo说明文档" target="_blank" rel="external">hexo说明文档</a>)：</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在Gitshell(已经安装了git并且将git加入到path环境变量中)输入：</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹(自行选定的文件夹folder)中新建所需要的文件。</p>
<blockquote>
<p>$ hexo init folder<br>$ cd folder<br>$ npm install</p>
</blockquote>
<p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><p><strong>_config.yml</strong><br>网站的 配置 信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong><br>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line"> "name": "hexo-site",</span><br><span class="line"> "version": "0.0.0",</span><br><span class="line"> "private": true,</span><br><span class="line"> "hexo": &#123;</span><br><span class="line">	"version": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">	"hexo": "^3.0.0",</span><br><span class="line">	"hexo-generator-archive": "^0.1.0",</span><br><span class="line">	"hexo-generator-category": "^0.1.0",</span><br><span class="line">	"hexo-generator-index": "^0.1.0",</span><br><span class="line">	"hexo-generator-tag": "^0.1.0",</span><br><span class="line">	"hexo-renderer-ejs": "^0.1.0",</span><br><span class="line">	"hexo-renderer-stylus": "^0.2.0",</span><br><span class="line">	"hexo-renderer-marked": "^0.2.4",</span><br><span class="line">	"hexo-server": "^0.1.2"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>scaffolds</strong><br>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p><strong>source</strong><br>资源文件夹是存放用户资源的地方。除 <em>posts 文件夹之外，开头命名为 </em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong><br><a href="https://hexo.io/docs/themes.html" title="hexo主题" target="_blank" rel="external">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="本地启动server"><a href="#本地启动server" class="headerlink" title="本地启动server"></a>本地启动server</h2><p>该步骤可以检验安装是否ok。如果能成功，那么恭喜你离成功更近一步了。</p>
<p>在Gitshell中进入前面指定的folder(建立的站点的根目录)，输入：</p>
<blockquote>
<p>$ hexo server</p>
</blockquote>
<p>可以观察命令行的输出，然后通过浏览器打开<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>，成功的情况下则会看到默认的欢迎页面。</p>
<h2 id="部署到github-pages"><a href="#部署到github-pages" class="headerlink" title="部署到github pages"></a>部署到github pages</h2><p>(<a href="https://help.github.com/categories/github-pages-basics/" title="github pages介绍" target="_blank" rel="external">点击了解Github Pages</a>)</p>
<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p>
<blockquote>
<p>$ hexo deploy</p>
</blockquote>
<p>在开始之前，您必须先在站点的配置文件_config.yml(前面建立的folder目录下)中修改参数，一个正确的部署配置中至少要有 type 参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br></pre></td></tr></table></figure>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">  	repo:</span><br><span class="line">	type: heroku</span><br><span class="line">	repo:</span><br></pre></td></tr></table></figure>
<p>这里重点提及部署到Github pages的方法(步骤)。</p>
<p><strong>a.首先在Github上面创建一个新的Repository，仓库命名格式为yourname.github.io，注意：yourname是你自己定义的一个名称，后面的github.io是统一的，格式一定需要符合这个样式。</strong><br><strong>b.然后，配置文件_config.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:your_github_account/yourname.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>repo</td>
<td>库（Repository）地址</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息</td>
</tr>
</tbody>
</table>
<p>eg(我的Github账号是cstsinghua，而我新建的仓库名称是cstsinghua.github.io):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:cstsinghua/cstsinghua.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>注意：如果是建立项目网站，则branch需要修改为gh-pages，详细情况请参见<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="external">Github pages中User, Organization, and Project Pages的差异</a></p>
<p><strong>c.安装hexo的git插件<a href="https://github.com/hexojs/hexo-deployer-git" title="hexo的git插件" target="_blank" rel="external">hexo-deployer-git</a></strong></p>
<blockquote>
<p>$ npm install hexo-deployer-git –save</p>
</blockquote>
<p><strong>d.部署前面建立的站点(folder下面的内容)：</strong></p>
<p>执行完，开始部署，即先hexo generate，然后hexo deploy。也可以一步到位：hexo d -g</p>
<blockquote>
<p>  $ hexo clean<br>    $ hexo generate<br>    $ hexo deploy</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>$ hexo d -g</p>
</blockquote>
<p>注意：在这一步可能报错，已知的一些错误可以参见<a href="https://hexo.io/zh-cn/docs/troubleshooting.html#Git-部署问题" target="_blank" rel="external">hexo git部署常见问题</a></p>
<p>另外，可能遇到SSH publickey接入问题，可以参见<a href="https://help.github.com/articles/generating-an-ssh-key/" title="创建github ssh key" target="_blank" rel="external">创建github SSH key</a>和<a href="https://github.com/settings/keys" title="github SSH key管理" target="_blank" rel="external">github SSH key管理</a></p>
<h2 id="optional-重绑定域名"><a href="#optional-重绑定域名" class="headerlink" title="(optional)重绑定域名"></a>(optional)重绑定域名</h2><p>Custom domain redirects for GitHub Pages sites(将独立(个性)域名与GitHub Pages的空间域名绑定)</p>
<p>yourname.github.io的域名格式比较固定，那么是否可以设置一个个性化的域名呢，另外需要注意的是Github pages的容量受限于github的要求，目前是1GB(请参见<a href="https://help.github.com/articles/what-are-github-pages/" target="_blank" rel="external">https://help.github.com/articles/what-are-github-pages/</a>)。因此，建立一个独立的个性化(blog)网站(域名是个性化独立的，容量也可以调整)，在某些情况下还是有必要的(请参见<a href="https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/" title="github pages域名重定向" target="_blank" rel="external">github pages域名重定向</a>)。</p>
<ul>
<li><p>Github pages 设置：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如cstsinghua.me。</p>
</li>
<li><p>DNS设置：注册DNSpod，添加域名，不是必要的步骤，但是据说可以提高解析效率。本人没有测试。</p>
</li>
<li><p>在域名服务商，如net.cn中修改增加两条A记录，指向github pages 提供的 ip<br>  192.30.252.153<br>  192.30.252.154</p>
</li>
</ul>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>一旦成功创建属于自己的blog，当然是想与他人分享，让小伙伴们都可以搜索到或者浏览自己的成果。很不幸的是，采用本文方式创建的blog默认情况下只会静静躺在互联网的一个角落，google或者百度等搜索引擎是无法知晓它的存在。因此，我们必须采用一些方式来推广自己的blog，让其他人能够通过Google或者百度等搜索引擎搜索到我们blog。</p>
<ul>
<li><p>先验证博客是否被搜索引擎收录</p>
<p>  在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的cstsinghua.github.io</p>
<blockquote>
<p>site:cstsinghua.github.io</p>
</blockquote>
<p>  如下图：<br>  <img src="http://i.imgur.com/gVZSKWY.png" alt=""></p>
<p>  如果已被搜索引擎收录，那恭喜你，可以不用看后面的内容了。你的blog已经在互联网上飘香四溢。</p>
</li>
<li><p>在google和百度的站长管理平台验证并添加blog地址</p>
<p>  <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google站长管理平台地址</a></p>
<p>  <a href="http://zhanzhang.baidu.com/linksubmit/url" target="_blank" rel="external">百度站长管理平台地址</a></p>
<p>  这里以Google为例(百度的类似)：</p>
<p>  <strong>1.</strong>登录google站长管理平台，在首页中点击”添加属性”按钮，然后将你的blog地址填写并添加，如下图所示：<br>  <img src="http://i.imgur.com/7Xp2CIP.png" alt=""><br>  <strong>2.</strong>blog网址添加完成之后，会跳转到验证所有权页面，验证方式有很多种，可以根据自己的情况选择，这里选择推荐的方法，即上传HTML文件的方式，其步骤在跳转的页面写得很清楚，按部就班地操作就行了(<strong>注意：先点击下载页面提示的HTML文件，报错</strong>)。如下图所示：<br>  <img src="http://i.imgur.com/tz37dOJ.png" alt=""></p>
<p>  <img src="http://i.imgur.com/UvrvykY.png" alt=""></p>
<p>  <strong>3.</strong>生成并提交站点地图(sitemap.xml)<br>  站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p>
<p>  怎么生成blog网站的站点地图呢？方式有很多种，hexo本身也自带了生成站点地图的插件。我们要先安装插件，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件：</p>
<blockquote>
<p>npm install hexo-generator-sitemap –save</p>
<p>npm install hexo-generator-baidu-sitemap –save</p>
</blockquote>
<p>  在blog根目录的配置文件_config.yml中添加如下代码</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>  然后，修改blog根目录的配置文件_config.yml中url参数为你blog的地址，比如我的是这样：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="line">url: https://cstsinghua.github.io/</span><br></pre></td></tr></table></figure>
<p>  此时，可以重新生成你的blog</p>
<blockquote>
<p>hexo g</p>
</blockquote>
<p>  如果你在你的blog根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了。当然可以采用其他很多方式来生成sitemap.xml，网上也有很多在线工具或者提供下载的本地GUI工具来生成，可以参见<a href="https://code.google.com/archive/p/sitemap-generators/wikis/SitemapGenerators.wiki" target="_blank" rel="external">https://code.google.com/archive/p/sitemap-generators/wikis/SitemapGenerators.wiki</a>，里面提供了非常多的链接地址，本人使用过<a href="https://xmlsitemapgenerator.org" target="_blank" rel="external">https://xmlsitemapgenerator.org</a>在线生成过。</p>
<p>  最后，将生成的sitemap.xml提交到google站长管理平台，如下图所示：<br>  <img src="http://i.imgur.com/T0ur897.png" alt=""></p>
<p>  蓝色表示sitem.xml里面上传的网页数，橙色表示已经被google加入索引(收录)的网页数，一旦被收录，这个时候就可以在google上面搜索到blog了！关于细节可以点击google站长页面上的帮助进行了解。</p>
</li>
</ul>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搭建个人Blog/">搭建个人Blog</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-ZXing开源项目实战" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/ZXing开源项目实战/">Zxing二维码开源库实战</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-06-13T07:42:25.000Z" itemprop="datePublished" class="post-time">
  2016-06-13
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Zxing二维码开源库学习和优化"><a href="#Zxing二维码开源库学习和优化" class="headerlink" title="Zxing二维码开源库学习和优化"></a>Zxing二维码开源库学习和优化</h1><p>  本文对Google官方开源的二维码扫描库ZXing做一个总体概述，然后进行Android开发环境下的实战(二次)开发和优化，并用于生产项目。<br>  ZXing开源项目官方地址:<a href="https://github.com/zxing/zxing" title="ZXing" target="_blank" rel="external">https://github.com/zxing/zxing</a></p>
<hr>
<h2 id="前期学习和准备"><a href="#前期学习和准备" class="headerlink" title="前期学习和准备"></a>前期学习和准备</h2><p> 各种百度和google，先了解二维码的技术概念和原理，他人经验和文章等等。以下摘自百度百科：</p>
<p> 国外对二维码技术的研究始于20世纪80年代末，在二维码符号表示技术研究方面已研制出多种码制，常见的有PDF417、QR Code、Code 49、Code 16K、Code One等。这些二维码的信息密度都比传统的一维码有了较大提高，如PDF417的信息密度是一维码CodeC39的20多倍。在二维码标准化研究方面，国际自动识别制造商协会（AIM）、美国标准化协会（ANSI）已完成了PDF417、QR Code、Code 49、Code 16K、Code One等码制的符号标准。国际标准技术委员会和国际电工委员会还成立了条码自动识别技术委员会（ISO/IEC/JTC1/SC31），已制定了QR Code的国际标准（ISO/IEC 18004：2000《自动识别与数据采集技术—条码符号技术规范—QR码》），起草了PDF417、Code 16K、Data Matrix、Maxi Code等二维码的ISO/IEC标准草案。在二维码设备开发研制、生产方面，美国、日本等国的设备制造商生产的识读设备、符号生成设备，已广泛应用于各类二维码应用系统。二维码作为一种全新的信息存储、传递和识别技术，自诞生之日起就得到了世界上许多国家的关注。美国、德国、日本等国家，不仅已将二维码技术应用于公安、外交、军事等部门对各类证件的管理，而且也将二维码应用于海关、税务等部门对各类报表和票据的管理，商业、交通运输等部门对商品及货物运输的管理、邮政部门对邮政包裹的管理、工业生产领域对工业生产线的自动化管理。</p>
<p> 我国对二维码技术的研究开始于1993年。中国物品编码中心对几种常用的二维码PDF417、QRCCode、Data Matrix、Maxi Code、Code 49、Code 16K、Code One的技术规范进行了翻译和跟踪研究。随着我国市场经济的不断完善和信息技术的迅速发展，国内对二维码这一新技术的需求与日俱增。中国物品编码中心在原国家质量技术监督局和国家有关部门的大力支持下，对二维码技术的研究不断深入。在消化国外相关技术资料的基础上，制定了两个二维码的国家标准：二维码网格矩阵码（SJ/T 11349-2006）和二维码紧密矩阵码（SJ/T 11350-2006），从而大大促进了我国具有自主知识产权技术的二维码的研发。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-下载ZXing并选择包"><a href="#1-下载ZXing并选择包" class="headerlink" title="1. 下载ZXing并选择包"></a>1. 下载ZXing并选择包</h3><blockquote>
<p>截止本文攥写之时，ZXing的最新版本为3.2.1，在Github网站上下载ZXing的主分支（zxing-master.zip），解压完成之后，目录树如下：<br><img src="http://172.20.154.39:8080/GodSDKBackground/ZXing-dirTree.png" alt="ZXing项目解压的目录层次"></p>
<p>以下对解压的目录结构(包含模块)的主要部分做一个概述(此处以3.2.1版本基准，不同的版本包含的模块可能稍有差异，请留意)：</p>
</blockquote>
<ul>
<li><p><strong>android</strong></p>
<p>  Android client Barcode Scanner,中文意为“条形扫码器”，下文简称BS。可作为独立的扫码APP使用。</p>
</li>
<li><p><strong>android-core</strong></p>
<p>   Android-related code shared among android, androidtest, glass，即android、androidtest和glass三个模块共享的android相关库，当前其实就是一个相机配置工具类(CameraConfigurationUtils.java).</p>
</li>
<li><p><strong>android-integration</strong></p>
<p>   Supports integration with Barcode Scanner via Intent，即通过Intent的方式提供一种便捷的途径将BS整合到用户的APP中。</p>
</li>
<li><p><strong>androidtest</strong></p>
<p>  Android test app, ZXing Test，即模拟调用方app(相当于用户APP的角色)，通过android-integration整合Barcode Scanner</p>
</li>
<li><p><strong>core</strong></p>
<p>  The core image decoding library, and test code.即核心的图片编解码库，整个条形码的核心处理库，另外还包括测试代码。</p>
</li>
<li><p>glass    </p>
<p>  Simple Google Glass application</p>
</li>
<li><p>zxingorg</p>
<p>  The source behind zxing.org</p>
</li>
<li><p>zxing.appspot.com</p>
<p>  The source behind web-based barcode generator at zxing.appspot.com</p>
</li>
<li><p>javase</p>
<p>  JavaSE-specific client code</p>
</li>
</ul>
<p>其中，与开发Android二维码扫码相关的模块有android、android-core、android-integration、androidtest和core模块。</p>
<p>androidtest、android-integration、android三个模块的关系图如下：</p>
<p><img src="http://172.20.154.39:8080/GodSDKBackground/Barcode_module_relationship.png" alt="模块关系图"></p>
<h3 id="2-试用并厘清ZXing项目的源码"><a href="#2-试用并厘清ZXing项目的源码" class="headerlink" title="2.试用并厘清ZXing项目的源码"></a>2.试用并厘清ZXing项目的源码</h3><ul>
<li><p>试用：</p>
<p>  用Eclipse导入(按照导入现有Android工程的方式)上面所述的androidtest模块，导入之后，源代码部分会报错。主要有以下两种错误：</p>
<ul>
<li><p>由于ZXing项目编写者采用的java编译版本不低于1.7.0，因此如果你的Eclipse的java编译版本设置为1.6.0或者更低版本时，将会报错，比如new ArrayList&lt;&gt;(),在1.6.0版本则不能省略具体的泛型类型，应该为new ArrayList<yourclass>()；</yourclass></p>
</li>
<li><p>引用了大量core模块、android-integration和android-core的类，因此需要将core模块的jar包(当然也可以直接copy源码)添加到工程的构建路径(core包的下载地址:<a href="http://repo1.maven.org/maven2/com/google/zxing/core/" title="ZXing的core包" target="_blank" rel="external">http://repo1.maven.org/maven2/com/google/zxing/core/</a>)，另外需要将android-integration和android-core的源码复制到工程中(新建对应的package，copy类)；</p>
<p>按照上面步骤处理完之后，则可以运行的测试APP诞生了。工程目录图如下：<br><img src="http://172.20.154.39:8080/GodSDKBackground/barcode_test_project.png" alt="ZXing试用工程目录"></p>
<p>运行并安装APK至手机或模拟器，测试APP界面如下图：</p>
<p><img src="http://172.20.154.39:8080/GodSDKBackground/barcode_test_app.png" alt="ZXing试用工程目录">    </p>
<p>可以体验扫码和生成二维码的功能。</p>
</li>
</ul>
</li>
<li><p>源码分析</p>
<p>  其实这里要关注的源码主要有四部分：core、android、android-integration和android-core，其中android-integration和android-core较为简单，这里不再赘述。而core涉及图片处理和二维码的理论技术，暂不做深入研究。</p>
<p>  android模块即BS，可以作为单独APP使用，是一个功能强大的条码扫描器，不仅支持多种类型的条码，还支持多国语言，分享二维码，查看扫描历史，反向扫描等功能。</p>
<p>  因此，这里主要就android模块进行分析阐述。导入Eclipse之后，android模块的包结构图如下：</p>
<p>  <img src="http://172.20.154.39:8080/GodSDKBackground/barcode_BS_Hierarchy.png" alt="BS包结构"></p>
<p>  如上图所示，BS主要包括下列组件：</p>
<ul>
<li><p>android：与CaptureActivity直接相关的核心组件。包含了发生震动管理器，闪光灯等等。</p>
</li>
<li><p>book：如果查询的结果是图书信息，用户可以选择查询该书的更进一步的详细信息，该包即包含了搜索与展示书籍的相关类。</p>
</li>
<li><p>camera/camera.open：摄像头相关组件，核心类是CameraManager</p>
</li>
<li><p>clipboard：剪贴板</p>
</li>
<li><p>encode：编码功能的各个组件集合。核心类为QRCodeEncoder，最终实施编码的是MultiFormatWriter类</p>
</li>
<li><p>history：扫描历史管理，核心类是HistoryManager</p>
</li>
<li><p>result：条码扫描的结果被分为不同的类型，所有的类型都定义在com.google.zxing.client.result.ParsedResultType中，对于不同的类型都有对应的处理方法：xxxResultHandler，所有的ResultHandler都包含在此包中。不同的xxxResultHandler还提供了扫描结果页面要展示几个button，每个button的文本以及需要绑定的事件等等。</p>
</li>
<li><p>result.supplement：对已经扫描并解码的结果做额外处理的工具集。比如扫描出来的是isbn号，如果在设置中选择了“检索更多信息”则会在扫描出isbn号之后自动去网上查询该书的信息，最后将书的信息展示出来，而如果没选中，则只会将isbn号码展示。</p>
</li>
<li><p>share：分享二维码功能，亦是编码功能的入口所在。</p>
</li>
<li><p>wifi：是WifiResultHandler的辅助类集合。如果扫描到的二维码是对wifi信息的编码，那么最终扫描结果页会展示一个“连接到网络”的按钮，点击此按钮就会自动尝试连接。该包中所包含的类则是链接网络所需的工具类。</p>
<p>打开BS，即进入扫描界面时，BS大致做了如下的事情：配置Camera并启动Camera、构建preview与扫描窗口、捕捉画面并解码、将解码结果交给不同ResultHandler去处理。下面逐一进行分析。</p>
</li>
</ul>
<ol>
<li><p>配置Camera并启动Camera</p>
<p> 启动Camera是在CaptureActivity.initCamera中进行的，最重要的几句代码是：</p>
<pre><code>cameraManager.openDriver(surfaceHolder);
// Creating the handler starts the preview, which can also throw a
// RuntimeException.
if (handler == null) {
    handler = new CaptureActivityHandler(this, decodeFormats,
            decodeHints, characterSet, cameraManager);
}
</code></pre><p> CameraManager是相机管理类，是BS中唯一与Camera打交道的类，CameraManager.openDriver主要做了三件事：</p>
<pre><code>/**
 * Opens the camera driver and initializes the hardware parameters.
 * 
 * @param holder
 *            The surface object which the camera will draw preview frames
 *            into.
 * @throws IOException
 *             Indicates the camera driver failed to open.
 */
public synchronized void openDriver(SurfaceHolder holder)
        throws IOException {
    Camera theCamera = camera;
    if (theCamera == null) {
        // 1. 获取手机背面的摄像头
        theCamera = OpenCameraInterface.open(requestedCameraId);
        if (theCamera == null) {
            throw new IOException();
        }
        camera = theCamera;
    }
    // 2. 设置摄像头预览view
    theCamera.setPreviewDisplay(holder);

    if (!initialized) {
        initialized = true;
        configManager.initFromCameraParameters(theCamera);
        if (requestedFramingRectWidth &gt; 0 &amp;&amp; requestedFramingRectHeight &gt; 0) {
            setManualFramingRect(requestedFramingRectWidth,
                    requestedFramingRectHeight);
            requestedFramingRectWidth = 0;
            requestedFramingRectHeight = 0;
        }
    }

    Camera.Parameters parameters = theCamera.getParameters();
    String parametersFlattened = parameters == null ? null : parameters
            .flatten(); // Save these, temporarily
    try {
        // 3. 读取配置并设置相机参数
        configManager.setDesiredCameraParameters(theCamera, false);
    } catch (RuntimeException re) {
        // Driver failed
        Log.w(TAG,
                &quot;Camera rejected parameters. Setting only minimal safe-mode parameters&quot;);
        Log.i(TAG, &quot;Resetting to saved camera params: &quot;
                + parametersFlattened);
        // Reset:
        if (parametersFlattened != null) {
            parameters = theCamera.getParameters();
            parameters.unflatten(parametersFlattened);
            try {
                theCamera.setParameters(parameters);
                configManager.setDesiredCameraParameters(theCamera, true);
            } catch (RuntimeException re2) {
                // Well, darn. Give up
                Log.w(TAG,
                        &quot;Camera rejected even safe-mode parameters! No configuration&quot;);
            }
        }
    }

}
</code></pre><p> CameraConfigurationManager是相机辅助类，主要用于设置相机的各类参数。核心方法有两个：</p>
<ul>
<li><p>initFromCameraParameters：计算了屏幕分辨率和当前最适合的相机像素</p>
</li>
<li><p>setDesiredCameraParameters：读取配置设置相机的对焦模式、闪光灯模式等等</p>
<p>CaptureActivityHandler类是一个针对扫描任务的Handler，可接收的message有启动扫描（restart_preview）、扫描成功（decode_succeeded）、扫描失败（decode_failed）等等。</p>
<p>在创建一个CaptureActivityHandler对象的时候也做了三件事：</p>
<p>  CaptureActivityHandler(CaptureActivity activity,</p>
<pre><code>           Collection&lt;BarcodeFormat&gt; decodeFormats,
           Map&lt;DecodeHintType,?&gt; baseHints,
           String characterSet,
           CameraManager cameraManager) {
  this.activity = activity;
  // 1. 启动扫描线程
  decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
      new ViewfinderResultPointCallback(activity.getViewfinderView()));
  decodeThread.start();
  state = State.SUCCESS;

  // Start ourselves capturing previews and decoding.
  this.cameraManager = cameraManager;
  // 2. 开启相机预览界面
  cameraManager.startPreview();
  // 3. 将preview回调函数与decodeHandler绑定、调用viewfinderView
  restartPreviewAndDecode();
}
</code></pre><p>restartPreviewAndDecode方法又调用了CameraManager.requestPreviewFrame：</p>
<p>  /**</p>
<ul>
<li>A single preview frame will be returned to the handler supplied. The data</li>
<li>will arrive as byte[] in the message.obj field, with width and height</li>
<li><p>encoded as message.arg1 and message.arg2, respectively.</p>
</li>
<li><p>1：将handler与preview回调函数绑定；<br></p>
</li>
<li>2：注册preview回调函数<br></li>
<li>综上，该函数的作用是当相机的预览界面准备就绪后就会调用hander向其发送传入的message</li>
<li>@param handler</li>
<li>The handler to send the message to.</li>
<li>@param message</li>
<li>The what field of the message to be sent.<br>*/<br>public synchronized void requestPreviewFrame(Handler handler, int message) {<br>Camera theCamera = camera;<br>if (theCamera != null &amp;&amp; previewing) {<br>previewCallback.setHandler(handler, message);<br>/ 绑定相机回调函数，当预览界面准备就绪后会回调Camera.PreviewCallback.onPreviewFrame<br>theCamera.setOneShotPreviewCallback(previewCallback);<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>2. 构建preview与扫描窗口

    首先相机有自己的preview界面，然后我们需要构造一个扫描窗口，引导用户将条码置于窗口中完成扫描。

    构造扫描窗口是在CaptureActivityHandler.restartPreviewAndDecode中，通过调用activity.drawViewfinder()来实现的。这里有个画扫描窗口的类叫ViewfinderView，该类也是想要改变扫描窗口风格所必须重构的一个类。

    重构ViewfinderView涉及Android的高级话题：自定义View及其属性，这里暂不赘述。

    相机的preview界面显示出来后即可开始扫描，所以需要监听preview是否已经显示这个事件，这就是Camera.PreviewCallback的作用。PreviewCallback.onPreviewFrame做的事便是当preview界面展示出来的时候向DecodeHandler发送一个decode消息，DecodeHandler收到该消息后会执行decode方法来解码。

    注意，检测并触发捕获画面动作的，是Camera.setOneShotPreviewCallback()这个方法。该函数被调用后，如果预览界面已经打开，就会将包含当前preview frame的byte数组传给回调函数，此时再向DecodeHandler发送decode消息。

3. 捕捉画面并解码

    具体参考DecodeHandler.decode方法。（本文只从宏观上对zxing进行分析，对于解码的原理暂不做介绍）

4. 将解码结果交给不同ResultHandler去处理

    当DecodeHandler.decode完成解码后会向CaptureActivityHandler发消息。如果编码成功则调用CaptureActivity.handleDecode方法对扫描到的结果进行分类处理。

    该方法中首先获取ResultHandler：

        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(
                this, rawResult);
    然后调用handleDecodeInternally和handleDecodeExternally对ResultHandler进行处理。谈到这两个方法，就不得不再分析一下    IntentSource。

        enum IntentSource {

          /**
           * 本地app向BS(Barcode Scanner)发起的启动指令
           * 比如在androidtest项目中，利用整合的android-integration对BS发起调用指令：com.google.zxing.client.android.SCAN
           * BS中该启动命令对应的Source类型便是NATIVE_APP_INTENT
           */
            NATIVE_APP_INTENT,

          /**
           * 打开BS的时候传入查询商品的url，与最终扫描到的product id结合进行查询
           * 两种url的形式不同
           */
          PRODUCT_SEARCH_LINK,
          ZXING_LINK,

          /**
           * 直接打开BS
           */
          NONE

        }

    结合CaptureActivity.onResume中的部分代码来理解：

        else if (dataString != null
                    &amp;&amp; dataString.contains(&quot;http://www.google&quot;)
                    &amp;&amp; dataString.contains(&quot;/m/products/scan&quot;)) {

                // Scan only products and send the result to mobile Product
                // Search.
                source = IntentSource.PRODUCT_SEARCH_LINK;
                sourceUrl = dataString;
                decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;

        } else if (isZXingURL(dataString)) {

            // Scan formats requested in query string (all formats if none
            // specified).
            // If a return URL is specified, send the results there.
            // Otherwise, handle it ourselves.
            source = IntentSource.ZXING_LINK;
            sourceUrl = dataString;
            Uri inputUri = Uri.parse(dataString);
            scanFromWebPageManager = new ScanFromWebPageManager(inputUri);
            decodeFormats = DecodeFormatManager
                    .parseDecodeFormats(inputUri);
            // Allow a sub-set of the hints to be specified by the caller.
            decodeHints = DecodeHintManager.parseDecodeHints(inputUri);

        }

    NATIVE_APP_INTENT和NONE很好理解，而PRODUCT_SEARCH_LINK和ZXING_LINK是指定查询商品的url（而不是交给zxing分析后再决定去哪里查询），将扫描出来的内容拼凑到url中，然后在浏览器中展示结果。

    理解了IntentSource，就容易看懂handleDecodeInternally其实就是将结果展示到界面上。handleDecodeExternally稍复杂些，当source == IntentSource.NATIVE_APP_INTENT时，BS会将扫描分析的结果存到Intent中返回给调用方app，因此调用方app在启动BS的时候一定要使用startActivityForResult。这一点可以在androidtest的IntentIntegrator.initiateScan方法的最后看到。
</code></pre><h3 id="3-BS优化"><a href="#3-BS优化" class="headerlink" title="3.BS优化"></a>3.BS优化</h3><p>BS可直接作为独立APP运行，但是项目中的很多功能我们并不需要，而且扫描的界面为横向，因此进行相关优化。接下来，我们在BS项目工程基础上，直接修改其中代码或者xml文件，达到修改扫码界面为竖屏且美化扫码界面的目的。</p>
<ol>
<li><p>修改BS默认的横屏为竖屏</p>
<p>针对ZXing3.2.1版本，这里一共需要6步，需要提醒的是：不同的ZXing版本需要的步骤可能有差异，因为里面的源代码逻辑有修改。因此，有的时候尽信书不如无书，本文的步骤可能仅适合ZXing3.2.1，如果在ZXing其他版本上完成以下六步无法实现竖屏，或者修改之后会出错，请仔细排查(可以断点调试跟踪)。其实，要实现竖屏，从原理上应该是共通的，主要包括Activity本身的方向(属性)设置，同时关联到相机的参数(如预览窗口)调整等方面。</p>
<ul>
<li><p>第一步：调整CaptureActivity的方向为竖屏显示</p>
<p>   修改工程的AndroidManifest.xml,CaptureActivity的android:screenOrientation属性，设置为portrait</p>
   <!-- 调整扫描activity为竖屏,step1.调整activity的方向为竖屏 -->
   <activity android:name=".CaptureActivity" android:cleartaskonlaunch="true" android:screenorientation="portrait" android:statenotneeded="true" android:theme="@style/CaptureTheme" android:windowsoftinputmode="stateAlwaysHidden">
</activity></li>
<li><p>第二步：调整相机预览界面方向</p>
<p>   在 CameraConfigurationManager.setDesiredCameraParameters 的最后(或第一行也可)增加如下代码：<br>   //调整扫描activity为竖屏,step2.调整相机预览界面方向<br>   camera.setDisplayOrientation(90);<br>   注意：调整相机preview的时钟方向与手机竖屏的自然方向一致。该方法必须在相机的startPreview之前被调用，</p>
<pre><code>在预览界面展示出来后设置是无效的。
</code></pre></li>
<li><p>第三步：调整扫描窗口尺寸</p>
<p>   修改 CameraManager.getFramingRectInPreview()方法中的部分代码：<br>   原代码段为：</p>
<pre><code>rect.left = rect.left * cameraResolution.x / screenResolution.x;
rect.right = rect.right * cameraResolution.x / screenResolution.x;
rect.top = rect.top * cameraResolution.y / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
framingRectInPreview = rect;
</code></pre><p>   修改后代码段为：</p>
<pre><code>/*
 * 调整扫描activity为竖屏,step3.调整扫描窗口尺寸
 * 由于修改了屏幕的初始方向，手机分辨率由原来的 width\*height 变为 height\*width
 * 形式，但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
 */
rect.left = rect.left * cameraResolution.y / screenResolution.x;
rect.right = rect.right * cameraResolution.y / screenResolution.x;
rect.top = rect.top * cameraResolution.x / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.x / screenResolution.y;
framingRectInPreview = rect;
</code></pre><p>   原因：由于修改了屏幕的初始方向，手机分辨率由原来的 width*height 变为 height*width 形式，</p>
<pre><code>但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
</code></pre></li>
<li><p>第四步：将扫描框设置为正方形</p>
<p>   修改 CameraManager.getFramingRect()方法中的部分代码：<br>   原代码段为：</p>
<pre><code>int width = findDesiredDimensionInRange(screenResolution.x,
        MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = findDesiredDimensionInRange(screenResolution.y,
        MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect);
</code></pre><p>   修改后代码段为：</p>
<pre><code>/*
  * 调整扫描activity为竖屏,step4.将扫描框设置为正方形
 */
//后面设置height = width的前提下，如x&gt;y时可能会导致topOffset为负值，因此需要对此进行修正，加入下面这行代码
int resolutionMin = Math.min(screenResolution.x, screenResolution.y);
int width = findDesiredDimensionInRange(resolutionMin,
MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = width;//宽度等于高度，即为正方形
Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect);
</code></pre></li>
<li><p>第五步：反转扫描到的图形</p>
<pre><code>修改 DecodeHandler.decode 方法，增加以下代码：
</code></pre><p>   private void decode(byte[] data, int width, int height) {</p>
<pre><code>long start = System.currentTimeMillis();
Result rawResult = null;

/*
 * 调整扫描activity为竖屏,step5.反转扫描到的图形
 */
// 新增反转数据代码开始
byte[] rotatedData = new byte[data.length];
for (int y = 0; y &lt; height; y++) {
    for (int x = 0; x &lt; width; x++)
        rotatedData[x * height + height - y - 1] = data[x + y * width];
}
int tmp = width;
width = height;
height = tmp;
// 新增代码结束

PlanarYUVLuminanceSource source = activity.getCameraManager()
        .buildLuminanceSource(rotatedData, width, height);
//...后续代码
</code></pre><p>   }</p>
</li>
<li><p>第六步：(关键)修改CaptureActivity的onresume方法</p>
<pre><code>完成以上五步后，在ZXing的某些版本上应该是可以实现竖屏了，但是在3.2.1版本上，由于在CaptureActivity
的onresume方法里面涉及到了修改activity的方向，因此需要针对性修改这部分代码。
原代码段为：
   if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
   true)) {
       setRequestedOrientation(getCurrentOrientation());
   } else {
       setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
   }
</code></pre><p>   修改后代码段为：</p>
<pre><code>if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
true)) {
    setRequestedOrientation(getCurrentOrientation());
} else {
    // setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
}
</code></pre><p>   同时，需要修改getCurrentOrientation方法：<br>   原方法为：</p>
<pre><code>private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
    default:
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
    }
}
</code></pre><p>   修改后为：</p>
<pre><code>private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        // return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
    default:
        // return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
    }
}
</code></pre></li>
</ul>
</li>
<li><p>美化扫描界面</p>
<p>原生的扫描界面比较朴素，如果需要做出更漂亮些的扫描界面，就必须重写ViewfinderView类(res/layout/capture.xml布局中使用该类作为扫描窗口界面)。这里，我们为了实现类微信或支付宝的扫描界面效果，在将扫码界面修改为竖屏的基础上，可以做如下修改：</p>
<ul>
<li><p>在ViewfinderView类添加变量：</p>
<pre><code>/**
 * 四个边角对应的宽度
 */
 private static final int CORNER_WIDTH = 8;

/**
 * 四个边角对应的长度
 */
private int ScreenRate;

/**
 * 手机的屏幕密度
 */
private static float density;

/**
 * 四个边角的颜色
 */
private final int cornerColor;

/**
 * 扫描框中的中间线的宽度
 */
private static final int MIDDLE_LINE_WIDTH = 2;

/**
 * 扫描框中的中间线的与扫描框左右的间隙
 */
private static final int MIDDLE_LINE_PADDING = 10;

/**
 * 中间那条线每次刷新移动的距离
 */
private static final int SPEEN_DISTANCE = 5;

/**
 * 中间滑动线的最顶端位置
 */
private int slideTop;

/**
 * 中间滑动线的最底端位置
 */
private int slideBottom;

boolean isFirst;
</code></pre></li>
<li><p>修改ViewfinderView类的构造方法和onDraw方法。注：对于Android自定义View，绘制的核心就是onDraw方法。</p>
<p> a.在构造方法中添加初始化或设置变量的值：</p>
<p>   // This constructor is used when the class is built from an XML resource.<br>   public ViewfinderView(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);

// Initialize these once for performance rather than calling them every
// time in onDraw().
paint = new Paint(Paint.ANTI_ALIAS_FLAG);
Resources resources = getResources();
maskColor = resources.getColor(R.color.viewfinder_mask);
resultColor = resources.getColor(R.color.result_view);
laserColor = resources.getColor(R.color.viewfinder_laser);

//设置添加的变量值--start
cornerColor = Color.GREEN;
density = context.getResources().getDisplayMetrics().density;  
//将像素转换成dp  
ScreenRate = (int)(20 * density);  
//设置添加的变量值--end

resultPointColor = resources.getColor(R.color.possible_result_points);
scannerAlpha = 0;
possibleResultPoints = new ArrayList&lt;&gt;(5);
lastPossibleResultPoints = null;
</code></pre><p>   }</p>
<p>b.修改onDraw方法中部分代码：</p>
<p>修改前代码段：</p>
<p>   if (resultBitmap != null) {</p>
<pre><code>// Draw the opaque result bitmap over the scanning rectangle
paint.setAlpha(CURRENT_POINT_OPACITY);
canvas.drawBitmap(resultBitmap, null, frame, paint);
</code></pre><p>   } else {</p>
<pre><code>// Draw a red &quot;laser scanner&quot; line through the middle to show
// decoding is active
paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&lt;ResultPoint&gt; currentPossible = possibleResultPoints;
List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&lt;&gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

// Request another update at the animation interval, but only
// repaint the laser line,
// not the entire viewfinder mask.
postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
        frame.top - POINT_SIZE, frame.right + POINT_SIZE,
        frame.bottom + POINT_SIZE);
</code></pre><p>   }</p>
<p>修改后代码段：</p>
<p>   if (resultBitmap != null) {<br>   // Draw the opaque result bitmap over the scanning rectangle<br>   paint.setAlpha(CURRENT_POINT_OPACITY);<br>   canvas.drawBitmap(resultBitmap, null, frame, paint);<br>   } else {</p>
<pre><code>// Draw a red &quot;laser scanner&quot; line through the middle to show
// decoding is active
/*paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);*/

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&lt;ResultPoint&gt; currentPossible = possibleResultPoints;
List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&lt;&gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

/*
 * 如下为了优化扫描框，绘制边角
 */
paint.setColor(cornerColor);
canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
        + ScreenRate, frame.bottom, paint);
canvas.drawRect(frame.left, frame.bottom - ScreenRate, frame.left
        + CORNER_WIDTH, frame.bottom, paint);
canvas.drawRect(frame.right - ScreenRate, frame.bottom
        - CORNER_WIDTH, frame.right, frame.bottom, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom
        - ScreenRate, frame.right, frame.bottom, paint);

/*
 * 如下绘制中间上下滚动的横线
 */
//初始化中间线滑动的最上边和最下边
if(!isFirst){
    isFirst = true;
    slideTop = frame.top;
    slideBottom = frame.bottom;
}

//绘制中间的线,每次刷新界面，中间的线往下移动SPEEN_DISTANCE
slideTop += SPEEN_DISTANCE;
if(slideTop &gt;= frame.bottom){
    slideTop = frame.top;
}
canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
            frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);
</code></pre></li>
</ul>
</li>
</ol>
<pre><code>            // Request another update at the animation interval, but only
            // repaint the laser line,
            // not the entire viewfinder mask.
            postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
                    frame.top - POINT_SIZE, frame.right + POINT_SIZE,
                    frame.bottom + POINT_SIZE);
        }

**注意**：上面的代码中，中间那根线微信是用的图片(图片可以自己制作，也可以反编译微信apk从中获取)，这里是画的线条，如果你想更加仿真点就将下面的代码：

    canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
                frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);



修改为：

    Rect lineRect = new Rect();  
    lineRect.left = frame.left;  
    lineRect.right = frame.right;  
    lineRect.top = slideTop;  
    lineRect.bottom = slideTop + 18;  
    canvas.drawBitmap(((BitmapDrawable)(getResources().getDrawable(R.drawable.qrcode_scan_line))).getBitmap(), null, lineRect, paint);  
</code></pre><h3 id="4-实战并整合"><a href="#4-实战并整合" class="headerlink" title="4.实战并整合"></a>4.实战并整合</h3><p>待续(实际使用中，一般都是应用APP包括了扫描功能，而不是将扫码功能单独作为一个APP，因此需要对BS工程进行简化，使其可以作为其他应用工程的依赖lib，并去除那些不需要的功能，然后就直接整合进APP。)</p>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zxing/">Zxing</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Eclipse动态调试指南" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/Eclipse动态调试指南/">Eclipse动态调试Android应用指南</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-06-13T07:41:13.000Z" itemprop="datePublished" class="post-time">
  2016-06-13
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Eclipse动态调试指南"><a href="#Eclipse动态调试指南" class="headerlink" title="Eclipse动态调试指南"></a>Eclipse动态调试指南</h1><p>本文对Eclipse进行动态调试做一个全面的讲解（动态调试还可以采用netbeans等工具，暂不阐述），旨在为广大只有apk而没有源代码的程序猿提供排查bug的另辟蹊径。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-反编译"><a href="#1-反编译" class="headerlink" title="1.反编译"></a>1.反编译</h2><p>对目标apk使用apktool反编译出可调试的smali代码到out文件夹，目前apktool最新的版本是2.0.1。</p>
<pre><code>e.g. java -jar apktool_2.0.1.jar d -d target.apk -o out
</code></pre><p>注意:-d参数是必须的，因为这样反编译出来的代码后缀均是java，因为只有java文件才能被eclipse/netbeans识别调试。</p>
<h2 id="2-设置调试标记"><a href="#2-设置调试标记" class="headerlink" title="2.设置调试标记"></a>2.设置调试标记</h2><p>在输出的out文件夹中，用文本编辑工具打开AndroidManifest.xml，在application节点中设置属性android:debuggable=”true”。</p>
<pre><code>e.g. &lt;application android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;com.boyaa.godsdk.core.MutiUnipayApplication&quot;&gt;
</code></pre><h2 id="3-在主Activity的onCreate事件中添加调试等待-可选"><a href="#3-在主Activity的onCreate事件中添加调试等待-可选" class="headerlink" title="3.在主Activity的onCreate事件中添加调试等待(可选)"></a>3.在主Activity的onCreate事件中添加调试等待(可选)</h2><p><strong>注意:如果不需要在程序的开头调试的话，建议忽略这一步。</strong></p>
<p>用文本编辑工具打开主类文件，找到onCreate方法，在第一句前插入invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V，记得添加a=0;//的前缀保持上下一致，结果如下：</p>
<pre><code>a=0;// # virtual methods
a=0;// .method protected onCreate(Landroid/os/Bundle;)V
a=0;//     invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V
a=0;// 
a=0;//     .locals 1
a=0;//     .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;
a=0;// 
a=0;//     .prologue
a=0;//     .line 11
a=0;//     invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V
</code></pre><h2 id="4-保存文件，用apktool重新编译打包为debug-apk"><a href="#4-保存文件，用apktool重新编译打包为debug-apk" class="headerlink" title="4.保存文件，用apktool重新编译打包为debug.apk"></a>4.保存文件，用apktool重新编译打包为debug.apk</h2><pre><code>e.g. java -jar apktool_2.0.1.jar b -d out -o debug.apk
</code></pre><h2 id="5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk"><a href="#5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk" class="headerlink" title="5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk"></a>5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk</h2><p>当然也可以直接采用JDK里面的签名工具通过命令行手动进行签名：<br>    e.g. “jarsigner” -keystore “C:\Users\CoulsonChen\Desktop\kop.keystore” -storepass “kop1122334” -keypass “kop1122334” “D:\t\125.apk” “kop” -sigalg SHA1withRSA -digestalg SHA1</p>
<h2 id="6-上传debug-sign-apk至手机或模拟器，然后安装并运行。"><a href="#6-上传debug-sign-apk至手机或模拟器，然后安装并运行。" class="headerlink" title="6.上传debug_sign.apk至手机或模拟器，然后安装并运行。"></a>6.上传debug_sign.apk至手机或模拟器，然后安装并运行。</h2><p>如果启用第3步，这时你会看到程序运行后停留在白屏界面，这时不要动设备和退出程序，因为程序现在是运行到刚才添加的waitForDebugger代码这里，这行代码的意思是一直挂起中，等待调试器。</p>
<p>如果未启用第3步，则apk正常运行(与普通安装apk无异)。</p>
<h2 id="7-启动eclipse，构建java项目"><a href="#7-启动eclipse，构建java项目" class="headerlink" title="7.启动eclipse，构建java项目"></a>7.启动eclipse，构建java项目</h2><ol>
<li>File -&gt; New -&gt; Project -&gt; Java Project -&gt; Next</li>
<li>Project Name随便起，Use default location选项去掉，Location选择第1步指定的out文件夹，然后Next</li>
<li>把smali文件夹设为Source Folder，然后Finish</li>
</ol>
<h2 id="8-在eclipse中，在需要关注的地方添加断点"><a href="#8-在eclipse中，在需要关注的地方添加断点" class="headerlink" title="8.在eclipse中，在需要关注的地方添加断点"></a>8.在eclipse中，在需要关注的地方添加断点</h2><p>设置断点示例：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-breakpoint.png" alt="设置断点示意图"></p>
<p>打开DDMS（路径在%android-sdks%\tools\ddms.bat）,如果在第6步中运行了修改后的程序，在DDMS的设备列表中会显示可以调试的程序。<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-DDMS.png" alt="DDMS的设备列表"></p>
<p>从上图可以看到，调试的端口为8608</p>
<h2 id="9-现在要做的就是把代码与调试程序关联即可"><a href="#9-现在要做的就是把代码与调试程序关联即可" class="headerlink" title="9.现在要做的就是把代码与调试程序关联即可"></a>9.现在要做的就是把代码与调试程序关联即可</h2><p>回到eclipse，配置远程调试</p>
<ol>
<li>菜单Run -&gt; Debug -&gt; Debug Configurations</li>
<li>双击Remote Java Application，Host处默认localhost就行，Port填第9步得到的8608，然后Apply -&gt; Debug。</li>
</ol>
<p>示意图：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-relation.png" alt="关联源码和程序"></p>
<h2 id="10-切换至debug视图"><a href="#10-切换至debug视图" class="headerlink" title="10.切换至debug视图"></a>10.切换至debug视图</h2><p>看到程序已经运行并中断在下一行可执行的代码了，相关的变量可以直接查看了。示意图：<br><img src="http://172.20.154.39:8080/GodSDKBackground/dynamicDebug-debug.png" alt="最终调试"></p>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态调试/">动态调试</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-apktool打包之后包体变大" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/06/13/apktool打包之后包体变大/">apktool打包之后apk包体变大</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-06-13T07:40:18.000Z" itemprop="datePublished" class="post-time">
  2016-06-13
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>


 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="apktool打包之后apk包体变大"><a href="#apktool打包之后apk包体变大" class="headerlink" title="apktool打包之后apk包体变大"></a>apktool打包之后apk包体变大</h1><p>原因：应该是apktool 2.0.3版本之后引入了两个字段</p>
<ul>
<li><p>compressionType: </p>
</li>
<li><p>doNotCompress:</p>
</li>
</ul>
<p>这两个字段会决定重新编译apk时哪些类型的文件不会压缩，从而影响最终生成的apk的包体大小。</p>
<ol>
<li>解决办法一：</li>
</ol>
<p>请对比apktool 2.0.1和2.1.1版本反编译之后目录下的apktool.yml文件：</p>
<p><strong>2.0.1：</strong><br><img src="http://i.imgur.com/IO5RRBr.png" alt=""></p>
<p><strong>2.1.1：</strong><br><img src="http://i.imgur.com/SOVelmB.png" alt=""></p>
<p>因此，可以动态调整doNotCompress字段中不压缩的文件类型(比如删除图中的- lua行)，来达到压缩的效果，从而使得包体大小保持与原有大小基本一致。</p>
<ol>
<li><p>解决办法二：<br> 既然apktool 2.0.1及其之下版本未引入doNotCompress字段，那么可以采用高版本的apktool释放的1.apk(framework)来作为apktool 2.0.1及其之下版本重编译时的框架依赖。这样可以解决2.0.1重编译依赖Android6.0系统特性的apk失败的问题。</p>
<p> 举例：首先用apktool 2.0.1反编译target.apk，然后将更高版本的apktool释放(反编译操作时候就会自动释放出来)的1.apk覆盖掉apktool 2.0.1的1.apk，1.apk文件一般放在Home_dir\apktool\framework\1.apk,其中Home_dir是操作系统的默认Home目录，windows平台可以打开cmd，提示的目录即为Home_dir。当然也可以采用Everything搜索等工具全局搜索下就知道其路径了。最后，用apktool 2.0.1版本重新编译target.apk反编译时生成的目录，即可编译成功。</p>
</li>
</ol>

    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Apktool打包/">Apktool打包</a></li></ul>

</article>
    </li>
  
</ul>

<nav id="page-nav">
    <div class="inner">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
    </div>
</nav>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Atypical programmer",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://cstsinghua.github.io/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>





<script src="http://s95.cnzz.com/z_stat.php?id=1259817891&web_id=1259817891"></script>





</body>
</html>
