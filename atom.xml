<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Atypical programmer</title>
  <subtitle>做一个非典型程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cstsinghua.github.io/"/>
  <updated>2018-01-08T09:31:21.000Z</updated>
  <id>http://cstsinghua.github.io/</id>
  
  <author>
    <name>Cstsinghua</name>
    <email>cstsinghua@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>adb原理简介及常用命令介绍</title>
    <link href="http://cstsinghua.github.io/2018/01/08/adb%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>http://cstsinghua.github.io/2018/01/08/adb原理简介及常用命令介绍/</id>
    <published>2018-01-08T08:18:23.000Z</published>
    <updated>2018-01-08T09:31:21.000Z</updated>
    
    <content type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们知道，Android程序安装和调试都可通过&lt;a href=&quot;https://developer.android.com/studio/command-line/adb.html&quot; title=&quot;官方adb介绍&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adb&lt;/a&gt;来实现。adb原理看似简单，其实涉及到的知识和原理很多也比较复杂，要想完全弄清楚adb的原理和运行机制，除了查阅官方资料、网上的相关资料(这里提供两份参考资料，请下载&lt;a href=&quot;/adb原理.pdf&quot;&gt;adb原理.pdf&lt;/a&gt;、&lt;a href=&quot;/Android远程控制技术.pdf&quot;&gt;Android远程控制技术.pdf&lt;/a&gt;，不过个人认为这两份资料并未将adb原理讲透将明白，也缺乏实际的场景抓包说明)，实际动手(抓包、测试)都不可少，本文下面章节对adb原理做详细介绍。&lt;/p&gt;
&lt;h1 id=&quot;adb原理分析&quot;&gt;&lt;a href=&quot;#adb原理分析&quot; class=&quot;headerlink&quot; title=&quot;adb原理分析&quot;&gt;&lt;/a&gt;adb原理分析&lt;/h1&gt;&lt;p&gt;(待续)&lt;/p&gt;
&lt;h1 id=&quot;adb常用命令介绍&quot;&gt;&lt;a href=&quot;#adb常用命令介绍&quot; class=&quot;headerlink&quot; title=&quot;adb常用命令介绍&quot;&gt;&lt;/a&gt;adb常用命令介绍&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;adb命令详解(官方文档)&lt;br&gt; adb命令的官方文档和命令使用请参见&lt;a href=&quot;https://developer.android.com/studio/command-line/adb.html&quot; title=&quot;adb命令官方文档说明&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.android.com/studio/command-line/adb.html&lt;/a&gt;。里面对命令的各种参数和子命令都有详细的介绍，可以根据需要，查阅对应的子命令章节。&lt;/li&gt;
&lt;li&gt;通过命令行学习&lt;br&gt; 打开命令行，这里以windows系统为例。如果没有将adb.exe的父目录添加到环境变量path路径中，那么在命令行里面需要输入adb命令的全路径。adb.exe在&lt;code&gt;%ANDROID_HOME%\platform-tools&lt;/code&gt;下，其中&lt;code&gt;%ANDROID_HOME%&lt;/code&gt;代表你电脑上Android SDK的安装路径。&lt;br&gt; 打开命令行，输入adb命令，就可以看到命令的帮助信息，从中也可以了解有哪些子命令和参数可用。如下图所示：&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/ZaDEzmS.png&quot; alt=&quot;adb命令&quot;&gt;&lt;/li&gt;
&lt;li&gt;常用命令介绍&lt;br&gt;&lt;strong&gt;adb命令通用格式&lt;/strong&gt;：&lt;br&gt; 参见官方文档：&lt;a href=&quot;http://developer.android.com/intl/zh-cn/tools/help/adb.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/intl/zh-cn/tools/help/adb.html&lt;/a&gt;&lt;blockquote&gt;
&lt;p&gt;adb [-d|-e|-s &lt;serialnumber&gt;] &amp;lt;command&amp;gt;&lt;/serialnumber&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取系统版本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop ro.build.version.release&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看手机SDK API Level&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop ro.build.version.sdk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看手机CPU信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop ro.product.cpu.abi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  或按照下面命令序列依次输入，即进入Android手机的shell命令行，读取&lt;code&gt;cpuinfo&lt;/code&gt;文件的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell&lt;br&gt;cd /proc&lt;br&gt;cat cpuinfo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发送文件到手机 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb push [-p] &amp;lt;local&amp;gt;  &amp;lt;remote&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 命令说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;copy file/dir to device(复制文件或目录至手机设备)&lt;/li&gt;
&lt;li&gt;(‘-p’ to display the transfer progress)，-p参数表示显示传输进度&lt;/li&gt;
&lt;li&gt;local为本地的文件目录(全路径)&lt;/li&gt;
&lt;li&gt;remote为手机端指定存放目录(Linux风格，/开头，如/data/dir)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从手机拉取文件到本地&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb pull [-p] [-a] &amp;lt;remote&amp;gt; [&amp;lt;local&amp;gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  命令说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;copy file/dir from device(从手机设备复制文件或目录至本机)&lt;/li&gt;
&lt;li&gt;(‘-p’ to display the transfer progress)，-p参数表示显示传输进度&lt;/li&gt;
&lt;li&gt;(‘-a’ means copy timestamp and mode)，复制文件的同时复制文件的时间戳和模式(权限模式)&lt;/li&gt;
&lt;li&gt;local为本地的文件目录(全路径)&lt;/li&gt;
&lt;li&gt;remote为手机端指定存放目录(Linux风格，/开头，如/data/dir)&lt;/li&gt;
&lt;li&gt;示例(e.g.) &lt;code&gt;adb pull -p /default.prop D:\&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;adb shell dumpsys&lt;br&gt;  默认打印出当前系统所有service信息，在后面可加上具体的服务名 需要列出当前运行的服务，可运行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys | findstr DUMP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看手机上层(顶层)Activity的名字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys activity -h  加上-h可以获取帮助信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  linux:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys activity | grep “mFocusedActivity”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  windows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys activity | findstr “mFocusedActivity”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看UI层级&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell uiautomator dump&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看手机分辨率&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell wm size&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  或&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys window displays&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看机型(手机型号)时，可以使用以下命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop ro.product.model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  如果我们忘记具体系统属性的名字，我们可以使用grep进行过滤，比如：&lt;br&gt;  windows系统：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop | findstr product&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  或&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell cat /system/build.prop | findstr product&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  Linux系统：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell getprop | grep product&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  或 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell cat /system/build.prop | grep product&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;打开adb时(在命令行输入adb命令的时候)出现类似报错：&lt;/strong&gt;&lt;br&gt; adb server version (31) doesn’t match this client (39); killing…&lt;br&gt; error: could not install &lt;em&gt;smartsocket&lt;/em&gt; listener: cannot bind to &lt;code&gt;127.0.0.1:5037:&lt;/code&gt; 通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 (10048)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因：电脑上安装了其他手机助手，比如360，腾讯手机管家等，其开启了adb server，但是这些软件自带的adb版本与当前Android SDK路径(添加进了系统path)下的adb(位于&lt;code&gt;%ANDROID_HOME%\platform-tools&lt;/code&gt;下，其中&lt;code&gt;%ANDROID_HOME%&lt;/code&gt;代表你电脑上Android SDK的安装路径)版本不一致，从命令行运行adb devices或者adb start-server，会从Android SDK路径下(已加入到了环境变量path中)的adb启动adb server，&lt;br&gt;从而与当前正在运行的其他软件开启的adb server冲突。而两个版本的server都默认监听5037端口，从而导致系统提示”&lt;code&gt;cannot bind to 127.0.0.1:5037&lt;/code&gt;,只能使用一次”的字样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决办法：&lt;br&gt;  查找是哪个软件开启了adb server，然后将其进程kill掉；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Netstat –ano|findstr “5037”,找到正在使用5037端口的进程ID；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tasklist|findstr &amp;quot;&amp;lt;PID号&amp;gt;&amp;quot;&lt;/code&gt;(其中&lt;code&gt;&amp;lt;PID&amp;gt;&lt;/code&gt;为步骤1中查询到的进程ID号),查看该PID对应的进程名称；&lt;/li&gt;
&lt;li&gt;通过任务管理器的详细信息栏(适用于windows7以上版本系统)，找到对应PID和进程名称的进程，kill之(或者直接用&lt;code&gt;taskkill /F /PID &amp;lt;PID&amp;gt;&lt;/code&gt;命令直接kill对应PID的进程也可，其中&lt;code&gt;&amp;lt;PID&amp;gt;&lt;/code&gt;为步骤1中查询到的进程ID号)；&lt;/li&gt;
&lt;li&gt;重新打开命令行然后输入adb devices即可；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们知道，Android程序安装和调试都可通过&lt;a href=&quot;https://developer.an
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="tools" scheme="http://cstsinghua.github.io/categories/Android/tools/"/>
    
    
      <category term="命令" scheme="http://cstsinghua.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="常用" scheme="http://cstsinghua.github.io/tags/%E5%B8%B8%E7%94%A8/"/>
    
      <category term="adb" scheme="http://cstsinghua.github.io/tags/adb/"/>
    
      <category term="原理" scheme="http://cstsinghua.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="简介" scheme="http://cstsinghua.github.io/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>用sphinx编写智能和漂亮的文档</title>
    <link href="http://cstsinghua.github.io/2017/11/16/%E7%BC%96%E5%86%99sphinx%E6%96%87%E6%A1%A3/"/>
    <id>http://cstsinghua.github.io/2017/11/16/编写sphinx文档/</id>
    <published>2017-11-16T03:07:26.000Z</published>
    <updated>2017-11-16T03:07:29.000Z</updated>
    
    <content type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本文基于实际工作中的场景，&lt;strong&gt;其中的仓库和地址等均是公司内部网址，外部无法访问&lt;/strong&gt;。但原理是相通的，在本地创建API文档或基于远程仓库创建文档时都可参考。&lt;/p&gt;
&lt;p&gt;引擎插件文档采用了&lt;a href=&quot;http://www.sphinx-doc.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sphinx&lt;/a&gt;工具，将rst格式的源文件(rst文件采用&lt;a href=&quot;http://www.sphinx-doc.org/en/stable/rest.html&quot; title=&quot;reStructuredText (reST)&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;reStructuredText (reST)&lt;/a&gt;标记语言编写，类似markdown)生成为html格式，从而在浏览器打开查看。生成的html格式模板主题采用了&lt;a href=&quot;https://github.com/rtfd/sphinx_rtd_theme&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sphinx_rtd_theme&lt;/a&gt;。当前&lt;a href=&quot;https://docs.python.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;python的官方文档&lt;/a&gt;就是用sphinx工具来生成的。&lt;/p&gt;
&lt;p&gt;引擎插件库的源文件仓库地址：公司的&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gogit仓库&lt;/a&gt;(基于&lt;a href=&quot;https://gogs.io/docs&quot; title=&quot;gogs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gogs&lt;/a&gt;搭建的自助Git服务平台)，引擎插件对应的子目录为&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master/sphinx/source/others&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://gogit.oa.com/Engine/engine_doc/src/master/sphinx/source/others&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改即针对&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master/sphinx/source/others/device.rst&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;device.rst&lt;/a&gt;进行。&lt;/p&gt;
&lt;h1 id=&quot;安装、编辑和发布步骤&quot;&gt;&lt;a href=&quot;#安装、编辑和发布步骤&quot; class=&quot;headerlink&quot; title=&quot;安装、编辑和发布步骤&quot;&gt;&lt;/a&gt;安装、编辑和发布步骤&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;安装python，这里以windows系统为例，安装python3.4版本，当然python2.7或最新的python3.6应该也OK的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装sphinx(可参照&lt;a href=&quot;https://github.com/sphinx-doc/sphinx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sphinx-doc/sphinx&lt;/a&gt;)，在命令行输入(安装python之后，一般都会自带安装python的包安装管理工具pip，如果输入下面命令提示找不到pip，则需要安装pip工具，可以参照网上教程执行)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip install Sphinx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装sphinx的主题&lt;a href=&quot;https://github.com/rtfd/sphinx_rtd_theme&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sphinx_rtd_theme&lt;/a&gt;(Sphinx theme for &lt;a href=&quot;https://readthedocs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;readthedocs.org&lt;/a&gt;)，在命令行输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip install sphinx_rtd_theme&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装&lt;a href=&quot;http://mirrors.shuosc.org/apache/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tomcat&lt;/a&gt;，解压到给定目录(比如&lt;code&gt;E:\apache-tomcat-7.0.82&lt;/code&gt;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将&lt;a href=&quot;/others.zip&quot;&gt;others.zip&lt;/a&gt;解压，然后解压的目录(连同other目录)copy至tomcat安装目录的&lt;code&gt;E:\tomcat_path\webapps\ROOT&lt;/code&gt;下(比如&lt;code&gt;E:\apache-tomcat-7.0.82\webapps\ROOT&lt;/code&gt;)。如下图所示：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/DeFhy0s.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注：other目录是已经用&lt;code&gt;sphinx-quickstart&lt;/code&gt;命令配置好的文档根目录，如果想自己配置，则可以新建一个目录(比如&lt;code&gt;E:\apache-tomcat-7.0.82\webapps\ROOT\docRoot&lt;/code&gt;)，然后执行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开命令行，输入下面命令&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;cd E:\apache-tomcat-7.0.82\webapps\ROOT\docRoot&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后输入命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sphinx-quickstart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 该命令会自动引导你对该目录进行配置，这些配置用于sphinx构建时候使用。配置完成之后会在目录的source子目录(配置的时候选择源文件和构建文件分离的选项)下生成conf.py文件，该文件里面就是用python语言来编写的配置，可以在配置完成之后打开进行修改。建议在引导过程中，大部分选项直接选按enter键选默认配置即可，但对于“autodoc” extension和是否支持make两个选项，请选择&lt;code&gt;yes&lt;/code&gt;。选择支持make的话，则会在该目录下生成&lt;code&gt;make.bat&lt;/code&gt;和&lt;code&gt;Makefile&lt;/code&gt;文件，这样后续在修改了rst源文件之后，只需要在该目录下执行&lt;code&gt;make html&lt;/code&gt;命令，即可将最新rst文件实时生成对于的html文件。(查看make.bat文件，可以发现其只是对sphinx-build命令进行了封装，这样构建的时候更加便捷，所以也可以不用make，直接采用sphinx-build命令将rst文件构建生成html文件，当然sphinx其实支持还支持将rst文件转换成pdf等格式，详细情况可以阅读&lt;a href=&quot;http://www.sphinx-doc.org/en/stable/contents.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sphinx的使用文档&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置tomcat的http服务端口为8080(避免与常用的http 80端口冲突，在&lt;code&gt;%tomcat_install_path%/conf/server.xml&lt;/code&gt;中更改)，启动tomcat，即双击运行&lt;code&gt;E:\tomcat_path\bin\startup.bat&lt;/code&gt;(比如&lt;code&gt;E:\apache-tomcat-7.0.82\bin\startup.bat&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;打开浏览器，输入&lt;a href=&quot;http://localhost:8080/others/build/html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080/others/build/html/&lt;/a&gt;，此时可查看引擎插件的本地打开文档效果，与&lt;a href=&quot;http://engine.by.com:8000/doc/sphinx/build/html/others/device.html#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://engine.by.com:8000/doc/sphinx/build/html/others/device.html#&lt;/a&gt;完全一致，只是运行在本地tomcat服务器。&lt;/li&gt;
&lt;li&gt;用文本编辑器编辑device.rst(可查阅并熟悉&lt;a href=&quot;http://www.sphinx-doc.org/en/stable/rest.html&quot; title=&quot;reStructuredText (reST)&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;reStructuredText (reST)标记语言&lt;/a&gt;的语法，在网上搜索了解该标记语言的语法也可)，完成编辑之后，在文档根目录(比如上面示例&lt;code&gt;E:\apache-tomcat-7.0.82\webapps\ROOT\other&lt;/code&gt;)下打开命令行，执行&lt;code&gt;make html&lt;/code&gt;,构建完成之后，再次用浏览器打开&lt;a href=&quot;http://localhost:8080/others/build/html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080/others/build/html/&lt;/a&gt;(或按F5刷新，重新加载)，可以查看到刚才编辑修改过的地方。我们编辑了device.rst之后，先在本地加载预览，符合要求，则提交到gogit仓库&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://gogit.oa.com/Engine/engine_doc/src/master&lt;/a&gt;，引擎插件对应的子目录为&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master/sphinx/source/others&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://gogit.oa.com/Engine/engine_doc/src/master/sphinx/source/others&lt;/a&gt;。引擎部采用&lt;a href=&quot;https://readthedocs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Read the Docs&lt;/a&gt;从gogit的文档仓库&lt;a href=&quot;http://gogit.oa.com/Engine/engine_doc/src/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://gogit.oa.com/Engine/engine_doc/src/master&lt;/a&gt;将里面的rst文档拉取并构建，然后部署到&lt;a href=&quot;http://engine.by.com:8000/doc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP server&lt;/a&gt;上，从而可以打开&lt;a href=&quot;http://engine.by.com:8000/doc/sphinx/build/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://engine.by.com:8000/doc/sphinx/build/html/index.html&lt;/a&gt;查看，关于Read the Doc的原理，请参见其官网&lt;a href=&quot;https://readthedocs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://readthedocs.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本文基于实际工作中的场景，&lt;strong&gt;其中的仓库和地址等均是公司内部网址，外部无法访问&lt;/stron
    
    </summary>
    
      <category term="杂项" scheme="http://cstsinghua.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="文档" scheme="http://cstsinghua.github.io/categories/%E6%9D%82%E9%A1%B9/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="sphinx" scheme="http://cstsinghua.github.io/tags/sphinx/"/>
    
      <category term="API 文档" scheme="http://cstsinghua.github.io/tags/API-%E6%96%87%E6%A1%A3/"/>
    
      <category term="rst" scheme="http://cstsinghua.github.io/tags/rst/"/>
    
      <category term="reStructuredText" scheme="http://cstsinghua.github.io/tags/reStructuredText/"/>
    
      <category term="readthedocs" scheme="http://cstsinghua.github.io/tags/readthedocs/"/>
    
      <category term="python" scheme="http://cstsinghua.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Android手机屏幕实时展示</title>
    <link href="http://cstsinghua.github.io/2017/11/01/Android%E5%AE%9E%E6%97%B6%E5%B1%8F%E5%B9%95%E5%B1%95%E7%A4%BA/"/>
    <id>http://cstsinghua.github.io/2017/11/01/Android实时屏幕展示/</id>
    <published>2017-11-01T02:04:55.000Z</published>
    <updated>2017-11-01T03:24:13.000Z</updated>
    
    <content type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在Android开发中，有这样的情形：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手机连接在本机，但是因为在一边调试，不方便同时拿着手机看结果(手机屏幕和PC屏幕来回切换较麻烦)，期望手机屏幕与调试程序的屏幕同时在PC的屏幕一并展示，这样更加便捷；&lt;/li&gt;
&lt;li&gt;调试(或测试)的手机并非连接在本机上，此时需要在测试的时候在本机上同步查看远端手机的屏幕(调试时实时的展示)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述情况下，就需要将调试的手机屏幕通过一定技术手段在PC屏幕上实时展示。通过查询资料和实践，目前总结出两种方法可以达到目标。&lt;/p&gt;
&lt;h1 id=&quot;原生adb方式&quot;&gt;&lt;a href=&quot;#原生adb方式&quot; class=&quot;headerlink&quot; title=&quot;原生adb方式&quot;&gt;&lt;/a&gt;原生adb方式&lt;/h1&gt;&lt;p&gt;我们知道，Android调试都是通过&lt;a href=&quot;https://developer.android.com/studio/command-line/adb.html&quot; title=&quot;官方adb介绍&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adb&lt;/a&gt;来实现。adb原理看似简单，其实涉及到的知识和原理很多也比较复杂，要想完全弄清楚adb的原理和运行机制，除了查阅官方资料、网上的相关资料(这里提供两份参考资料，请下载&lt;a href=&quot;/adb原理.pdf&quot;&gt;adb原理.pdf&lt;/a&gt;、&lt;a href=&quot;/Android远程控制技术.pdf&quot;&gt;Android远程控制技术.pdf&lt;/a&gt;，不过个人认为这两份资料并未将adb原理讲透将明白，也缺乏实际的场景抓包说明)，实际动手(抓包、测试)都不可少，本文暂不对adb原理进行展开，后续会单独写一篇adb的原理介绍。&lt;/p&gt;
&lt;p&gt;这里以windows系统为例，开发人员常使用adb.exe，在命令行下执行各种adb命令，比如截图&lt;code&gt;adb shell screencap /sdcard/your_path.png&lt;/code&gt;。那么既然通过adb命令可以截图，我们是否可以想到，如果不停地执行截图，然后将N张截图以类似播放电影的方式连贯起来，那不就相当于实时查看手机屏幕了吗。&lt;/p&gt;
&lt;p&gt;看起来这个方式应该可行，但是存在两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;adb shell screencap&lt;/code&gt;命令截图，耗时还是比较多，一般在1-2s之间，而且对手机资源消耗也比较多，不停截图的话，CPU和其他资源占用就更多了，可能影响正在调试的APP的测试指标；&lt;/li&gt;
&lt;li&gt;还需要单独对adb.exe的命令行使用进行代码封装，原理虽简单，但是做这些重复性的活很让人厌烦。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于问题1，我们可以通过minicap的方式来解决；对于问题2，其实Android SDK包里面已经有相关工具库可供使用，那就是ddmlib，位于&lt;code&gt;%ANDROID_HOME%\tools\lib\&lt;/code&gt;目录下(其中&lt;code&gt;%ANDROID_HOME%&lt;/code&gt;表示Android SDK的安装目录)，名字一般叫&lt;code&gt;ddmlib-x.y.z-xx.jar&lt;/code&gt;(x.y.z-xx表示版本号，建议更新Android SDK至最新版)。关于ddmlib，网上资料相对较少，可以查看jar包的源码进行详细的研究，也可以参考网上已有的部分资料(比如github上一个ddmlib封装库&lt;a href=&quot;https://github.com/cosysoft/device&quot; title=&quot;cosysoft/device&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/cosysoft/device&lt;/a&gt;)。ddmlib相当于提供了一个adb client，提供了调用的接口，可以实现连接设备，发送和执行adb命令，获取结果等等，也就是说，大家平时通过adb.exe能干的事情，ddmlib都可以做到，提供了很好的封装和调用接口，其实Android的DDMS工具和其他类似工具等底层都是通过调用ddmlib实现调试和操作的。&lt;/p&gt;
&lt;p&gt;但是，我们这里仍然不直接使用ddmlib，为什么呢，答案就是“站在巨人的肩膀上前进”。其实Github上已有一个较好的实现&lt;a href=&quot;https://github.com/adakoda/android-screen-monitor&quot; title=&quot;android-screen-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-screen-monitor&lt;/a&gt;，该实现基于ddmlib，另外还使用到chimpchat(与ddmlib库一样，位于位于&lt;code&gt;%ANDROID_HOME%\tools\lib\&lt;/code&gt;目录下，名字一般叫&lt;code&gt;chimpchat-x.y.z-xx.jar&lt;/code&gt;)和&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;google的guava库&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从Github将&lt;a href=&quot;https://github.com/adakoda/android-screen-monitor&quot; title=&quot;android-screen-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-screen-monitor&lt;/a&gt;工程clone下来之后，通过Eclipse导入工程，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BQ6uUWw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对工程源码进行定制或二次开发之后，可以将工程导出为一个可执行jar包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/s3VwaWb.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;minicap和minitouch&quot;&gt;&lt;a href=&quot;#minicap和minitouch&quot; class=&quot;headerlink&quot; title=&quot;minicap和minitouch&quot;&gt;&lt;/a&gt;minicap和minitouch&lt;/h1&gt;&lt;p&gt;该方式基于Github上一个比较有名的云测手机测试项目&lt;a href=&quot;https://github.com/openstf/stf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STF项目&lt;/a&gt;的两个子项目&lt;a href=&quot;https://github.com/openstf/minicap&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;minicap&lt;/a&gt;、&lt;a href=&quot;https://github.com/openstf/minitouch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;minitouch&lt;/a&gt;。其中minicap实现屏幕实时展示，而minitouch实现模拟点击和滑动，从而可以在本机上直接操作手机，就如同直接在手机上点击和滑动一样。&lt;/p&gt;
&lt;p&gt;minicap的原理大致为(可详细查看minicap Github的readme)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在手机端通过minicap.so(Android NDK开发，其基于Android底层开发，从设备底层获取屏幕的数据)&lt;/li&gt;
&lt;li&gt;minicap可执行文件，在手机端开启一个socket server，接收来自PC客户端的连接，将屏幕帧流不断发送至PC端的socket client&lt;/li&gt;
&lt;li&gt;PC端通过adb forward命令实现socket连接转发，因为PC连接Android手机一切都通过adb server。PC的socket client通过adb forward转发连接至minicap开启的socket server，读取其发送的帧流，然后在PC端处理之后即可通过GUI程序或者web页面展示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于minicap实现手机屏幕实时展示，官方Github仓库的sample中提供了NodeJS的示例，而python和java的示例在网上已有很多人实现过(本文后续会提供一份python版本的实现)，可以参阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://testerhome.com/topics/3115&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STF 框架之 minicap 工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/777af34b4f21&quot; title=&quot;Python实现minicap协议解析并通过PyQt渲染&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Python实现minicap协议解析并通过PyQt渲染&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在Android开发中，有这样的情形：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手机连接在本机，但是因为在一边调试，不
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="tools" scheme="http://cstsinghua.github.io/categories/Android/tools/"/>
    
    
      <category term="Android" scheme="http://cstsinghua.github.io/tags/Android/"/>
    
      <category term="实时" scheme="http://cstsinghua.github.io/tags/%E5%AE%9E%E6%97%B6/"/>
    
      <category term="real time" scheme="http://cstsinghua.github.io/tags/real-time/"/>
    
      <category term="screen" scheme="http://cstsinghua.github.io/tags/screen/"/>
    
      <category term="展示" scheme="http://cstsinghua.github.io/tags/%E5%B1%95%E7%A4%BA/"/>
    
      <category term="display" scheme="http://cstsinghua.github.io/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android应用包apk双击安装和文件图标定制</title>
    <link href="http://cstsinghua.github.io/2017/09/30/apk%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85/"/>
    <id>http://cstsinghua.github.io/2017/09/30/apk双击安装/</id>
    <published>2017-09-30T04:08:36.000Z</published>
    <updated>2017-09-30T06:07:29.000Z</updated>
    
    <content type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Android应用最终是以APK文件的形式发布，在开发和调试过程中，经常需要安装某个apk，一般情况下有两种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用第三方软件，比如各大厂商的手机助手等。&lt;ul&gt;
&lt;li&gt;优点：简单省事&lt;/li&gt;
&lt;li&gt;缺点：国内流氓厂家太多，安装一个软件经常附带安装很多其他杂七杂八的东西，对用户造成困扰不说，个人数据的安全性和隐私有泄露的隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用Android自带adb命令&lt;ul&gt;
&lt;li&gt;优点：非侵入，透明&lt;/li&gt;
&lt;li&gt;缺点：每次都要在命令行窗口输入命令，繁琐，效率较低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;自己造轮子-invent-the-wheel&quot;&gt;&lt;a href=&quot;#自己造轮子-invent-the-wheel&quot; class=&quot;headerlink&quot; title=&quot;自己造轮子(invent the wheel)&quot;&gt;&lt;/a&gt;自己造轮子(invent the wheel)&lt;/h1&gt;&lt;p&gt;基于上述的背景，作为开发者，自己实现一个小工具，该工具需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快捷安装&lt;br&gt;  实现便捷安装apk(双击apk文件即自动安装至调试手机)&lt;/li&gt;
&lt;li&gt;定制文件显示图标&lt;br&gt;  可以定制apk文件在文件系统中显示时的图标，即在资源管理器中查看时不会显示空白(因为未设置默认打开程序)，如下图所示(这里以yml文件为例)：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/2n3dd7W.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;要达到上述要求，那么即需要编写一个简单的可执行程序，并且设置为apk文件的默认打开程序，由该程序调用&lt;code&gt;adb install&lt;/code&gt;进行apk文件安装，同时该程序的icon即用于apk文件的展示图标。在windows系统下，要编写一个exe文件非常方便。&lt;/p&gt;
&lt;h2 id=&quot;实施&quot;&gt;&lt;a href=&quot;#实施&quot; class=&quot;headerlink&quot; title=&quot;实施&quot;&gt;&lt;/a&gt;实施&lt;/h2&gt;&lt;p&gt;这里选择采用python脚本+Pyinstaller来开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;python脚本&lt;br&gt;  处理参数传入和adb intall调用安装，可以扩展功能&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pyinstaller.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pyinstaller&lt;/a&gt;&lt;br&gt;  官方描述：Freeze (package) Python programs into stand-alone executables，简单来说就是将python脚本转换成可独立运行的程序，在windows平台即exe，其具体原理可以参见官方的介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.python脚本示例(&lt;a href=&quot;/apk_installer.pyw&quot;&gt;apk_installer.pyw&lt;/a&gt;)：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; shlex,subprocess&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    apk_name = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#print apk_name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#os.system(&#39;adb install -r &#39; + apk_name) #will spawn command prompt,so &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cmd = &lt;span class=&quot;string&quot;&gt;&#39;adb install -r &#39;&lt;/span&gt; + apk_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    si = subprocess.STARTUPINFO()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    si.dwFlags |= subprocess.STARTF_USESHOWWINDOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    si.wShowWindow = subprocess.SW_HIDE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#si.wShowWindow = subprocess.SW_HIDE # hide command prompt window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# p = subprocess.Popen(shlex.split(cmd),shell=True)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p = subprocess.Popen(cmd,startupinfo = si,shell = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p.wait() &lt;span class=&quot;comment&quot;&gt;#waitting for child process to terminate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# DETACHED_PROCESS = 0x00000008&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# subprocess.call(cmd, creationflags = DETACHED_PROCESS)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.先利用python pip命令安装pyinstaller，然后利用pyinstaller将上述python脚本转换成exe：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令行模式下切换到python脚本的目录(D:\cstsinghua\apk install)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd D:\cstsinghua\apk install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行转换命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pyinstaller -F –nowindow -i android.ico apk_installer.pyw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  &lt;code&gt;-F&lt;/code&gt;表示只生成一个exe，所有需要的文件都包含在生成的exe内；&lt;code&gt;--nowindow&lt;/code&gt;隐藏命令行窗口，&lt;code&gt;-i&lt;/code&gt;参数后面跟exe文件的ico文件，可以根据自己的喜好制作成想要的图(可以用png图片转成ico文件，可参见&lt;a href=&quot;http://www.bitbug.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线制作ico图标&lt;/a&gt;)。pyinstaller命令参数请参考&lt;a href=&quot;http://pythonhosted.org/PyInstaller/usage.html#windows-specific-options&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pyinstaller参数详解&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里提供完整示例(包含python脚本和ico文件，以pyinstaller的spec文件，最终的exe文件)，请下载：&lt;a href=&quot;/apk install.zip&quot;&gt;apk install.zip&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;p&gt;这里仅提供一种简单的思路，当然也可以采用加入鼠标右键菜单的方式来实现apk安装，可参考&lt;a href=&quot;https://github.com/pwelyn/SignapkTools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/pwelyn/SignapkTools&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Android应用最终是以APK文件的形式发布，在开发和调试过程中，经常需要安装某个apk，一般情况下有
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="tools" scheme="http://cstsinghua.github.io/categories/Android/tools/"/>
    
    
      <category term="Android" scheme="http://cstsinghua.github.io/tags/Android/"/>
    
      <category term="apk install" scheme="http://cstsinghua.github.io/tags/apk-install/"/>
    
      <category term="双击" scheme="http://cstsinghua.github.io/tags/%E5%8F%8C%E5%87%BB/"/>
    
      <category term="double click" scheme="http://cstsinghua.github.io/tags/double-click/"/>
    
      <category term="installer" scheme="http://cstsinghua.github.io/tags/installer/"/>
    
      <category term="apk icon" scheme="http://cstsinghua.github.io/tags/apk-icon/"/>
    
      <category term="定制apk显示图标" scheme="http://cstsinghua.github.io/tags/%E5%AE%9A%E5%88%B6apk%E6%98%BE%E7%A4%BA%E5%9B%BE%E6%A0%87/"/>
    
      <category term="apk display icon" scheme="http://cstsinghua.github.io/tags/apk-display-icon/"/>
    
  </entry>
  
  <entry>
    <title>RxJava&amp;RxAndroid学习之路--理论篇</title>
    <link href="http://cstsinghua.github.io/2017/03/10/RxJava%E5%92%8CRxAndroid%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>http://cstsinghua.github.io/2017/03/10/RxJava和RxAndroid学习之路——理论篇/</id>
    <published>2017-03-10T08:30:28.000Z</published>
    <updated>2017-03-14T06:36:24.000Z</updated>
    
    <content type="html">&lt;p&gt;RxJava&amp;amp;RxAndroid学习之路–理论篇&lt;/p&gt;
&lt;p&gt;最近一段时间以来，在面试的Android开发人员简历中，基本都会提及熟悉RxJava或RxAndroid，貌似不会RxJava或RxAndroid就落伍，就只是初级的Android开发人员。于是，带着好奇心和疑问准备一探究竟，于是乎接下来就是一通google balabala…但是，网上关于RxJava或RxAndroid的学习资料非常多，各种文章和blog让人眼花缭乱，不知道如何入手，可以说，大部分文章要么艰涩难懂，要么过于浅显，让人看了不明觉厉。是的，RxJava或RxAndroid的学习相对来说有一定的门槛，但是一旦入门，那么相信你就会爱上它。本文根据个人学习RxJava或RxAndroid的历程，总结出相关经验，以便他人学习之时少走弯路。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;学习一个新知识的时候，一般地，我们都会带着如下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要学习(Why to learn)？&lt;/li&gt;
&lt;li&gt;要学的新知识是什么(What is it)？&lt;/li&gt;
&lt;li&gt;怎么学习这个知识点(How to learn)？&lt;/li&gt;
&lt;li&gt;学习之后怎么用(Where to use)？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个问题，这里就不用回答了，既然你打开了这篇文章，说明你肯定有着充分的理由。本文重点介绍一下2和3，也即本人学习RxJava或RxAndroid的经验总结，希望能对你有所帮助。&lt;/p&gt;
&lt;h1 id=&quot;ReactiveX是什么？&quot;&gt;&lt;a href=&quot;#ReactiveX是什么？&quot; class=&quot;headerlink&quot; title=&quot;ReactiveX是什么？&quot;&gt;&lt;/a&gt;ReactiveX是什么？&lt;/h1&gt;&lt;p&gt;要了解RxJava&amp;amp;RxAndroid是什么，首先得了解什么是ReactiveX？ReactiveX是Reactive Extensions的缩写，一般简写为Rx，RxJava&amp;amp;RxAndroid是Rx在JVM和Android平台上的具体实现，除了Java语言，ReactiveX几乎已经被其他主流编程语言所支持。其官方网址为&lt;a href=&quot;http://reactivex.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io&lt;/a&gt;，其实这个网站的手册和介绍已经非常详细，但是，对于初学者而言，还是有一定难度。不过，引用该网站对Rx的介绍作为一个概念性的认识，还是有必要的。&lt;/p&gt;
&lt;p&gt;正如reactivex.io所述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说ReactiveX结合了观察者模式、迭代器模式和函数式编程的最佳思想。&lt;/p&gt;
&lt;p&gt;因此，首先就需要熟悉观察者模式(Observer pattern)，相信熟悉java和Android的朋友应该对此比较熟悉了，其在GUI编程中经常使用。要了解观察者，建议阅读维基百科上面的阐述：&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/Observer_pattern&lt;/a&gt;；或者阅读”The Gang of Four”(所谓”四人帮”)所著的著名著作”Design Patterns:Elements of Reusable Object-Oriented Software”一书；亦可参考Github开源库&lt;a href=&quot;https://github.com/iluwatar/java-design-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/iluwatar/java-design-patterns&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;同理，也需要了解迭代器模式(Iterator pattern)，其在Java集合的遍历实现中经常使用。建议阅读维基百科上面的阐述：&lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/Iterator_pattern&lt;/a&gt;；或者阅读”The Gang of Four”(所谓”四人帮”)所著的著名著作”Design Patterns:Elements of Reusable Object-Oriented Software”一书；亦可参考Github开源库&lt;a href=&quot;https://github.com/iluwatar/java-design-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/iluwatar/java-design-patterns&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而关于函数式编程(functional programming,一种编程范式–programming paradigm)，这个话题很大，也很深，水平有限，这里不做阐述，想了解的读者可以在维基百科&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/Functional_programming&lt;/a&gt;查询或者通过其他资料学习。其实在我看来，在这个特定场景下，仅仅理解成用流式(链式)方式编写代码即可。&lt;/p&gt;
&lt;p&gt;有背景有了大致的了解之后，笔者认为，那么接下来应该需要先弄清里面的术语，Rx里面术语比较多，要厘清每个术语对应的角色，才能真正入门(笔者在刚接触Rx的时候，被里面各种术语和角色弄得头晕)。真正弄透了各个角色，也就真正了解了Rx。&lt;/p&gt;
&lt;h1 id=&quot;Rx里面的术语和角色&quot;&gt;&lt;a href=&quot;#Rx里面的术语和角色&quot; class=&quot;headerlink&quot; title=&quot;Rx里面的术语和角色&quot;&gt;&lt;/a&gt;Rx里面的术语和角色&lt;/h1&gt;&lt;p&gt;Rx里面包括很多术语，每个术语对应不同的角色，而这些角色组合在一起便是Rx的体系，也是我们在实际使用Rx进行编码的时候操作的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Observable:&lt;/strong&gt; 可观察对象，从对比角度看，相当于观察者模式中是被观察的对象(即观察者模式中的Subject，注意，请区分Rx里面的Subject，见下文)，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者。Observable的强大之处，在Rx中定义为更强大的Iterable，即可以emit(发射)item和item序列(流)，特别是数据流的概念，因为几乎所有的对象都可以理解或者转换成数据流，详细内容可参见&lt;a href=&quot;http://reactivex.io/documentation/observable.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io/documentation/observable.html&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;items:&lt;/strong&gt; 直译为项目，条目，在Rx里是指Observable发射的数据项；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;emit:&lt;/strong&gt; 直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Observer:&lt;/strong&gt; 观察者对象，可以对比理解成观察者模式里面的Observer，监听(也叫订阅，Subscribe)Observable发射的数据(流)并做出响应，Subscriber是它的一个特殊实现。Observable和Observer之间通过Subscribe方法联系在一起；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Operators:&lt;/strong&gt; 操作或运算，可以对Observable进行转换、过滤等操作，也可以生成Observable，大多数Operator对Observable操作返回的仍然是Observable，这样便可以形成链式操作(Chaining Operators)，类似于构建者模式(Builder Pattern)。Rx真正强大之处，最关键之一就是Operators提供的能力。详细内容可参见&lt;a href=&quot;http://reactivex.io/documentation/operators.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io/documentation/operators.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single:&lt;/strong&gt; Observable的一个变种(variant)，区别在于，它仅仅发出一个值(Value)或错误通知(error notification)。详细可参见&lt;a href=&quot;http://reactivex.io/documentation/single.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io/documentation/single.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subject:&lt;/strong&gt; 在Rx的某些语言实现中出现，既是observer又是observable，详细信息可参见&lt;a href=&quot;http://reactivex.io/documentation/subject.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io/documentation/subject.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scheduler:&lt;/strong&gt; 调度者，Rx引入多线程的机制。默认情况下，Observable及Operators都是在同一个线程完成所有工作，Observable的SubscribeOn方法(其实也是一个Operator)改变了默认的行为，通过指定一个不同的Scheduler，Observable则在该Scheduler上执行操作。而ObserveOn方法(其实也是一个Operator)则指定一个不同的Scheduler，Observable用来发送通知给Observer。详细信息请参见&lt;a href=&quot;http://reactivex.io/documentation/scheduler.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactivex.io/documentation/scheduler.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;RxJava-amp-RxAndroid入门&quot;&gt;&lt;a href=&quot;#RxJava-amp-RxAndroid入门&quot; class=&quot;headerlink&quot; title=&quot;RxJava&amp;amp;RxAndroid入门&quot;&gt;&lt;/a&gt;RxJava&amp;amp;RxAndroid入门&lt;/h1&gt;&lt;p&gt;对Rx有了初步的认识，特别是了解了里面的常用术语和角色，那么作为Java或Android开发者，要入门，应该怎么学习呢？首先，RxJava在Github上的仓库地址为&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ReactiveX/RxJava&lt;/a&gt;，RxAndroid的则对应&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ReactiveX/RxAndroid&lt;/a&gt;。在仓库的Wiki页面，有相关的介绍。不过不建议直接就读取里面内容，可以在有一定了解的基础上进行系统学习。&lt;/p&gt;
&lt;p&gt;这里推荐一篇blog，&lt;a href=&quot;http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/&lt;/a&gt;,里面分成4个部分，分别从基础、Operator、Rx的益处、RxAndroid四个方面进行了阐述，浅显易懂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别提醒：学习RxJava之时，可以用示意图的方式将流程的marble diagram图画出来，理解了marble diagram，也就很清晰地知道了整个机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Eg.&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/OtCBvel.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;除此之外，以下两篇文章或链接也值得一读：&lt;br&gt;&lt;a href=&quot;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.introtorx.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.introtorx.com/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;进一步学习&quot;&gt;&lt;a href=&quot;#进一步学习&quot; class=&quot;headerlink&quot; title=&quot;进一步学习&quot;&gt;&lt;/a&gt;进一步学习&lt;/h1&gt;&lt;p&gt;通过上面几篇文章的介绍，就可以对RxJava有一个基本的了解，也可以简单运用了。要想全面深入学习RxJava，那么建议仔细阅读reactivex.io的全部内容，以及RxJava&amp;amp;RxAndroid在Github上仓库中的Wiki内容。这里面又包含了其他推荐文章的链接。同时也可以研究RxJava&amp;amp;RxAndroid的源码。&lt;/p&gt;
&lt;p&gt;特别要提及的是，对于Android开发者而言，还需要了解Retrofit等支持Rx的开源库，结合起来使用，就更能彰显威力。那就是当下比较流行的Retrofit+RxAndroid开发。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      RxJava&amp;RxAndroid快速入门
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="编程实践" scheme="http://cstsinghua.github.io/categories/Android/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="入门" scheme="http://cstsinghua.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="RxJava" scheme="http://cstsinghua.github.io/tags/RxJava/"/>
    
      <category term="RxAndroid" scheme="http://cstsinghua.github.io/tags/RxAndroid/"/>
    
      <category term="学习之路" scheme="http://cstsinghua.github.io/tags/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="观察者模式" scheme="http://cstsinghua.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="http://cstsinghua.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Observer pattern" scheme="http://cstsinghua.github.io/tags/Observer-pattern/"/>
    
      <category term="Iterator pattern" scheme="http://cstsinghua.github.io/tags/Iterator-pattern/"/>
    
      <category term="functional programming" scheme="http://cstsinghua.github.io/tags/functional-programming/"/>
    
      <category term="ReactiveX" scheme="http://cstsinghua.github.io/tags/ReactiveX/"/>
    
  </entry>
  
  <entry>
    <title>Android APK逆向解析</title>
    <link href="http://cstsinghua.github.io/2017/02/21/Android%20APK%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90/"/>
    <id>http://cstsinghua.github.io/2017/02/21/Android APK逆向解析/</id>
    <published>2017-02-21T06:34:42.000Z</published>
    <updated>2018-03-02T03:43:02.000Z</updated>
    
    <content type="html">&lt;p&gt;Android APK逆向解析&lt;/p&gt;
&lt;p&gt;众所周知，Android系统是开源的，运行其上的Android应用APK即Android Package也是可以通过各种工具进行反编译或者逆向工程，从而可以对其他APP进行研究或者借鉴学习，亦或从APK中获取相关信息(比如清单文件AndroidManifest.xml里面的package、versionName和versionCode等等)。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android的构建流程&quot;&gt;&lt;a href=&quot;#Android的构建流程&quot; class=&quot;headerlink&quot; title=&quot;Android的构建流程&quot;&gt;&lt;/a&gt;Android的构建流程&lt;/h1&gt;&lt;p&gt;要真正进行Android反编译和逆向，首先需要对Android的编译和构建过程有一个大致的了解。因为反编译和编译的过程是相逆的。本文从Android开发者官网摘取了关于Android构建的描述，详细信息请参见&lt;a href=&quot;https://developer.android.com/studio/build/index.html#build-config&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android构建流程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;构建流程涉及许多将您的项目转换成 Android 应用软件包 (APK) 的工具和流程。构建流程非常灵活，因此了解它的一些底层工作原理会很有帮助。典型Android应用模块的构建流程如下图所示：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/ECzWe5b.png&quot; alt=&quot;build-process&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，典型 Android 应用模块的构建流程通常依循下列步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译器(这里涉及到JDK、aapt等工具)将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。&lt;/li&gt;
&lt;li&gt;APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。&lt;/li&gt;
&lt;li&gt;APK 打包器使用调试或发布密钥库签署您的 APK：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a.&lt;/strong&gt;如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;b.&lt;/strong&gt;如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署您的应用。要创建发布密钥库，请阅读在 Android Studio 中签署您的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Android-APK逆向解析&quot;&gt;&lt;a href=&quot;#Android-APK逆向解析&quot; class=&quot;headerlink&quot; title=&quot;Android APK逆向解析&quot;&gt;&lt;/a&gt;Android APK逆向解析&lt;/h1&gt;&lt;p&gt;首先，要对APK文件进行分析，需要了解APK文件的结构。其实APK文件就是一个zip文件，所以采用解压缩软件可以查看里面的子项。典型的APK文件的解压缩视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/xLb60OI.png&quot; alt=&quot;Android APK文件解压缩视图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;classes.dex：classes.dex是java源码编译后生成的java字节码文件(非传统JVM解释执行的class字节码)。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。Android模拟器中提供了一个dex文件的反编译工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，找到要查看的dex文件，执行dexdump xxx.dex（或者从压缩文件取出dex文件，直接在PC上面找到dexdump.exe的路径，然后执行命令）。另外Dedexer是一个反编译dex文件的开源工具，需要自己编译源代码。而当前，还有比如dex2jar(&lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/pxb1988/dex2jar&lt;/a&gt;)甚至封装好的GUI的工具(比如安卓逆向助手等等，可网上搜索下载)可以反编译dex文件为jar文件，再利用jd-gui(&lt;a href=&quot;http://jd.benow.ca/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jd.benow.ca/&lt;/a&gt;)工具打开jar文件，就可以阅读java源代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;resources.arsc：编译Android资源文件后的生成的二进制文件，resources.arsc有固定的格式，包括了资源索引和字符串资源池等，详细可参见&lt;a href=&quot;https://hellokugo.github.io/2016/09/03/Resource.arsc%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resources.arsc解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AndroidManifest.xml：清单文件，该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过编译的，即是二进制格式，如果直接用编辑器打开，显示会是乱码。因此需要先进行反编译处理，得到原始的AndroidManifest.xml文件。可以通过AXMLPrinter2或aapt工具解开或解析，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;assets：assets目录可以存放一些配置文件（比如webview本地资源、图片资源、音视频等等），不会经过编译，和原始工程里面的文件是一致的，这些文件的内容在程序运行过程中可以通过相关的API（android.content.res.AssetManager）获得。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lib：lib目录下的子目录存放的是一些与手机CPU架构对应的C/C++代码编译生成的so文件，一般用于JNI开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;META-INF：META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;res：res目录存放经过编译后的资源文件，虽与原始工程目录下的res目录层次结构类似，但是实际上是经过编译处理的，只有图片资源和原始工程是一致，其他类型的资源则是编译处理过，无法直接查看。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面对APK内部文件的分析来看，要想反编译或者逆向工程获取信息，其实主要涉及两个方面，一是对classes.dex反编译，转换成jar或者smali等，可以利用dex2jar(&lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/pxb1988/dex2jar&lt;/a&gt;)等工具生成jar，二是结合resources.arsc和res对资源进行反编译，从而得到原始的资源文件。本文罗列平时工作和搜集到的一些常见的Android APK反编译和逆向分析工具，对工具的使用不做过多阐述，关于各个工具的详细使用和技巧，可以参见下文中提及的工具的官方链接。&lt;/p&gt;
&lt;h2 id=&quot;全能型选手-apktool&quot;&gt;&lt;a href=&quot;#全能型选手-apktool&quot; class=&quot;headerlink&quot; title=&quot;全能型选手-apktool&quot;&gt;&lt;/a&gt;全能型选手-apktool&lt;/h2&gt;&lt;p&gt;apktool可以对Android APK直接进行反编译(也可以在反编译得到的目录基础上进行回编，生成apk)。其是Android领域反编译最常用的开源工具，虽然有商业级的反编译工具Jeb(&lt;a href=&quot;https://www.pnfsoftware.com/&quot; title=&quot;Android反编译商业化工具Jeb官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.pnfsoftware.com/&lt;/a&gt;)，但鉴于收费且不开源，更多的程序开发者则选择apktool，其官方链接:&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/&quot; title=&quot;apktool官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://ibotpeaches.github.io/Apktool/&lt;/a&gt;。&lt;br&gt;&lt;strong&gt;Note：apktool反编译之后，得到是目录和文件，因此适用于需要对原始文件和代码进行分析的场景。dex通过apktool依赖的backsmali工具反编译之后得到的是smali文件，关于smali/backsmali可以参见&lt;a href=&quot;https://github.com/JesusFreke/smali&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/JesusFreke/smali&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;jadx&quot;&gt;&lt;a href=&quot;#jadx&quot; class=&quot;headerlink&quot; title=&quot;jadx&quot;&gt;&lt;/a&gt;jadx&lt;/h2&gt;&lt;p&gt;可以将dex文件和apk文件反编译成可阅读的格式，主要涉及java代码和AndroidManifest.xml查看。jadx的github链接地址为&lt;a href=&quot;https://github.com/skylot/jadx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/skylot/jadx&lt;/a&gt;。适用场景：可以用于快速查看APK内的java代码和清单文件内容。&lt;/p&gt;
&lt;h2 id=&quot;ClassyShark&quot;&gt;&lt;a href=&quot;#ClassyShark&quot; class=&quot;headerlink&quot; title=&quot;ClassyShark&quot;&gt;&lt;/a&gt;ClassyShark&lt;/h2&gt;&lt;p&gt;google官方为Android开发者推出的独立的二进制文件检查工具，因此其权威性和强大毋庸赘言，且得到较好的维护和更新。其github地址为：[&lt;a href=&quot;https://github.com/google/android-classyshark&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/google/android-classyshark&lt;/a&gt;] ，其支持多种文件格式的解析，包括：库文件 (.dex, .aar, .so), 可执行文件 (.apk, .jar, .class) 和所有的Android二进制XML格式文件如AndroidManifest, resources, layouts等等。另外，很重要的一点，其能分析得出dex文件里面包含的方法数，这对于Android一个著名的问题(方法数超限65535，见&lt;a href=&quot;https://developer.android.com/studio/build/multidex.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.android.com/studio/build/multidex.html&lt;/a&gt;)的解决很有帮助。&lt;/p&gt;
&lt;h2 id=&quot;AXMLParser&quot;&gt;&lt;a href=&quot;#AXMLParser&quot; class=&quot;headerlink&quot; title=&quot;AXMLParser&quot;&gt;&lt;/a&gt;AXMLParser&lt;/h2&gt;&lt;p&gt;AXMLParser仅仅是用于解析APK里面的二进制AndroidManifest.xml，从而得到与原始工程里的AndroidManifest.xml内容一致的可读xml。较轻量级，适用于只想查看和AndroidManifest.xml里面包含的信息，比如包名package，versionCode和versionName，启动Activity等。其原始链接和下载地址为：&lt;a href=&quot;https://code.google.com/archive/p/xml-apk-parser/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://code.google.com/archive/p/xml-apk-parser/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:该工具很久没有更新了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;AAPT-aapt&quot;&gt;&lt;a href=&quot;#AAPT-aapt&quot; class=&quot;headerlink&quot; title=&quot;AAPT(aapt)&quot;&gt;&lt;/a&gt;AAPT(aapt)&lt;/h2&gt;&lt;p&gt;Android SDK中自带的appt工具(位于%ANDROID_HOME%\build-tools\%Android version%\aapt.exe,API Level 24及以后版本新增了aapt2,即%ANDROID_HOME%\build-tools\%Android version%\aapt2.exe。其中&lt;code&gt;%ANDROID_HOME%&lt;/code&gt;是Android SDK的安装目录，&lt;code&gt;%Android version%&lt;/code&gt;表示构建版本，完整示例比如&lt;code&gt;&amp;quot;F:\Android\sdk\build-tools\27.0.0\aapt.exe&amp;quot;&lt;/code&gt;)，其实构建APK的过程中，aapt工具起到了非常关键的作用，比如将原始资源等进行编译，生成R.id等。反过来，aapt也可以用于解析APK，包括清单文件AndroidManifest.xml中的信息。appt工具的功能很强大，子命令和参数非常丰富，具体可以进入&lt;code&gt;%ANDROID_HOME%\build-tools\%Android version%&lt;/code&gt;目录，然后在该目录的命令行输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd &lt;code&gt;%ANDROID_HOME%\build-tools\%Android version%&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;appt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可得到下面提示(这里重点说明aapt解析zip,jar,apk的命令使用方式。主要使用到appt的两个&lt;strong&gt;子命令list和dump&lt;/strong&gt;，命令的使用请多实践或查阅命令帮助，这里不详细赘述)：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/KRnIJOi.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;示例1：读取APK的包名(Windows下可以使用findstr对输出信息过滤，linux则是grep。从而对信息进行过滤筛选，比如包名packageName)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aapt list -v -a D:\UserProfiles\CoulsonChen\Desktop\QR.apk | findstr package&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例2：读取APk的packageName、versionCode、applicationLabel、launcherActivity、permission等各种详细信息(可以使用findstr对输出信息过滤，关注某一个具体的内容，比如包名packageName)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aapt dump badging D:\UserProfiles\CoulsonChen\Desktop\QR.apk&lt;br&gt;aapt dump badging D:\UserProfiles\CoulsonChen\Desktop\QR.apk | findstr launchable-activity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过aapt方式解析APK，需要熟悉命令的使用，也比较繁琐。但好处在于可以将其封装进脚本，用于编写自动化工具去解析和执行，这对于构建自动化测试或者自动打包流程等非常有用，而不依赖于GUI。&lt;/p&gt;
&lt;h2 id=&quot;新版Android-studio&quot;&gt;&lt;a href=&quot;#新版Android-studio&quot; class=&quot;headerlink&quot; title=&quot;新版Android studio&quot;&gt;&lt;/a&gt;新版Android studio&lt;/h2&gt;&lt;p&gt;Android studio 2.x版本提供了一个新功能，可以分析APK文件，得到dex的方法数，查看清单文件等。如下图所示：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/hyigywA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Android应用APK逆向解析工具和方法
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="逆向工程" scheme="http://cstsinghua.github.io/categories/Android/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Android" scheme="http://cstsinghua.github.io/tags/Android/"/>
    
      <category term="逆向" scheme="http://cstsinghua.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="apktool" scheme="http://cstsinghua.github.io/tags/apktool/"/>
    
      <category term="AndroidManifest.xml" scheme="http://cstsinghua.github.io/tags/AndroidManifest-xml/"/>
    
      <category term="ClassyShark" scheme="http://cstsinghua.github.io/tags/ClassyShark/"/>
    
      <category term="jadx" scheme="http://cstsinghua.github.io/tags/jadx/"/>
    
      <category term="AXMLPrinter" scheme="http://cstsinghua.github.io/tags/AXMLPrinter/"/>
    
      <category term="reverse engineering" scheme="http://cstsinghua.github.io/tags/reverse-engineering/"/>
    
      <category term="build" scheme="http://cstsinghua.github.io/tags/build/"/>
    
      <category term="aapt" scheme="http://cstsinghua.github.io/tags/aapt/"/>
    
  </entry>
  
  <entry>
    <title>Android 操作系统的内存回收机制</title>
    <link href="http://cstsinghua.github.io/2017/02/09/Android%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/</id>
    <published>2017-02-09T01:58:42.000Z</published>
    <updated>2017-02-09T04:27:59.000Z</updated>
    
    <content type="html">&lt;p&gt;Android 操作系统的内存回收机制&lt;/p&gt;
&lt;p&gt;Android系统是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使应用程序关闭但不退出，并由操作系统进行进程的回收管理。本文在Application Framework与Linux内核两个层次上，以进程为粒度，对Android 操作系统的进程资源回收机制进行了剖析。读者可以从本文获得对Android应用程序的生存周期的进一步理解，从而更加合理、高效地构建应用程序。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Note：本文转载自&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/&lt;/a&gt; ，适当添加批注和修正一些有争议的地方&lt;/strong&gt; &lt;/p&gt;
&lt;h1 id=&quot;Android-APP-的运行环境&quot;&gt;&lt;a href=&quot;#Android-APP-的运行环境&quot; class=&quot;headerlink&quot; title=&quot;Android APP 的运行环境&quot;&gt;&lt;/a&gt;Android APP 的运行环境&lt;/h1&gt;&lt;p&gt;Android 是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使得其进程调度与资源管理与其他平台的Linux有明显的区别。主要包含下面几个层次：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Application Framework&lt;br&gt;Application Framework 将整个操作系统分隔成两个部分。对应用开发者而言，所有APP都是运行在Application Framework之上，而并不需要关心系统底层的情况。Application Framework层为应用开发者提供了丰富的应用编程接口，如Activity Manager，Content Provider，Notification Manager，以及各种窗口Widget资源等。在Application Framework层，Activity是一个APP最基本的组成部分。一般每个 Activity对应于屏幕上的一个视图（或者说一屏），一个APP可以有一个或者多个Activity。应用程序被打包成.apk格式的文件，由Dalvik VM解释执行。&lt;/li&gt;
&lt;li&gt;Dalvik VM(或ART)&lt;br&gt;Dalvik虚拟机采用寄存器架构，而不是JVM的栈结构。Java程序编译后的.class文件并不能在Dalvik中解释执行。因此Google提供了一个 dx 工具，用于将.class文件转换成Dalivk能够识别的.dex格式。具体Dalvik VM的细节不是本文重点，以下不再讨论。&lt;/li&gt;
&lt;li&gt;Linux kernel&lt;br&gt;由上所述，所有的APP都是由Java代码编写并在Dalvik VM中得到解释执行。在Android操作系统中，每个Dalvik VM的每个Instance都对应于 Linux内核中的一个进程。可以使用adb shell工具查看系统中的当前进程。如下图所示，Android2.3.3启动后内核中的进程列表。&lt;br&gt;&lt;strong&gt;图 1. Android 2.3 中的进程列表（部分）&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/1sdyZGk.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图 1 中，UID 标识为 app_xx 的每一项都是一个 app 所占用的进程，可见 Android 设计使得每个应用程序由一个独立的 Dalvik 实例解释执行，而每个 Linux 内核进程加载一个 Dalvik 实例，通过这种方式提供 app 的运行环境。如此，每个 APP 的资源被完全屏蔽，互不干扰。虽然同时引入了进程间通信的困难，但也带来了更强的安全性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Android-内存回收原则&quot;&gt;&lt;a href=&quot;#Android-内存回收原则&quot; class=&quot;headerlink&quot; title=&quot;Android 内存回收原则&quot;&gt;&lt;/a&gt;Android 内存回收原则&lt;/h1&gt;&lt;p&gt;下面将从 Application Framework 和 Linux kernel 两个层次分析 Android 操作系统的资源管理机制。&lt;br&gt;Android 之所以采用特殊的资源管理机制，原因在于其设计之初就是面向移动终端，所有可用的内存仅限于系统 RAM，必须针对这种限制设计相应的优化方案。当 Android 应用程序退出时，并不清理其所占用的内存，Linux 内核进程也相应的继续存在，所谓“退出但不关闭”。从而使得用户调用程序时能够在第一时间得到响应。当系统内存不足时，系统将激活内存回收过程。为了不因内存回收影响用户体验（如杀死当前的活动进程），Android 基于进程中运行的组件及其状态规定了默认的五个回收优先级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMPORTANCE_FOREGROUND:&lt;/li&gt;
&lt;li&gt;IMPORTANCE_VISIBLE:&lt;/li&gt;
&lt;li&gt;IMPORTANCE_SERVICE:&lt;/li&gt;
&lt;li&gt;IMPORTANCE_BACKGROUND:&lt;/li&gt;
&lt;li&gt;IMPORTANCE_EMPTY:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几种优先级的回收顺序是 Empty process、Background process、Service process、Visible process、Foreground process。关于划分原则参见 &lt;a href=&quot;https://developer.android.com/guide/components/processes-and-threads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.android.com/guide/components/processes-and-threads.html&lt;/a&gt; 文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ActivityManagerService&lt;/code&gt;集中管理所有进程的内存资源分配。所有进程需要申请或释放内存之前必须调用&lt;code&gt;ActivityManagerService&lt;/code&gt;对象，获得其“许可”之后才能进行下一步操作，或者&lt;code&gt;ActivityManagerService&lt;/code&gt;将直接“代劳”。类&lt;code&gt;ActivityManagerService&lt;/code&gt;中涉及到内存回收的几个重要的成员方法如下：&lt;code&gt;trimApplications()，updateOomAdjLocked()，activityIdleInternal()&lt;/code&gt;。这几个成员方法主要负责 Android 默认的内存回收机制，&lt;strong&gt;若Linux内核中的内存回收机制没有被禁用，则跳过默认回收（这里其实应该不准确，可以参考updateOomAdjLocked源码进行比对）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;默认回收过程&quot;&gt;&lt;a href=&quot;#默认回收过程&quot; class=&quot;headerlink&quot; title=&quot;默认回收过程&quot;&gt;&lt;/a&gt;默认回收过程&lt;/h2&gt;&lt;p&gt;Android 操作系统中的内存回收可分为两个层次，即默认内存回收与内核级内存回收，本章重点对默认内存回收机制进行研究，Linux 内核层次的内存回收机制将在下一张介绍。 本章所有代码可参见&lt;code&gt;ActivityManagerService.java&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;回收动作入口：activityIdleInternal&quot;&gt;&lt;a href=&quot;#回收动作入口：activityIdleInternal&quot; class=&quot;headerlink&quot; title=&quot;回收动作入口：activityIdleInternal()&quot;&gt;&lt;/a&gt;回收动作入口：activityIdleInternal()&lt;/h3&gt;&lt;p&gt;Android系统中内存回收的触发点大致可分为三种情况。第一，用户程序调用&lt;code&gt;StartActivity()&lt;/code&gt;, 使当前活动的Activity被覆盖；第二，用户按 back 键，退出当前应用程序；第三，启动一个新的应用程序。这些能够触发内存回收的事件最终调用的函数接口就是&lt;code&gt;activityIdleInternal()&lt;/code&gt;。当&lt;code&gt;ActivityManagerService&lt;/code&gt;接收到异步消息&lt;code&gt;IDLE_TIMEOUT_MSG&lt;/code&gt;或者&lt;code&gt;IDLE_NOW_MSG&lt;/code&gt;时，&lt;code&gt;activityIdleInternal()&lt;/code&gt;将会被调用。代码如下：&lt;br&gt;&lt;strong&gt;清单 1. IDLE_NOW_MSG 的处理方式&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case IDLE_NOW_MSG:&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; IBinder token = (Ibinder)msg.obj; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    activityIdle(token, null); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; break;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清单 2. IDLE_TIMEOUT_MSG 的处理方式&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case IDLE_TIMEOUT_MSG: &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (mDidDexOpt) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       mDidDexOpt = false; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Message nmsg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       nmsg.obj = msg.obj; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       mHandler.sendMessageDelayed(nmsg, IDLE_TIMEOUT); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       return; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   IBinder token = (IBinder)msg.obj; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Slog.w(TAG, &amp;quot;Activity idle timeout for &amp;quot; + token); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   activityIdleInternal(token, true, null); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDLE_NOW_MSG&lt;/code&gt;由Activity的切换以及Activiy焦点的改变等事件引发，&lt;code&gt;IDLE_TIMEOUT_MSG&lt;/code&gt;在Activity启动超时的情况下引发，一般这个超时时间设为10s，如果10s之内一个Activity依然没有成功启动，那么将发送异步消息&lt;code&gt;IDLE_TIMEOUT_MSG&lt;/code&gt;进行资源回收。&lt;code&gt;activityIdleInternal()&lt;/code&gt;的主要任务是改变系统中Activity的状态信息，并将其添加到不同状态列表中。其主要工作如下：&lt;/p&gt;
&lt;p&gt;首先，调用&lt;code&gt;scheduleAppGcsLocked()&lt;/code&gt;方法通知所有进行中的任务进行垃圾回收。&lt;code&gt;scheduleAppGcsLocked()&lt;/code&gt;将进行调度JVM的garbage collect，回收一部分内存空间，这里仅仅是通知每个进程自行进程垃圾检查并调度回收时间，而非同步回收。然后，取出&lt;code&gt;mStoppingActivities&lt;/code&gt; 和&lt;code&gt;mFinishigActivities&lt;/code&gt;列表中的所有内容，暂存在临时变量中。这两个列表分别存储了当前状态为stop和finishi的activity 对象。对于 stop 列表，如果其中的activity的finish状态为true，判断是不是要立即停止，如果要立即停止则调用&lt;code&gt;destroyActivityLocked()&lt;/code&gt;通知目标进程调用onDestroy()方法，否则，先调用&lt;code&gt;resumeTopActivity()&lt;/code&gt;运行下一个Activity。如果finish状态为false，则调用 &lt;code&gt;stopActivityLocked()&lt;/code&gt;通知客户进程停止该Activity，这种情况一般发生在调用&lt;code&gt;startActivity()&lt;/code&gt;后。对于finish列表，直接调用 &lt;code&gt;destroyActivityLocked()&lt;/code&gt;通知客户进程销毁目标 Activity。&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;destroyActivityLocked&lt;/code&gt;等函数并没有真正意义上改变内存的使用，只是将其状态改变为“允许回收”，真正的回收在下面即将调用的 &lt;code&gt;trimApplications()&lt;/code&gt;函数中。&lt;/p&gt;
&lt;h3 id=&quot;回收过程函数-trimApplications&quot;&gt;&lt;a href=&quot;#回收过程函数-trimApplications&quot; class=&quot;headerlink&quot; title=&quot;回收过程函数 trimApplications()&quot;&gt;&lt;/a&gt;回收过程函数 trimApplications()&lt;/h3&gt;&lt;p&gt;trimApplications() 函数的结构如下 :&lt;br&gt;&lt;strong&gt;清单 3. trimApplications 函数&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private final void trimApplications() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    synchronized (this) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // First remove any unused application processes whose package &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // has been removed. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (i=mRemovedProcesses.size()-1; i&amp;gt;=0; i--) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           (1)//kill process; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          if (!updateOomAdjLocked()) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           (2)//do something default &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Finally, if there are too many activities now running, try to &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // finish as many as we can to get back down to the limit. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           (3)do something &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;清单3中的三个标序号的位置分别负责如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当程序执行到&lt;code&gt;trimApplications()&lt;/code&gt;之后，首先检查mRemovedProcesses列表中的进程。mRemovedProcesses列表中主要包含了crash的进程、5 秒内没有响应并被用户选在强制关闭的进程、以及应用开发这调用killBackgroundProcess想要杀死的进程。调用Process.killProcess 将所有此类进程全部杀死。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;函数，若成功返回，说明Linux内核支持&lt;code&gt;setOomAdj()&lt;/code&gt;接口，updateOomAdjLocked将修改adj(adjustments)的值并通知 linux内核，内核根据adj值以及内存使用情况动态管理进程资源（lowmemorykiller和oom_killer）。若&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;返回为假，则表示当前系统不支持setOomAdj()接口，将在本地进行默认的资源回收。&lt;/li&gt;
&lt;li&gt;最后，如果当前依然运行了过多的Activity，对多余的Activity进行回收。&lt;code&gt;trimApplications()&lt;/code&gt;的大多数的代码都在处理Oom_killer不存在情况下的默认资源回收，下面对其默认回收过程（即代码清单3中标记(2)的位置）进行进一步分析。其回收过程可大致描述如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤一，获取当前所有运行的进程mLruProcesses，mLruProcesses中的排序规则是按最近使用时间。对mLruProcesses中不能被关闭的进程进行计数，这些不能被关闭的进程包括运行service的进程，运行broadcast receiver的进程等，见如下代码。&lt;br&gt;&lt;strong&gt;清单 4. 计数不能被关闭的进程&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (app.persistent || app.services.size() != 0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            || app.curReceiver != null &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            || app.persistentActivities &amp;gt; 0) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // Don&amp;apos;t count processes holding services against our &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // maximum process count. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numServiceProcs++; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤二， 设当前最大运行进程数&lt;code&gt;curMaxProcs = curMaxProcs + numServiceProcs&lt;/code&gt;（即默认最大进程数与运行Service的进程数之和），如果当前进程的数量&lt;code&gt;mRemovedProcesses.size()&lt;/code&gt;大于这个值，则遍历所有当前运行的进程，杀死符合条件的那些进程并释放内存。清理过程见清单 5（部分代码省略）。从清单5的代码中可以看出，进程被杀死的条件是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须是非 persistent 进程，即非系统进程；&lt;/li&gt;
&lt;li&gt;必须是空进程，即进程中没有任何activity存在。如果杀死存在Activity的进程，有可能关闭用户正在使用的程序，或者使应用程序恢复的时延变大，从而影响用户体验；&lt;/li&gt;
&lt;li&gt;必须无broadcast receiver。运行broadcast receiver一般都在等待一个事件的发生，用户并不希望此类程序被系统强制关闭；&lt;/li&gt;
&lt;li&gt;进程中service的数量必须为0。存在service的进程很有可能在为一个或者多个程序提供某种服务，如GPS定位服务。杀死此类进程将使其他进程无法正常服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上条件缺一不可。&lt;br&gt;&lt;strong&gt;清单 5. 清理过程&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (!app.persistent &amp;amp;&amp;amp; app.activities.size() == 0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;amp;&amp;amp; app.curReceiver == null &amp;amp;&amp;amp; app.services.size() == 0) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       if (app.pid &amp;gt; 0 &amp;amp;&amp;amp; app.pid != MY_PID) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           Process.killProcess(app.pid); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; else &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           try &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               app.thread.scheduleExit(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125; catch (Exception e) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               // Ignore exceptions. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // todo: For now we assume the application is not buggy &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // or evil, and will quit as a result of our request. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // Eventually we need to drive this off of the death &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       // notification, and kill the process if it takes too long. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       cleanUpApplicationRecordLocked(app, false, i); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       i--; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤三，再次检查当前运行的进程，如果&lt;code&gt;mRemovedProcesses.size()&lt;/code&gt;仍然大于curMaxProcs则放宽条件再次进行回收。判断条件见代码清单6（部分代码省略）。下面代码中，布尔变量canQuit的值为真时，那么这个进程可以被回收。canQuit的取值分两个步骤，首先是根据进程的属性赋值。 1. 必须是非persistent进程，即非系统进程；2. 必须无broadcast receiver；3. 进程中service的数量必须为 0；4.persistent类型的activity数量为0。与步骤二唯一的不同在第 4 条，这里不要求进程是空进程，只要进程中没有persistent类型的Activity就可以（Activity 是否是persistent类型在开发阶段指定）。这些条件都满足时，再检查进程中每个Activity的属性，当该进程中所有的Activity都还必须满足三个条件：Activity的状态已经保存，当前处在不可见状态并且Activity已经Stop。这时杀掉进程只会降低下次调用程序时的加载速度，下次启动时将恢复到关闭之前的状态，并不会在用户体验上造成致命的影响，所以，canQuit置位为真。这种情况与步骤二的回收方式也有所不同，由于进程中 Activity的数量不是0，下一步需要对每个activity执行&lt;code&gt;destroyActivityLocked()&lt;/code&gt;销毁，最后才杀死进程。&lt;br&gt;&lt;strong&gt;清单 6. 执行 destroyActivityLocked() 销毁&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;boolean canQuit = !app.persistent &amp;amp;&amp;amp; app.curReceiver == null &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;amp;&amp;amp; app.services.size() == 0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;amp;&amp;amp; app.persistentActivities == 0; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int NUMA = app.activities.size(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (j=0; j&amp;lt;NUMA &amp;amp;&amp;amp; canQuit; j++) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   HistoryRecord r = (HistoryRecord)app.activities.get(j); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   canQuit = (r.haveState || !r.stateNotNeeded) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;amp;&amp;amp; !r.visible &amp;amp;&amp;amp; r.stopped; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (canQuit) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // Finish all of the activities, and then the app itself. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for (j=0; j&amp;lt;NUMA; j++) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       HistoryRecord r = (HistoryRecord)app.activities.get(j); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       if (!r.finishing) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           destroyActivityLocked(r, false); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       r.resultTo = null; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if (app.pid &amp;gt; 0 &amp;amp;&amp;amp; app.pid != MY_PID) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Process.killProcess(app.pid); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   cleanUpApplicationRecordLocked(app, false, i); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   i--; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   //dump(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤四，上面3个过程都是针对整个 process 进行的资源回收。在以上过程执行完毕之后，将在更小的粒度上对Activity的资源进行回收。与上面所述类似，列表mLRUActivities存储了当前所有运行中的Activity，排序规则同样为最少访问原则。&lt;code&gt;mLRUActivities.size()&lt;/code&gt;返回系统中运行的Activity的数量，当其大于MAX_ACTIVITIES（MAX_ACTIVITIES是一个常量，一般值为20，代表系统中最大允许同时存在的Activity时。将回收部分满足条件的Activity以减少内存的使用。回收条件代码清单7所示：&lt;br&gt;&lt;strong&gt;清单 7. 回收条件代码&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Finally, if there are too many activities now running, try to &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// finish as many as we can to get back down to the limit. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (   i=0; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       i&amp;lt;mLRUActivities.size() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;amp;&amp;amp; mLRUActivities.size()  &amp;gt; curMaxActivities; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       i++) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;final HistoryRecord r &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       = (HistoryRecord)mLRUActivities.get(i); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // We can finish this one if we have its icicle saved and &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // it is not persistent. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   if ((r.haveState || !r.stateNotNeeded) &amp;amp;&amp;amp; !r.visible &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;amp;&amp;amp; r.stopped &amp;amp;&amp;amp; !r.persistent &amp;amp;&amp;amp; !r.finishing) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       final int origSize = mLRUActivities.size(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       destroyActivityLocked(r, true); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       if (origSize  &amp;gt; mLRUActivities.size()) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           i--; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里回收的只是Activity的内存资源，并不会杀死进程，也不会影响进程的运行。当进程需要调用被杀掉的Activity时，可以从保存的状态中回复，当然可能需要相对长一点的时延。&lt;/p&gt;
&lt;h2 id=&quot;Linux-内核中的内存回收&quot;&gt;&lt;a href=&quot;#Linux-内核中的内存回收&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核中的内存回收&quot;&gt;&lt;/a&gt;Linux 内核中的内存回收&lt;/h2&gt;&lt;h3 id=&quot;lowmemorykiller&quot;&gt;&lt;a href=&quot;#lowmemorykiller&quot; class=&quot;headerlink&quot; title=&quot;lowmemorykiller&quot;&gt;&lt;/a&gt;lowmemorykiller&lt;/h3&gt;&lt;p&gt;上面提到，&lt;code&gt;trimApplications()&lt;/code&gt;函数中会执行一个叫做&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;的函数，如果返回false，则执行默认回收，若返回true则不执行默认内存回收。updateOomAdjLocked将针对每一个进程更新一个名为adj的变量，并将其告知Linux内核，内核维护一个包含adj的数据结构（即进程表），并通过lowmemorykiller检查系统内存的使用情况，在内存不足的情况下杀死一些进程并释放内存。下面将对这种Android Framework与Linux内核相配合的内存回收机制进行研究。&lt;/p&gt;
&lt;p&gt;由于Android操作系统中的所有应用程序都运行在独立的Dalvik虚拟机环境中，Linux内核无法获知每个进程的运行状态，也就无法为每个进程维护一个合适的adj值，因此，Android Application Framework中必须提供一套机制以动态的更新每个进程的adj。这就是&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;位于ActivityManagerService中，其主要作用是为进程选择一个合适的adj值，并通知 Linux 内核更新这个值。updateOomAdjLocked 首先调用&lt;code&gt;computeOomAdjLocked()&lt;/code&gt;初步计算adj的值，然后回到&lt;code&gt;updateOomAdjLocked()&lt;/code&gt;对其值进行进一步修正。估算流程可参见代码。&lt;/p&gt;
&lt;p&gt;关于adj，其定义在&lt;code&gt;task_struct-&amp;gt;signal_struct-&amp;gt;adj&lt;/code&gt;, 文件 &lt;code&gt;/kernel/include/linux/sched.h&lt;/code&gt;中（其实在Android源码&lt;code&gt;com.android.server.am.ProcessList.java&lt;/code&gt;中有定义，但在Android 7.0及之后，adj的映射值不再是-17~16，具体可以参见源代码）。实质为进程数据结构中的一个变量，用来表示发生Out of Memory时杀死进程的优先级顺序。lowmemorykiller利用这个变量对进程的重要程度进行判断，并在内存不足时释放部分空间，其实现在文件&lt;code&gt;/kernel/drivers/staging/android/lowmemorykiller.c&lt;/code&gt;中。lowmemorykiller定义了两个数组：lowmem_adj和 lowmem_minfree。其中lowmen_adj定义了一系列adj键值，而lowmem_minfree 的每个元素代表一个内存阈值。如下代码中四个阈值分别是 6MB，8MB，16MB 和 64MB，分别代表当内存小于64MB时，adj大于或等于12的那些进程将被杀死并回收，内存小于16MB时，adj大于等于6的那些进程将被杀死并回收，内存小于8MB时，adj大于等于1的那些进程将被杀死并回收，内存小于6MB时，adj大于等于0的所有进程将被杀死并回收。内核中的每个进程都持有一个adj，取值范围-17到15(准确说还是-17~16，只是16这个值用于缓存等特殊情况)，值越小代表进程的重要性越高，回收优先级越低，其中-17代表禁用自动回收。Android 系统中，只有 0-15 被使用。&lt;br&gt;&lt;strong&gt;清单 8. 每个进程都持有一个 adj&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static int lowmem_adj[6] = &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        0, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        1, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        6, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        12, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; static int lowmem_adj_size = 4; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; static size_t lowmem_minfree[6] = &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        3 * 512,      /* 6MB */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        2 * 1024,     /* 8MB */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        4 * 1024,     /* 16MB */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        16 * 1024,    /* 64MB */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; static int lowmem_minfree_size = 4;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;lowmemorykiller注册一个lowmem_shrinker，lowmem_shrinker利用了标准Linux内核中的Cache Shrinker来实现，当空闲内存页面不足时，内核线程kswapd将用已注册的lowmem_shrinker来回收内存页面。&lt;br&gt;&lt;strong&gt;清单 9. 用已注册的 lowmem_shrinker 来回收内存页面&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static struct shrinker lowmem_shrinker = &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .shrink = lowmem_shrink, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .seeks = DEFAULT_SEEKS * 16 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; static int __init lowmem_init(void) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task_free_register(&amp;amp;task_nb); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        register_shrinker(&amp;amp;lowmem_shrinker); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;lowmem_shrink的代码在函数lowmem_shrink中，下面给出该函数的主要结构。lowmem_shrink根据上述规则遍历所有进程，选出需要结束的进程，通过发送一个无法忽略的信号SIGKILL强制结束这些进程&lt;br&gt;&lt;strong&gt;清单 10. 强制结束进程&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static int lowmem_shrink(struct shrinker *s, int nr_to_scan, gfp_t gfp_mask) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for_each_process(p) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           //Select processes to be forced  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (selected) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               force_sig(SIGKILL, selected); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               rem -= selected_tasksize; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rem = -1; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return rem; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Oom-killer&quot;&gt;&lt;a href=&quot;#Oom-killer&quot; class=&quot;headerlink&quot; title=&quot;Oom_killer&quot;&gt;&lt;/a&gt;Oom_killer&lt;/h3&gt;&lt;p&gt;如果上述各种方法都无法释放出足够的内存空间，那么当为新的进程分配应用程序时将发生Out of Memory异常，OOM_killer将尽最后的努力杀掉一些进程来释放空间。Android中的OOM_killer继承自标准Linux 2.6内核，用于分配内存时Out of Memory的处理。Android并没有对其实现方式进行修改。其位置在linux/mm/oom_kill.c。oom_killer遍历进程，并计算所有进程的badness值，选择badness最大的那个进程将其杀掉。函数badness的声明如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsigned long badness(struct task_struct *p, unsigned long uptime)&lt;/code&gt; 函数select_bad_process返回将要杀掉的那个进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清单 11. 返回将要杀掉的进程&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static struct task_struct *select_bad_process(unsigned long *ppoints, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                            struct mem_cgroup *mem) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for_each_process(p) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               points = badness(p, uptime.tv_sec); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               if (points &amp;gt; *ppoints || !chosen) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       chosen = p; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       *ppoints = points; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return chosen; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后，和lowmemorykiller一样，通过发送SIGKILL结束选中的进程。由于oom_killer与标准Linux内核并无不同，这里不再详细研究。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;本文研究了Android操作系统上的内存回收机制。主要包括Application Framework层的默认回收以及Linux内核中的lowmemorykiller、OOM_killer。一般来说应用开发者并不需要控制或者修改系统的内存管理以及回收，但是深入理解这些系统级的管理机制还是必要的，尤其有助于更加合理地设计应用程序，使应用程序的进程在其生命周期内高效地运行。而系统级开发者如果想要对内存管理机制进行优化，对原有机制的理解则是必不可少的重要前提。&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;参考 Android 专题：    &lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/theme/android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android 开发从入门到精通&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;更多有关移动开发方面的内容，请参考&lt;a href=&quot;http://www.ibm.com/developerworks/cn/mobile/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;移动开发&lt;/a&gt;专题。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      Android系统内存管理和回收机制详解
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="内存管理" scheme="http://cstsinghua.github.io/categories/Android/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Android" scheme="http://cstsinghua.github.io/tags/Android/"/>
    
      <category term="内存管理" scheme="http://cstsinghua.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="内存回收" scheme="http://cstsinghua.github.io/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
      <category term="机制" scheme="http://cstsinghua.github.io/tags/%E6%9C%BA%E5%88%B6/"/>
    
      <category term="OS" scheme="http://cstsinghua.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Android热修复技术选型——三大流派解析</title>
    <link href="http://cstsinghua.github.io/2016/12/02/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E2%80%94%E2%80%94%E4%B8%89%E5%A4%A7%E6%B5%81%E6%B4%BE%E8%A7%A3%E6%9E%90/"/>
    <id>http://cstsinghua.github.io/2016/12/02/Android热修复技术选型——三大流派解析/</id>
    <published>2016-12-02T09:15:32.000Z</published>
    <updated>2016-12-02T09:16:52.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是引用引用自淘宝无线开发专家 所为 的文章；原文地址&lt;a href=&quot;https://baichuan.bbs.taobao.com/detail.html?spm=a3c0d.7998981.0.0.hHNK0p&amp;amp;postId=6571722&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://baichuan.bbs.taobao.com/detail.html?spm=a3c0d.7998981.0.0.hHNK0p&amp;amp;postId=6571722&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h1&gt;&lt;h2 id=&quot;一、正常开发流程&quot;&gt;&lt;a href=&quot;#一、正常开发流程&quot; class=&quot;headerlink&quot; title=&quot;一、正常开发流程&quot;&gt;&lt;/a&gt;一、正常开发流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/TFaUUWJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从流程来看，传统的开发流程存在很多弊端：&lt;br&gt;重新发布版本代价太大&lt;br&gt;用户下载安装成本太高&lt;br&gt;BUG修复不及时，用户体验太差&lt;/p&gt;
&lt;h2 id=&quot;二、热修复开发流程&quot;&gt;&lt;a href=&quot;#二、热修复开发流程&quot; class=&quot;headerlink&quot; title=&quot;二、热修复开发流程&quot;&gt;&lt;/a&gt;二、热修复开发流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/xdzxdsf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而热修复的开发流程显得更加灵活，优势很多：&lt;br&gt;无需重新发版，实时高效热修复&lt;br&gt;用户无感知修复，无需下载新的应用，代价小&lt;br&gt;修复成功率高，把损失降到最低&lt;/p&gt;
&lt;h1 id=&quot;业界热门的热修复技术&quot;&gt;&lt;a href=&quot;#业界热门的热修复技术&quot; class=&quot;headerlink&quot; title=&quot;业界热门的热修复技术&quot;&gt;&lt;/a&gt;业界热门的热修复技术&lt;/h1&gt;&lt;p&gt;热修复作为当下热门的技术，在业界内比较著名的有阿里巴巴的AndFix、Dexposed，腾讯QQ空间的超级补丁技术和微信的Tinker。最近阿里百川推出的HotFix热修复服务就基于AndFix技术，定位于线上紧急BUG的即时修复，所以AndFix技术这块我们重点分析阿里百川HotFix。下面，我们就分别介绍QQ空间超级热补丁技术和微信的Tinker以及阿里百川HotFix技术。&lt;/p&gt;
&lt;h2 id=&quot;一、QQ空间超级补丁技术&quot;&gt;&lt;a href=&quot;#一、QQ空间超级补丁技术&quot; class=&quot;headerlink&quot; title=&quot;一、QQ空间超级补丁技术&quot;&gt;&lt;/a&gt;一、QQ空间超级补丁技术&lt;/h2&gt;&lt;p&gt;超级补丁技术基于DEX分包方案，使用了多DEX加载的原理，大致的过程就是：把BUG方法修复以后，放到一个单独的DEX里，插入到dexElements数组的最前面，让虚拟机去加载修复完后的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/IdVuVD4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当patch.dex中包含Test.class时就会优先加载，在后续的DEX中遇到Test.class的话就会直接返回而不去加载，这样就达到了修复的目的。&lt;/p&gt;
&lt;p&gt;但是有一个问题是，当两个调用关系的类不在同一个DEX时，就会产生异常报错。我们知道，在APK安装时，虚拟机需要将classes.dex优化成odex文件，然后才会执行。在这个过程中，会进行类的verify操作，如果调用关系的类都在同一个DEX中的话就会被打上CLASS_ISPREVERIFIED的标志，然后才会写入odex文件。&lt;/p&gt;
&lt;p&gt;所以，为了可以正常的进行打补丁修复，必须避免类被打上CLASS_ISPREVERIFIED标志，具体的做法就是单独放一个类在另外DEX中，让其他类调用。&lt;/p&gt;
&lt;p&gt;我们来逆向手机QQ空间APK看一下具体的实现：&lt;br&gt;先进入程序入口QZoneRealApplication，在attachBaseContext中进行了两步操作：修复CLASS_ISPREVERIFIED标志导致的unexpected DEX problem异常、加载修复的DEX。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB2i5fbaqi5V1BjSspeXXcWPFXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.修复unexpectedDEX problem异常&lt;/p&gt;
&lt;p&gt;  先看代码：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/Tb46ClC.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  可以看到，这里是要加载一个libs目录下的dalvikhack.jar。在项目的assets/libs找到该文件，解压得到classes.dex文件，逆向打开该DEX文件，&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/mbZ8TEL.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  通过不同的DEX加载进来，然后在每一个类的构造方法中引用其他DEX中的唯一类AnitLazyLoad，避免类被打上CLASS_ISPREVERIFIED标志。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/CIbsTKJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  在无修复的情况下，将DO_VERIFY_CLASSES设置为false，提高性能。只有在需要修复的时候，才设置为true。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/eQYKz2a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  至于如何加载进来，与接下来第二个步骤基本相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.加载修复的DEX&lt;/p&gt;
&lt;p&gt;  从loadPatchDex()方法进入，经过几次跳转，到达核心的代码段，SystemClassLoaderInjector.c()。由于进行了混淆和多次方法的跳转，于是将核心代码段做了如下整理：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB2W0i_aqi5V1BjSszgXXbHLpXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  修复的步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以看出是通过获取到当前应用的Classloader，即为BaseDexClassloader&lt;/li&gt;
&lt;li&gt;通过反射获取到他的DexPathList属性对象pathList&lt;/li&gt;
&lt;li&gt;通过反射调用pathList的dexElements方法把patch.dex转化为Element[]&lt;/li&gt;
&lt;li&gt;两个Element[]进行合并，把patch.dex放到最前面去&lt;/li&gt;
&lt;li&gt;加载Element[]，达到修复目的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整体的流程图如下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img.alicdn.com/imgextra/i2/2554813229/TB2qQfaaxvzQeBjSZFxXXXLBpXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  从流程图来看，可以很明显的找到这种方式的特点：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;优势：&lt;/strong&gt;&lt;br&gt;  没有合成整包（和微信Tinker比起来），产物比较小，比较灵活&lt;br&gt;  可以实现类替换，兼容性高。（某些三星手机不起作用）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;不足：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持即时生效，必须通过重启才能生效。&lt;/li&gt;
&lt;li&gt;为了实现修复这个过程，必须在应用中加入两个DEX！dalvikhack.dex中只有一个类，对性能影响不大，但是对于patch.dex来说，修复的类到了一定数量，就需要花不少的时间加载。对手淘这种航母级应用来说，启动耗时增加2s以上是不能够接受的事。&lt;/li&gt;
&lt;li&gt;在ART模式下，如果类修改了结构，就会出现内存错乱的问题。为了解决这个问题，就必须把所有相关的调用类、父类子类等等全部加载到patch.dex中，导致补丁包异常的大，进一步增加应用启动加载的时候，耗时更加严重。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、微信Tinker&quot;&gt;&lt;a href=&quot;#二、微信Tinker&quot; class=&quot;headerlink&quot; title=&quot;二、微信Tinker&quot;&gt;&lt;/a&gt;二、微信Tinker&lt;/h2&gt;&lt;p&gt;微信针对QQ空间超级补丁技术的不足提出了一个提供DEX差量包，整体替换DEX的方案。主要的原理是与QQ空间超级补丁技术基本相同，区别在于不再将patch.dex增加到elements数组中，而是差量的方式给出patch.dex，然后将patch.dex与应用的classes.dex合并，然后整体替换掉旧的DEX，达到修复的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB2Q3S8ap95V1Bjy0FeXXXyfpXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们来逆向微信APK看一下具体的实现：&lt;br&gt;先找到应用入口TinkerApplication，在onBaseContextAttached()调用了loadTinker(),&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2554813229/TB29BS_aqi5V1BjSsphXXaEpXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入TinkerLoader的tryLoad()方法中，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2554813229/TB2h5Taaqm5V1Bjy1zbXXXsBFXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从方法名可以预见，在tryLoadPatchFilesInternal()中尝试加载本地的补丁，再经过跳转进入核心修复功能类SystemClassLoaderAdder.class中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i2/2554813229/TB2dIPaap_AQeBjSZFvXXbnKXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码中可以看出，根据Android版本的不同，分别采取具体的修复操作，不过原理都是一样的。我们以V19为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB2tHbXaqe5V1Bjy1zjXXa08VXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从代码中可以看到，通过反射操作得到PathClassLoader的DexPatchList,反射调用patchlist的makeDexElements()方法吧本地的DEX文件直接替换到Element[]数组中去，达到修复的目的。&lt;br&gt;对于如何进行patch.dex与classes.dex的合并操作，这里微信开启了一个新的进程，开启新进程的服务TinkerPatchService进行合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB24Vjbap_AQeBjSZFBXXX22XXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2554813229/TB2ydjbap95V1Bjy0FlXXaBbXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从流程图来看，同样可以很明显的找到这种方式的特点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;br&gt;合成整包，不用在构造函数插入代码，防止verify，verify和opt在编译期间就已经完成，不会在运行期间进行&lt;br&gt;性能提高。兼容性和稳定性比较高。&lt;br&gt;开发者透明，不需要对包进行额外处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不足：&lt;/strong&gt;&lt;br&gt;与超级补丁技术一样，不支持即时生效，必须通过重启应用的方式才能生效。&lt;br&gt;需要给应用开启新的进程才能进行合并，并且很容易因为内存消耗等原因合并失败。&lt;br&gt;合并时占用额外磁盘空间，对于多DEX的应用来说，如果修改了多个DEX文件，就需要下发多个patch.dex与对应的classes.dex进行合并操作时这种情况会更严重，因此合并过程的失败率也会更高。&lt;/p&gt;
&lt;h2 id=&quot;三、阿里百川HotFix&quot;&gt;&lt;a href=&quot;#三、阿里百川HotFix&quot; class=&quot;headerlink&quot; title=&quot;三、阿里百川HotFix&quot;&gt;&lt;/a&gt;三、阿里百川HotFix&lt;/h2&gt;&lt;p&gt;阿里百川推出的热修复HotFix服务，相对于QQ空间超级补丁技术和微信Tinker来说，定位于紧急bug修复的场景下，能够最及时的修复bug，下拉补丁立即生效无需等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2554813229/TB2ZzS_aqi5V1BjSszdXXXUJXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、AndFix实现原理&lt;br&gt;AndFix不同于QQ空间超级补丁技术和微信Tinker通过增加或替换整个DEX的方案，提供了一种运行时在Native修改Filed指针的方式，实现方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。&lt;br&gt;原理图如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2554813229/TB2rHm7aqi5V1BjSspdXXXyFFXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2、AndFix实现过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于实现方法的替换，需要在Native层操作，经过三个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2554813229/TB2td2aaqm5V1BjSspoXXa8VXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来以Dalvik设备为例，来分析具体的实现过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.1 setup()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i4/2554813229/TB2pqjaap_AQeBjSZPhXXXt5pXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于Dalvik来说，遵循JIT即时编译机制，需要在运行时装载libdvm.so动态库，获取以下内部函数：&lt;br&gt;1） dvmThreadSelf( )：查询当前的线程；&lt;br&gt;2）dvmDecodeIndirectRef()：根据当前线程获得ClassObject对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.2 setFieldFlag&lt;br&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2554813229/TB2pzLaaqm5V1BjSspoXXa8VXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该操作的目的：让private、protected的方法和字段可被动态库看见并识别。原因在于动态库会忽略非public属性的字段和方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.3 replaceMethod&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i2/2554813229/TB2fQjaaqm5V1BjSspoXXa8VXXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;该步骤是方法替换的核心，替换的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB239Dbaqi5V1BjSspiXXXGBFXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;AndFix对ART设备同样支持，具体的过程与Dalvik相似，这里不再赘述。&lt;br&gt;从技术原理，不难看出阿里百川HotFix的几个特点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大的优势在于&lt;/strong&gt;&lt;br&gt;BUG修复的即时性&lt;br&gt;补丁包同样采用差量技术，生成的PATCH体积小&lt;br&gt;对应用无侵入，几乎无性能损耗&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不足：&lt;/strong&gt;&lt;br&gt;不支持新增字段，以及修改方法，也不支持对资源的替换。&lt;br&gt;由于厂商的自定义ROM，对少数机型暂不支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合分析如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/2554813229/TB293jhap55V1Bjy0FoXXbVjFXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;热修复的坑和解&quot;&gt;&lt;a href=&quot;#热修复的坑和解&quot; class=&quot;headerlink&quot; title=&quot;热修复的坑和解&quot;&gt;&lt;/a&gt;热修复的坑和解&lt;/h1&gt;&lt;p&gt;我们可以看到，QQ空间超级补丁技术和微信Tinker的修复原理都基于类加载，在功能上已经支持类、资源的替换和新增，功能非常强大。既然已经有了这么强大的热修复技术，为什么阿里百川还要推出自己的热修复方案HotFix呢？&lt;/p&gt;
&lt;h2 id=&quot;一、多DEX带来的性能问题和影响&quot;&gt;&lt;a href=&quot;#一、多DEX带来的性能问题和影响&quot; class=&quot;headerlink&quot; title=&quot;一、多DEX带来的性能问题和影响&quot;&gt;&lt;/a&gt;一、多DEX带来的性能问题和影响&lt;/h2&gt;&lt;p&gt;我们知道，多DEX方案用来解决应用方法数65k的问题，现在Google也官方支持了MultiDex的实现方案。但是，这实在是应用因方法数超出而作出的不得已的下策，但是超级补丁技术和Tinker作为一种热修复的方案，平生给应用增加了多个DEX，而多DEX技术最大的问题在于性能上的坑，因此基于这种方案的补丁技术影响应用的性能是无疑的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.启动加载时间过长&lt;/p&gt;
&lt;p&gt;  我们可以看到，超级补丁技术和Tinker都选择在Application的attachBaseContext()进行补丁DEX的加载，即使这是加载dex的最佳时机，但是依然会带来很大的性能问题，首当其冲的就是启动时间太长。&lt;/p&gt;
&lt;p&gt;  对于补丁DEX来说，应用启动时虚拟机会进行dexopt操作，将patch.dex文件转换成odex文件，这个过程非常耗时。而这个过程，又要求需要在主线程中，以同步的方式执行，否则无法成功进行修复。就DEX的加载时间，大概做了以下的时间测试。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img.alicdn.com/imgextra/i1/2554813229/TB2EBDcap15V1Bjy1XbXXaNcVXa_!!2-martrix_bbs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  随着patch.dex的增加，在不做任何优化的情况下，启动时间也直线增长。对于一个应用来说，这简直是灾难性的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.易造成应用的ANR和Crash&lt;/p&gt;
&lt;p&gt;  正是尤其多DEX加载导致了启动时间过长，很容易就会引发应用的ANR。我们知道当应用在主线程等待超过5s以后，就会直接导致长时间无响应而退出。超级补丁技术为保证ART不出现地址错乱问题，需要将所有关联的类全部加入到补丁中，而微信Tinker采取一种差量包合并加载的方式，都会使要加载的DEX体积变得很大。这也很大程度上容易导致ANR情况的出现。&lt;/p&gt;
&lt;p&gt;  除了应用ANR以外，多DEX模式也同样很容易导致Crash情况的出现。我们知道，超级补丁技术为了保证ART设备下不出现地址错乱问题，需要把修改类的所有相关类全部加入到补丁中，这里会出现一个问题，为了保证补丁包的体积最小，能否保证引入全部的关联类而不引入无关的类呢？一旦没有引入关联的类，就会出现以下的异常：&lt;br&gt;  NoClassDefFoundError&lt;br&gt;  Could not find class&lt;br&gt;  Could not find method&lt;br&gt;  出现这些异常，就会直接导致应用的Crash退出。&lt;/p&gt;
&lt;p&gt;  所以，不难看出如果我们需要修复一个不是Crash的BUG，但是因为未加入相关类而导致了更严重的Crash，就更加的得不偿失。&lt;/p&gt;
&lt;p&gt;  总的来说，热修复本质的目的是为了保证应用更加稳定，而不是为了更强大的功能引入更大的风险和不稳定性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、热修复-or-插件化？&quot;&gt;&lt;a href=&quot;#二、热修复-or-插件化？&quot; class=&quot;headerlink&quot; title=&quot;二、热修复 or 插件化？&quot;&gt;&lt;/a&gt;二、热修复 or 插件化？&lt;/h2&gt;&lt;p&gt;我们经常提到热修复和插件化，这都是当下热门的新兴技术。在讲述之前，需要对这两个概念进行一下解释。&lt;br&gt;插件化：一个程序划分为不同的部分，以插件的形式加载到应用中去，本质上它使用的技术还是热修复技术，只是加入了更多工程实践，让它支持大规模的代码更新以及资源和SO包的更新。&lt;br&gt;热修复：当线上应用出现紧急BUG，为了避免重新发版，并且保证修复的及时性而进行的一项在线推送补丁的修复方案。&lt;/p&gt;
&lt;p&gt;显然，从概念上我们可以看到，插件化使用场景更多是功能，热修复使用常见在于修复。从这个层面来说，插件化必然功能更加强大，能做的事情也更多。QQ空间超级补丁技术和微信Tinker从类、资源的替换和更新上来看，与其说是热修复，不如说是插件化。&lt;/p&gt;
&lt;p&gt;当然，强大的功能也就增加了不稳定的因素。比如上文提到的增加启动时间，导致ANR、Crash的问题。&lt;/p&gt;
&lt;p&gt;QQ空间超级补丁技术和微信Tinker提供了更加强大的功能，但是对应用的性能和稳定有较大的影响，就BUG修复的这个使用场景上还不够明确，并且显得过重。&lt;/p&gt;
&lt;p&gt;针对应用的性能损耗，我们可以举例做一个对比。某APP的启动载入时间为3s左右，本身就是基于多DEX模式的实现。&lt;br&gt;分别接入三种热修复服务，根据腾讯提供超级补丁技术和Tinker的数据，那么会变成以下的场景：&lt;br&gt;阿里百川HotFix:启动时间几乎无增加，不增加运行期额外的磁盘消耗。&lt;br&gt;QQ空间超级补丁技术：如果应用有700个类，启动耗时增加超过2.5s，达到5.5s以上。&lt;br&gt;微信Tinker：假设应用有5个DEX文件，分别修改了这5个DEX，产生5个patch.dex文件，就要进行5次的patch合并动作，假设每个补丁1M，那么就要多占用7.5M的磁盘空间。&lt;/p&gt;
&lt;p&gt;显然对于修复紧急BUG这个场景，阿里百川HotFix的更为合适，它更加轻量，可以在不重启的情况下生效，且对性能几乎没有影响。微信Tinker、QQ空间超级补丁技术更多地把场景定位在发布小的新功能上，采用ClassLoader的模式，牺牲较高的性能代价去实现类、资源新增或替换的功能。阿里百川HotFix对应用本身做到无侵入，无性能损耗。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;QQ空间超级补丁技术和微信Tinker 支持新增类和资源的替换，在一些功能化的更新上更为强大，但对应用的性能和稳定会有的一定的影响；阿里百川HotFix虽然暂时不支持新增类和资源的替换，对新功能的发布也有所限制，但是作为一项定位为线上紧急BUG的热修复的服务来说，能够真正做到BUG即时修复用户无感知，同时保证对应用性能不产生不必要的损耗，在热修复方面不失为一个好的选择。&lt;/p&gt;
&lt;p&gt;目前阿里百川HotFix已经开始公测，点击立即使用，即可开始你的热修复之旅。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      引用自淘宝无线开发专家 所为 的文章；原文地址https://baichuan.bbs.taobao.com/detail.html?spm=a3c0d.7998981.0.0.hHNK0p&amp;postId=6571722
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="插件化和热修复" scheme="http://cstsinghua.github.io/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Android" scheme="http://cstsinghua.github.io/tags/Android/"/>
    
      <category term="热修复" scheme="http://cstsinghua.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="插件化" scheme="http://cstsinghua.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="HotFix" scheme="http://cstsinghua.github.io/tags/HotFix/"/>
    
      <category term="Tinker" scheme="http://cstsinghua.github.io/tags/Tinker/"/>
    
      <category term="手Qzone" scheme="http://cstsinghua.github.io/tags/%E6%89%8BQzone/"/>
    
      <category term="Andfix" scheme="http://cstsinghua.github.io/tags/Andfix/"/>
    
      <category term="阿里百川" scheme="http://cstsinghua.github.io/tags/%E9%98%BF%E9%87%8C%E7%99%BE%E5%B7%9D/"/>
    
  </entry>
  
  <entry>
    <title>Git命令使用遇到的那些坑</title>
    <link href="http://cstsinghua.github.io/2016/11/17/Git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://cstsinghua.github.io/2016/11/17/Git命令使用遇到的那些坑/</id>
    <published>2016-11-17T03:40:58.000Z</published>
    <updated>2016-11-17T03:41:21.000Z</updated>
    
    <content type="html">&lt;p&gt;Git命令使用遇到的那些坑收集&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Git命令使用遇到的那些坑&quot;&gt;&lt;a href=&quot;#Git命令使用遇到的那些坑&quot; class=&quot;headerlink&quot; title=&quot;Git命令使用遇到的那些坑&quot;&gt;&lt;/a&gt;Git命令使用遇到的那些坑&lt;/h1&gt;&lt;p&gt;Git是一款强大的版本管理工具，网上有很多Git教程，但是很多资料让人一知半解，不得要领。所以，还是阅读Git官方使用教程&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; title=&quot;Git官方教程&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;，或者通过终端git help命令来仔细研究各个命令，然后积累经验,熟能生巧。记住，踩坑是成长的必由之路！&lt;/p&gt;
&lt;h2 id=&quot;配置Git&quot;&gt;&lt;a href=&quot;#配置Git&quot; class=&quot;headerlink&quot; title=&quot;配置Git&quot;&gt;&lt;/a&gt;配置Git&lt;/h2&gt;&lt;p&gt;Git使用一系列配置文件来保存你自定义的行为。 它首先会查找/etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递–system选项给git config，它就会读写该文件。&lt;/p&gt;
&lt;p&gt;接下来Git会查找每个用户的~/.gitconfig文件（或者~/.config/git/config文件）。 你可以传递–global选项让Git读写该文件。&lt;/p&gt;
&lt;p&gt;最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该版本库有效。&lt;/p&gt;
&lt;p&gt;以上三个层次中每层的配置（&lt;strong&gt;系统、全局、本地&lt;/strong&gt;）都会覆盖掉上一层次的配置，所以.git/config 中的值会覆盖掉/etc/gitconfig中所对应的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;   Git的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行&lt;strong&gt;git config&lt;/strong&gt;命令会更简单些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;客户端配置&quot;&gt;&lt;a href=&quot;#客户端配置&quot; class=&quot;headerlink&quot; title=&quot;客户端配置&quot;&gt;&lt;/a&gt;客户端配置&lt;/h3&gt;&lt;p&gt;Git 能够识别的配置项分为两大类：客户端和服务器端。 其中大部分属于客户端配置——可以依你个人的工作偏好进行配置。尽管Git支持的选项 繁多，但其中大部分仅仅在某些罕见的情况下有意义。 我们只讲述最平常和最有用的选项。 如果想得到你当前版本的 Git 支持的选项列表，请运行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ man git-config&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令列出了所有可用的选项，以及与之相关的介绍。 你也可以在 &lt;a href=&quot;http://git-scm.com/docs/git-config.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://git-scm.com/docs/git-config.html&lt;/a&gt; 找到同样的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core.editor&lt;br&gt;默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器，如果没有设置，会调用vi来创建和编辑你的提交以及标签信息。 你可以使用core.editor选项来修改默认的编辑器：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;$ git config –global core.editor emacs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，无论你定义了什么终端编辑器，Git都会调用Emacs编辑信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;  如果是在windows系统下，比如设置编辑器为VS code，可能会遇到各种坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;坑1：&lt;/strong&gt; &lt;code&gt;git config --global core.editor D:\Program Files (x86)\Microsoft VS Code\Code.exe&lt;/code&gt;，此时会报错bash: syntax error near unexpected token `(‘，表明git bash里面不支持(符号，因此得想办法回避这个问题；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;坑2：&lt;/strong&gt;在踩过坑1，可能会&lt;code&gt;git config --global core.editor &amp;quot;D:\Program Files (x86)\Microsoft VS Code\Code.exe&amp;quot;&lt;/code&gt;，即用英文的引号将VS code的路径包裹起来，这样不会确实不会报错了。但是当git commit或其他编辑的时候，报错如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global --edit
D:\Program Files (x86)\Microsoft VS Code\Code.exe: -c: line 0: syntax error near unexpected token `(&amp;apos;
D:\Program Files (x86)\Microsoft VS Code\Code.exe: -c: line 0: `D:\Program Files (x86)\Microsoft VS Code\Code.exe &amp;quot;$@&amp;quot;&amp;apos;
error: There was a problem with the editor &amp;apos;D:\Program Files (x86)\Microsoft VS Code\Code.exe&amp;apos;.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;表明，其实真正在执行的时候还是无法绕过(符号。因此不能直接使用这样的路径。得想其他办法，比如设置上面提到的$VISUAL 或 $EDITOR，将VS Code的路径赋值进去；或者将VS Code的路径添加到PATH环境变量里面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;坑3：&lt;/strong&gt;在坑2的基础上，改用&lt;code&gt;git config --global core.editor code&lt;/code&gt;,然后git commit或其他编辑的时候，VS Code编辑器确实被自动打开了，但是commit的时候却提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit
Aborting commit due to empty commit message.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为git commit的工作原理如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.创建新的编辑器进程；&lt;br&gt;2.将COMMIT_EDITMSG文件传递给这个进程(可阻塞等待进程结束，也可直接返回，这里取决于配置时的参数)；&lt;br&gt;3.读取COMMIT_EDITMSG文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键在第二步，这种情况下，默认是没有等待VS Code进程结束就直接返回，而此时COMMIT_EDITMSG还并没有编辑，所以才是empty commit message，从而导致退出commit操作。&lt;br&gt;此时，我们可以使用&lt;code&gt;git config --global core.editor &amp;quot;code -w&amp;quot;&lt;/code&gt;，-w参数表示阻塞commit并等待VS Code进程结束。这样就成功解决了问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;最后发现，其实也可以直接在全局的.gitconfig文件(可以搜索找到它，一般情况下路径是%HOME%.gitconfig)里面直接编辑如下格式来解决上述问题。请注意必须在路径前后加上转义的引号，即&lt;code&gt;&amp;quot;D:/Program Files (x86)/Microsoft VS Code/Code.exe&amp;quot;&lt;/code&gt;是不行的。&lt;br&gt;     [core]&lt;br&gt;        editor = “\”D:/Program Files (x86)/Microsoft VS Code/Code.exe\””&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      Git命令使用遇到的那些坑
    
    </summary>
    
      <category term="版本控制" scheme="http://cstsinghua.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://cstsinghua.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
      <category term="Git" scheme="http://cstsinghua.github.io/tags/Git/"/>
    
      <category term="命令" scheme="http://cstsinghua.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="坑" scheme="http://cstsinghua.github.io/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="http://cstsinghua.github.io/2016/11/04/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://cstsinghua.github.io/2016/11/04/npm常用命令/</id>
    <published>2016-11-04T03:53:47.000Z</published>
    <updated>2016-11-04T03:53:52.000Z</updated>
    
    <content type="html">&lt;p&gt;npm常用命令介绍&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;npm常用命令&quot;&gt;&lt;a href=&quot;#npm常用命令&quot; class=&quot;headerlink&quot; title=&quot;npm常用命令&quot;&gt;&lt;/a&gt;npm常用命令&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;查看已安装的包&quot;&gt;&lt;a href=&quot;#查看已安装的包&quot; class=&quot;headerlink&quot; title=&quot;查看已安装的包&quot;&gt;&lt;/a&gt;查看已安装的包&lt;/h2&gt;&lt;p&gt;查看当前目录下安装的所有的包：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; npm list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看全局安装的所有的包（-g参数代表全局的意思）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm list -g&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看已经安装的某个包的信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm list package_name [-g]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装包&quot;&gt;&lt;a href=&quot;#安装包&quot; class=&quot;headerlink&quot; title=&quot;安装包&quot;&gt;&lt;/a&gt;安装包&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;npm install [-g] [package_name[@next] [–save]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.后面没有所有参数，即只输入npm install，表示在当前目录下安装当前目录工程)下的package.json的dependencies中指定的包；
1.加上-g代表全局安装，不加则表示在当前目录下安装

2.加上@next表示安装最新版本

3.加上--save表示安装的同时也将包加入到当前路径(工程)下的package.json的dependencies中去，这样以后迁移的时候就可以采用1来安装，比较便捷，可以记录依赖关系。
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;npm install [-g] [package_name[@version] [–save]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1.其他如上，只是这里如果是@version，则表示安装指定版本的包。比如安装TypeScript 2.0,可以使用npm install typescript@2.0.0.
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
</content>
    
    <summary type="html">
    
      npm常用命令介绍
    
    </summary>
    
      <category term="NodeJS" scheme="http://cstsinghua.github.io/categories/NodeJS/"/>
    
      <category term="npm" scheme="http://cstsinghua.github.io/categories/NodeJS/npm/"/>
    
    
      <category term="常用" scheme="http://cstsinghua.github.io/tags/%E5%B8%B8%E7%94%A8/"/>
    
      <category term="NodeJS" scheme="http://cstsinghua.github.io/tags/NodeJS/"/>
    
      <category term="npm" scheme="http://cstsinghua.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Android知识体系及新手如何快速入门</title>
    <link href="http://cstsinghua.github.io/2016/09/12/Android%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%8F%8A%E6%96%B0%E6%89%8B%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://cstsinghua.github.io/2016/09/12/Android知识体系及新手如何快速入门/</id>
    <published>2016-09-12T06:25:13.000Z</published>
    <updated>2016-12-09T02:04:48.000Z</updated>
    
    <content type="html">&lt;p&gt;Android知识体系及新手如何快速入门&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Note：本文摘录自网易梁建 | 网易云音乐安卓主程的一篇文章，稍做修改，仅供参考，其实很多还是比较粗略，后续会在此基础上进一步完善&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android知识体系框架&quot;&gt;&lt;a href=&quot;#Android知识体系框架&quot; class=&quot;headerlink&quot; title=&quot;Android知识体系框架&quot;&gt;&lt;/a&gt;Android知识体系框架&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/rilxPPX.jpg&quot; alt=&quot;Android知识体系框架&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们具体讲一讲各个部分的内容。&lt;/p&gt;
&lt;h2 id=&quot;四大组件&quot;&gt;&lt;a href=&quot;#四大组件&quot; class=&quot;headerlink&quot; title=&quot;四大组件&quot;&gt;&lt;/a&gt;四大组件&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/87qBiad.jpg&quot; alt=&quot;Android四大组件&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;UI设计&quot;&gt;&lt;a href=&quot;#UI设计&quot; class=&quot;headerlink&quot; title=&quot;UI设计&quot;&gt;&lt;/a&gt;UI设计&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/UAuLZ5w.png&quot; alt=&quot;UI设计&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见View的使用&quot;&gt;&lt;a href=&quot;#常见View的使用&quot; class=&quot;headerlink&quot; title=&quot;常见View的使用&quot;&gt;&lt;/a&gt;常见View的使用&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/mKIyZXs.png&quot; alt=&quot;常见View的使用&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GSWbAna.jpg&quot; alt=&quot;网络&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程和进程&quot;&gt;&lt;a href=&quot;#线程和进程&quot; class=&quot;headerlink&quot; title=&quot;线程和进程&quot;&gt;&lt;/a&gt;线程和进程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PZD9chB.png&quot; alt=&quot;线程和进程&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/mh9BKOz.png&quot; alt=&quot;数据存储&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;进阶学习&quot;&gt;&lt;a href=&quot;#进阶学习&quot; class=&quot;headerlink&quot; title=&quot;进阶学习&quot;&gt;&lt;/a&gt;进阶学习&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LZe5RSe.jpg&quot; alt=&quot;进阶学习&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;编程基础&quot;&gt;&lt;a href=&quot;#编程基础&quot; class=&quot;headerlink&quot; title=&quot;编程基础&quot;&gt;&lt;/a&gt;编程基础&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HNM83Yb.png&quot; alt=&quot;编程基础&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/DIDHddu.png&quot; alt=&quot;网络协议&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6iwxXc6.png&quot; alt=&quot;数据库&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;开源框架&quot;&gt;&lt;a href=&quot;#开源框架&quot; class=&quot;headerlink&quot; title=&quot;开源框架&quot;&gt;&lt;/a&gt;开源框架&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/SGi3c7x.png&quot; alt=&quot;开源框架&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试基础&quot;&gt;&lt;a href=&quot;#测试基础&quot; class=&quot;headerlink&quot; title=&quot;测试基础&quot;&gt;&lt;/a&gt;测试基础&lt;/h2&gt;&lt;p&gt;任何一个开发都不能把产品的质量完全依赖于专业的测试人员，相反，应该直接把上行质量作为自测目标。所以，开发人员需要学习必要的测试方法，常见的测试方法包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PJyJh1X.png&quot; alt=&quot;测试基础&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他补充学习&quot;&gt;&lt;a href=&quot;#其他补充学习&quot; class=&quot;headerlink&quot; title=&quot;其他补充学习&quot;&gt;&lt;/a&gt;其他补充学习&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wLazCDp.png&quot; alt=&quot;其他补充学习&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;讲完知识体系，下面讲讲作为一个新人如何快速入门和进阶的一些经验。想要快速入门，可以尝试以下的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;买一本通俗易懂的书籍，快速看完；&lt;/li&gt;
&lt;li&gt;查看并模仿官方samples，这可以让你了解安卓的样子；&lt;/li&gt;
&lt;li&gt;实践一个感兴趣功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;入门之后，进阶可以分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步进阶：系统学习官方training和guide部分，仔细看完获益匪浅&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;第二步进阶：引入开源项目简化开发，并查看源码了解实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;第三步进阶：当你慢慢熟悉开发之后，这个时候你就需要对view的内部世界更加了解，查看常见组件view等内部实现，查看Activity ManagerService, Android进程启动，低内存杀进程等运行机制，学习安卓运行环境，学习各种调优工具进行优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;推荐资料&quot;&gt;&lt;a href=&quot;#推荐资料&quot; class=&quot;headerlink&quot; title=&quot;推荐资料&quot;&gt;&lt;/a&gt;推荐资料&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;历年Google I/O大会视频&lt;br&gt;微信公众号：Google开发者&lt;br&gt;国人整理的学习列表&lt;br&gt;    &lt;a href=&quot;https://github.com/Trinea/android-open-project&quot; title=&quot;主流的Android开源项目&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Trinea/android-open-project&lt;/a&gt;&lt;br&gt;    &lt;a href=&quot;https://github.com/Freelander/Android_Data&quot; title=&quot;Android学习资料&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Freelander/Android_Data&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      Android知识体系及新手如何快速入门
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="学习" scheme="http://cstsinghua.github.io/categories/Android/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="路线图" scheme="http://cstsinghua.github.io/tags/%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    
      <category term="入门" scheme="http://cstsinghua.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="新手" scheme="http://cstsinghua.github.io/tags/%E6%96%B0%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse常用快捷键</title>
    <link href="http://cstsinghua.github.io/2016/07/14/Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://cstsinghua.github.io/2016/07/14/Eclipse常用快捷键/</id>
    <published>2016-07-14T09:30:18.000Z</published>
    <updated>2016-07-14T09:31:04.000Z</updated>
    
    <content type="html">&lt;p&gt;Eclipse常用的快捷键总结&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Eclipse常用快捷键&quot;&gt;&lt;a href=&quot;#Eclipse常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Eclipse常用快捷键&quot;&gt;&lt;/a&gt;Eclipse常用快捷键&lt;/h1&gt;&lt;p&gt;纸上得来终觉浅，绝知此事要躬行！！！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ctrl+D 删除本行；&lt;/li&gt;
&lt;li&gt;Alt+/ 代码提示；&lt;/li&gt;
&lt;li&gt;shift+enter在当前行下面添加空行；&lt;/li&gt;
&lt;li&gt;ctrl+shift+enter在当前行上面添加空行；&lt;/li&gt;
&lt;li&gt;alt+up（down）上移或下移选定行；&lt;/li&gt;
&lt;li&gt;Ctrl+/ 注释或取消注释；&lt;/li&gt;
&lt;li&gt;Ctrl+1 提示和建议；&lt;/li&gt;
&lt;li&gt;Ctrl+alt+up(down) 向上或向下复制选定行；&lt;/li&gt;
&lt;li&gt;End 来到行尾；Home来到行首；&lt;/li&gt;
&lt;li&gt;Ctrl+m 最大化窗口或还原窗口；&lt;/li&gt;
&lt;li&gt;Ctrl+o 方法大纲和搜索方法；&lt;/li&gt;
&lt;li&gt;Ctrl+l 来到指定行号&lt;/li&gt;
&lt;li&gt;Ctrl+e 在多个编辑窗口切换&lt;/li&gt;
&lt;li&gt;Ctrl+shift+o 导入包&lt;/li&gt;
&lt;li&gt;Ctrl+shift+/ 添加块注释&lt;/li&gt;
&lt;li&gt;Ctrl+shift+\ 去除块注释&lt;/li&gt;
&lt;li&gt;Ctrl+Q 定位到最后编辑的地方&lt;/li&gt;
&lt;li&gt;Ctrl+K 参照选中的Word快速定位到下一个&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+X 把当前选中的文本全部变为小写&lt;/li&gt;
&lt;li&gt;Ctrl+Shift+Y 把当前选中的文本全部变为小写&lt;/li&gt;
&lt;li&gt;当光标在一行的两端时，按住shift+home/end可以选择当前行&lt;/li&gt;
&lt;li&gt;ctrl+左右箭头 跳过一个单词&lt;/li&gt;
&lt;li&gt;ctrl+shift+左右是选择一个单词，可以连点左右以选择多个&lt;/li&gt;
&lt;li&gt;shift+上下键！选中光标到上下行！&lt;/li&gt;
&lt;li&gt;列编辑模式 Alt+Shift+A，一般情况下可能与系统其他快捷键冲突，可以修改为其他组合方式；&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      Eclipse常用的快捷键总结
    
    </summary>
    
      <category term="Java" scheme="http://cstsinghua.github.io/categories/Java/"/>
    
      <category term="Tools使用" scheme="http://cstsinghua.github.io/categories/Java/Tools%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="快捷键" scheme="http://cstsinghua.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="Eclipse" scheme="http://cstsinghua.github.io/tags/Eclipse/"/>
    
      <category term="常用" scheme="http://cstsinghua.github.io/tags/%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android studio常用快捷键</title>
    <link href="http://cstsinghua.github.io/2016/07/13/Android-studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://cstsinghua.github.io/2016/07/13/Android-studio常用快捷键/</id>
    <published>2016-07-13T10:07:19.000Z</published>
    <updated>2018-03-02T03:42:50.000Z</updated>
    
    <content type="html">&lt;p&gt;Android studio常用的快捷键&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android-studio常用快捷键总结&quot;&gt;&lt;a href=&quot;#Android-studio常用快捷键总结&quot; class=&quot;headerlink&quot; title=&quot;Android studio常用快捷键总结&quot;&gt;&lt;/a&gt;Android studio常用快捷键总结&lt;/h1&gt;&lt;p&gt;书读百遍，其义自现。同理，快捷键的使用需要孰能生巧。其实Android studio的的settings里面Keymap可以查看所有的快捷键，另外在Android studio的菜单栏，菜单项里面也注明了每项操作的快捷键(如果有)，经常查看和练习，根本也用不着在网上找说明。当然，对于新人或者英文不是太好的初学者，借鉴别人的经验是最快的学习方式。本文暂只适用于Windows平台，Mac环境后续补充。&lt;/p&gt;
&lt;h2 id=&quot;搜索和跳转快捷键&quot;&gt;&lt;a href=&quot;#搜索和跳转快捷键&quot; class=&quot;headerlink&quot; title=&quot;搜索和跳转快捷键&quot;&gt;&lt;/a&gt;搜索和跳转快捷键&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;Eclipse对应的快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+F&lt;/td&gt;
&lt;td&gt;局部查找&lt;/td&gt;
&lt;td&gt;Ctrl+F&lt;/td&gt;
&lt;td&gt;在当前打开的文件中查找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+R&lt;/td&gt;
&lt;td&gt;局部查找替换&lt;/td&gt;
&lt;td&gt;Ctrl+F&lt;/td&gt;
&lt;td&gt;在当前打开的文件中查找替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+shift+F&lt;/td&gt;
&lt;td&gt;全局查找&lt;/td&gt;
&lt;td&gt;Ctrl+H&lt;/td&gt;
&lt;td&gt;在整个工作空间查找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+shift+R&lt;/td&gt;
&lt;td&gt;全局查找替换&lt;/td&gt;
&lt;td&gt;Ctrl+H&lt;/td&gt;
&lt;td&gt;在整个工作空间查找替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+F7&lt;/td&gt;
&lt;td&gt;全局搜索被引用的地方&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+H&lt;/td&gt;
&lt;td&gt;将光标放在任何地方按下alt+f7即可在全局搜索被引用的地方，强大之处不管是文件、字符串、字段、方法、类皆可，AS会智能识别到底是什么东西&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+H&lt;/td&gt;
&lt;td&gt;查看所选择类的继承层级关系&lt;/td&gt;
&lt;td&gt;F4或Ctrl+T&lt;/td&gt;
&lt;td&gt;选择某个类或者类名时按下则会显示出该类的继承层级，从Object到最终子类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+F3&lt;/td&gt;
&lt;td&gt;在当前文件查找所选择的字符出现的地方&lt;/td&gt;
&lt;td&gt;Ctrl+K&lt;/td&gt;
&lt;td&gt;结合F3键使用，先选择某个字符串，然后按下不断Ctrl+F3，则会在文档中该字符串出现的地方来回切换，当到达最后一个出现的地方时，按F3键从头开始搜索，F3键是在已选择字符串后，在出现的地方循环来回切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+A&lt;/td&gt;
&lt;td&gt;可以进到任何你要去的地方(包括配置)&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;可以进到任何你要去的地方(包括配置)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2次点击Shift&lt;/td&gt;
&lt;td&gt;搜索任意内容&lt;/td&gt;
&lt;td&gt;Ctrl+H&lt;/td&gt;
&lt;td&gt;全局搜索任意内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+E&lt;/td&gt;
&lt;td&gt;打开最近操作的文件列表&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;打开最近操作的文件列表，从中可以选择想打开的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Q&lt;/td&gt;
&lt;td&gt;跳转至最近一次编辑位置&lt;/td&gt;
&lt;td&gt;Ctrl+Q&lt;/td&gt;
&lt;td&gt;连续多次按下，可以在最近编辑的历史轨迹中往后回滚&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+Shift+O&lt;/td&gt;
&lt;td&gt;快速高亮显示所选中变量在当前文件中出现的地方&lt;/td&gt;
&lt;td&gt;Alt+Shift+O&lt;/td&gt;
&lt;td&gt;可配合Ctrl+K一起使用，英文释义：Use Alt+Shift+O (Edit、 Find、Highlight Usages in File) to quickly highlight usages of some variable in the current file.Use Ctrl+K and Ctrl+Shift+K keys to navigate through highlighted usages.Press Esc to remove highlighting.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+N&lt;/td&gt;
&lt;td&gt;Go to File，打开文件，在弹框中输入要打开的文件名，会模糊匹配&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;打开文件，在弹框中输入要打开的文件名，会模糊匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + [&lt;/td&gt;
&lt;td&gt;跳至括号开头/结尾&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+P&lt;/td&gt;
&lt;td&gt;反向组合键为Ctrl + ]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;编辑代码的快捷键&quot;&gt;&lt;a href=&quot;#编辑代码的快捷键&quot; class=&quot;headerlink&quot; title=&quot;编辑代码的快捷键&quot;&gt;&lt;/a&gt;编辑代码的快捷键&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;Eclipse对应的快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Y&lt;/td&gt;
&lt;td&gt;删除当前行&lt;/td&gt;
&lt;td&gt;Ctrl+D&lt;/td&gt;
&lt;td&gt;删除当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+D&lt;/td&gt;
&lt;td&gt;复制当前行或语句块&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+down&lt;/td&gt;
&lt;td&gt;复制当前选择行或语句块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+J&lt;/td&gt;
&lt;td&gt;调出IDEA的神器live template&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;调出IDEA的神器live template&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+/&lt;/td&gt;
&lt;td&gt;注释/取消注释&lt;/td&gt;
&lt;td&gt;Ctrl+/&lt;/td&gt;
&lt;td&gt;适用于生成//单行注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+Enter&lt;/td&gt;
&lt;td&gt;调出IDEA对出错点的提示处理方法&lt;/td&gt;
&lt;td&gt;Ctrl+1&lt;/td&gt;
&lt;td&gt;快速找出解决问题的提示或者建议办法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+Insert&lt;/td&gt;
&lt;td&gt;生成构造器方法、setter/getter等模板方法&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;generate setter/getter等等模板方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Alt+L&lt;/td&gt;
&lt;td&gt;格式化代码&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+F&lt;/td&gt;
&lt;td&gt;格式化代码，用于美化代码排版&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Alt+O&lt;/td&gt;
&lt;td&gt;优化导入包&lt;/td&gt;
&lt;td&gt;Ctrl+Shift+O&lt;/td&gt;
&lt;td&gt;优化导入包，即没有导入的包可以自动补上，没有使用到的导入包则会删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+Up/Down&lt;/td&gt;
&lt;td&gt;向上或向下移动当前行&lt;/td&gt;
&lt;td&gt;Alt+Up/Down&lt;/td&gt;
&lt;td&gt;向上或向下移动当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+Shift+Up&lt;/td&gt;
&lt;td&gt;扩展所选区域(extend selection)&lt;/td&gt;
&lt;td&gt;Alt+Shift+Up&lt;/td&gt;
&lt;td&gt;从当前光标位置扩展当前所选区域，一直按住Alt、Shift键，多次点击up键，可以不断扩大所选的区域，此时点击down键则是相反的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Shift+Backspace&lt;/td&gt;
&lt;td&gt;跳转到最近一次编辑的地方，连续多次操作则沿着编辑历史记录回退&lt;/td&gt;
&lt;td&gt;Control+Q&lt;/td&gt;
&lt;td&gt;跳转至最近一次编辑的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;查看代码快捷键&quot;&gt;&lt;a href=&quot;#查看代码快捷键&quot; class=&quot;headerlink&quot; title=&quot;查看代码快捷键&quot;&gt;&lt;/a&gt;查看代码快捷键&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;Eclipse对应的快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Alt+H&lt;/td&gt;
&lt;td&gt;查看方法的调用层级结构&lt;/td&gt;
&lt;td&gt;Ctrl+Alt+H&lt;/td&gt;
&lt;td&gt;查看方法的调用层级结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+F12&lt;/td&gt;
&lt;td&gt;显示当前类的(方法)大纲&lt;/td&gt;
&lt;td&gt;Ctrl+O&lt;/td&gt;
&lt;td&gt;显示一个当前类的(方法)大纲，打开之后通过键盘输入可以自动过滤，这是一个非常高效的方式通过你知道的名称跳到对应的方法上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      Android studio常用的快捷键
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="Tools" scheme="http://cstsinghua.github.io/categories/Android/Tools/"/>
    
    
      <category term="快捷键" scheme="http://cstsinghua.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="Android studio" scheme="http://cstsinghua.github.io/tags/Android-studio/"/>
    
  </entry>
  
  <entry>
    <title>删除Windows下的超长路径目录</title>
    <link href="http://cstsinghua.github.io/2016/07/08/%E5%88%A0%E9%99%A4Windows%E4%B8%8B%E7%9A%84%E8%B6%85%E9%95%BF%E8%B7%AF%E5%BE%84%E7%9B%AE%E5%BD%95/"/>
    <id>http://cstsinghua.github.io/2016/07/08/删除Windows下的超长路径目录/</id>
    <published>2016-07-08T02:28:12.000Z</published>
    <updated>2017-06-12T08:31:49.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;删除超长路径文件或者目录&quot;&gt;&lt;a href=&quot;#删除超长路径文件或者目录&quot; class=&quot;headerlink&quot; title=&quot;删除超长路径文件或者目录&quot;&gt;&lt;/a&gt;删除超长路径文件或者目录&lt;/h1&gt;&lt;p&gt;在Windows操作系统，由于使用目录工具不当或者在使用某些编程工具时生成目录时(比如反复在同一目录下导入同一个工程)常常会产生多层递归模式，导致产生多级超长目录结构，而无法用Windows可视化右键模式进行删除，市面上的很多文件删除工具，如360强力删除、unlocker删除都无济于事，真是一件恼人的事情。&lt;/p&gt;
&lt;p&gt;其实，windows系统自身便带有相关的命令行工具可以用来删除，操作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比如D盘下面如存在D:\blog\node_modules\a\b\c......多层嵌套的目录；&lt;/li&gt;
&lt;li&gt;通过cmd命令行输入&lt;code&gt;cd D:\blog\node_modules&lt;/code&gt;命令进入上述目录(即D:\blog\node_modules)；如下图所示：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/tqS8Mn7.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir tempDir&lt;/code&gt;(上图中已有示例)，该命令在D:\blog\node_modules目录下创建名为tempDir的临时空目录，创建之后临时空目录的路径为D:\blog\node_modules\tempDir；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;robocopy /mir tempDir a&lt;/code&gt;；//&lt;strong&gt;tempDir是步骤3创建的空目录名称，而a则是D:\blog\node_modules\目录下的直接子目录即a&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面执行完毕之后，便可以删除目录了，此时D:\blog\node_modules\a\b\c......就只剩下D:\blog\node_modules，而后面的超长子路径a\b\c......则被删除了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是在某些情况下，执行robocopy命令在中途就可能停止，又不得不重新执行该命令，直到目录完全被删除为止。因此可以写批处理文件来循环操作，当然也可以采用简单的python脚本来执行。&lt;/p&gt;
&lt;h1 id=&quot;采用python脚本循环删除超长目录&quot;&gt;&lt;a href=&quot;#采用python脚本循环删除超长目录&quot; class=&quot;headerlink&quot; title=&quot;采用python脚本循环删除超长目录&quot;&gt;&lt;/a&gt;采用python脚本循环删除超长目录&lt;/h1&gt;&lt;p&gt;示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#-*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.比如无法删除的超长目录为D:\blog\node_modules\a\b\c\...\...；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.执行完毕之后，目录变成D:\blog\node_modules，后面的a\b\c\...\...则会被删除；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.chdir(&lt;span class=&quot;string&quot;&gt;r&quot;D:\blog\node_modules&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.mkdir(&lt;span class=&quot;string&quot;&gt;r&quot;D:\blog\node_modules\tempDir&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#创建临时的空目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = os.system(&lt;span class=&quot;string&quot;&gt;&quot;Robocopy.exe tempDir a /MIR&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(result != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.rmdir(&lt;span class=&quot;string&quot;&gt;r&quot;D:\blog\node_modules\tempDir&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#删除之前创建的临时目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;note：os.system(“Robocopy.exe tempDir a /MIR”)中tempDir是第八行代码创建的空目录名称，而a则是D:\blog\node_modules\目录下的直接子目录即a，实际使用时需要修改成你自己的目录&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      删除Windows系统下的超长路径文件或目录
    
    </summary>
    
      <category term="Python" scheme="http://cstsinghua.github.io/categories/Python/"/>
    
    
      <category term="Windows" scheme="http://cstsinghua.github.io/tags/Windows/"/>
    
      <category term="超长目录" scheme="http://cstsinghua.github.io/tags/%E8%B6%85%E9%95%BF%E7%9B%AE%E5%BD%95/"/>
    
      <category term="删除" scheme="http://cstsinghua.github.io/tags/%E5%88%A0%E9%99%A4/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers使用说明</title>
    <link href="http://cstsinghua.github.io/2016/07/01/Protocol%20Buffers%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://cstsinghua.github.io/2016/07/01/Protocol Buffers使用说明/</id>
    <published>2016-07-01T02:09:43.000Z</published>
    <updated>2016-07-01T02:09:43.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Protocol-Buffers简介&quot;&gt;&lt;a href=&quot;#Protocol-Buffers简介&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers简介&quot;&gt;&lt;/a&gt;Protocol Buffers简介&lt;/h1&gt;&lt;p&gt;Protocol Buffers是一种数据交换格式，用于结构化数据的读写，类似于序列化机制。在线客服系统里面Message的body部分其实就是具有结构化的数据，因此可以采用Protocol Buffers来实现各平台和语言之间的消息传输。Protocol Buffers特点以及与XML、各语言的序列化机制等的比较，可以后续展开，这里不赘述！此处重点说明其如何使用，特别是针对java(Android)平台。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/google/protobuf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/google/protobuf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; https://developers.google.com/protocol-buffers/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Protocol-Buffers的使用&quot;&gt;&lt;a href=&quot;#Protocol-Buffers的使用&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers的使用&quot;&gt;&lt;/a&gt;Protocol Buffers的使用&lt;/h1&gt;&lt;p&gt;Protocol Buffers分为如下几个步骤&lt;/p&gt;
&lt;h2 id=&quot;1-Defining-Your-Protocol-Format-定义数据交换的协议格式&quot;&gt;&lt;a href=&quot;#1-Defining-Your-Protocol-Format-定义数据交换的协议格式&quot; class=&quot;headerlink&quot; title=&quot;1. Defining Your Protocol Format(定义数据交换的协议格式)&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;Defining Your Protocol Format(定义数据交换的协议格式)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;简单来说，就是类似于定义面向对象语言中的类，其相当于一个数据结构，对应用程序中要交换的数据做一个定义，包括各种字段的声明等等。其文件扩展名为.proto。对于.proto文件如何定义和其语法规范，请详细阅读&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot; title=&quot;Protocol Buffer Language Guide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Protocol Buffer Language Guide&lt;/a&gt;。这里是proto3版本(最新版本，建议采用)，proto2的也可以参阅&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;proto2 Language Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.proto示例(addressbook.proto)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//
// Note: START and END tags are used in comments to define sections used in
// tutorials.  They are not part of the syntax for Protocol Buffers.
//
// To get an in-depth walkthrough of this file and the related examples, see:
// https://developers.google.com/protocol-buffers/docs/tutorials

// [START declaration]
syntax = &amp;quot;proto3&amp;quot;;
package tutorial;
// [END declaration]

// [START java_declaration]
option java_package = &amp;quot;com.example.tutorial&amp;quot;;
option java_outer_classname = &amp;quot;AddressBookProtos&amp;quot;;
// [END java_declaration]

// [START csharp_declaration]
option csharp_namespace = &amp;quot;Google.Protobuf.Examples.AddressBook&amp;quot;;
// [END csharp_declaration]

// [START messages]
message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;
}

// Our address book file is just one of these.
message AddressBook {
  repeated Person people = 1;
}
// [END messages]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-Protocol-Compiler-Installation-获取protoc可执行二进制文件&quot;&gt;&lt;a href=&quot;#2-Protocol-Compiler-Installation-获取protoc可执行二进制文件&quot; class=&quot;headerlink&quot; title=&quot;2. Protocol Compiler Installation(获取protoc可执行二进制文件)&quot;&gt;&lt;/a&gt;2. &lt;strong&gt;Protocol Compiler Installation(获取protoc可执行二进制文件)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;可以在Github和其官方地址上看到相关的说明，但是个人觉得其让人不觉明历，通俗来说，这一步就是要生成一个可执行的protoc二进制文件(在windows平台下即protoc.exe)。这里以Windows平台为例说明(后续如无特殊说明，均默认是Windows平台)。建议直接使用Google提供的已经编译好的二进制可执行文件(&lt;a href=&quot;http://repo1.maven.org/maven2/com/google/protobuf/protoc/&quot; title=&quot;protoc可执行二进制文件下载&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://repo1.maven.org/maven2/com/google/protobuf/protoc/&lt;/a&gt;)，建议选择最新版本下载(根据自己操作系统的平台选择对应版本)。想要自己编译生成也可以，不过会遇到各种坑，感兴趣的童鞋可以尝试之&lt;a href=&quot;https://github.com/google/protobuf/releases&quot; title=&quot;下载protocol buffer源码包&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;protocol buffer源码包&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;protoc.exe是干什么的呢？其用来编译用户定义的数据结构即步骤1中编写的.proto文件，详细参见步骤3.&lt;/p&gt;
&lt;h2 id=&quot;3-Compiling-Your-Protocol-Buffers-编译Protocol-Buffers，即编译-proto文件&quot;&gt;&lt;a href=&quot;#3-Compiling-Your-Protocol-Buffers-编译Protocol-Buffers，即编译-proto文件&quot; class=&quot;headerlink&quot; title=&quot;3.  Compiling Your Protocol Buffers(编译Protocol Buffers，即编译.proto文件)&quot;&gt;&lt;/a&gt;3.  &lt;strong&gt;Compiling Your Protocol Buffers(编译Protocol Buffers，即编译.proto文件)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;即用步骤2得到的protoc可执行二进制文件编译步骤1所得的.proto文件，最终生成语言相关的类(代码)。这里以java语言为例：其命令格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\protobuf-3.0.0-beta-2\src&amp;gt;protoc.exe -I=D:\protobuf-3.0.0-beta-2\src --java_out=D:\kefu D:\protob
uf-3.0.0-beta-2\src\boyim.proto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上，进入命令行，protoc即protoc可执行二进制文件，指定$SRC_DIR：源目录 (一般情况下即你的应用程序所在目录 – 如果不提供的话，则默认为当前工作目录即当前命令行的目录)；$DST_DIR：目标目录(你所期望生成的代码存放的目录; 通常情况下与源目录一致)；$SRC_DIR/addressbook.proto：即.proto文件的路径. &lt;/p&gt;
&lt;p&gt;因为这里是生成java类, 因此使用 –java_out 选项 ， 类似的选项可以用于其它支持的语言.&lt;br&gt;对于addressbook.proto示例，这会在目标目录下生成 com/example/tutorial/AddressBookProtos.java文件.可以查看该文件，与普通的javaBean相似，包含了很多setters/getters方法，另外有一个builder方法，用于方便构造类对象。&lt;/p&gt;
&lt;h2 id=&quot;4-Protobuf-Runtime-Installation-生成Protocol-Buffer-API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中&quot;&gt;&lt;a href=&quot;#4-Protobuf-Runtime-Installation-生成Protocol-Buffer-API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中&quot; class=&quot;headerlink&quot; title=&quot;4. Protobuf Runtime Installation(生成Protocol Buffer API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中)&quot;&gt;&lt;/a&gt;4. &lt;strong&gt;Protobuf Runtime Installation(生成Protocol Buffer API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于java语言而言，就是生成一个Protocol Buffer API的jar包，应用里面导入该jar包即可，其他语言类似。那么如何生成这个API库呢？&lt;/p&gt;
&lt;p&gt;官方说明可以参见&lt;a href=&quot;https://github.com/google/protobuf/tree/master/java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Protobuf Runtime Installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里简化说明(建议使用maven来完成安装)：&lt;/p&gt;
&lt;h3 id=&quot;4-1-安装maven-注意需要安装JDK1-7及其以上版本&quot;&gt;&lt;a href=&quot;#4-1-安装maven-注意需要安装JDK1-7及其以上版本&quot; class=&quot;headerlink&quot; title=&quot;4.1 安装maven(注意需要安装JDK1.7及其以上版本)&quot;&gt;&lt;/a&gt;4.1 安装maven(注意需要安装JDK1.7及其以上版本)&lt;/h3&gt;&lt;p&gt;maven下载地址(目前最新版本3.3.9)，&lt;a href=&quot;http://maven.apache.org/&quot; title=&quot;maven下载地址&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://maven.apache.org/&lt;/a&gt;。下载之后解压，然后将解压后得到的目录路径添加到系统path中，这样使得可以直接在命令行使用mvn命令。&lt;/p&gt;
&lt;h3 id=&quot;4-2-下载protocol-buffer源码包&quot;&gt;&lt;a href=&quot;#4-2-下载protocol-buffer源码包&quot; class=&quot;headerlink&quot; title=&quot;4.2 下载protocol buffer源码包&quot;&gt;&lt;/a&gt;4.2 下载protocol buffer源码包&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/protobuf/releases&quot; title=&quot;下载protocol buffer源码包&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;protocol buffer源码包&lt;/a&gt;。注意：这里下载的版本必须与步骤2中protoc可执行二进制文件的版本一致，要查看protoc可执行二进制文件的版本，可以在命令行输入protoc –version。下载之后，解压，找到对应语言目录(java)，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/hqbfZFn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从命令行进入java目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意1：&lt;/strong&gt;步骤2下载二进制可执行文件之后需要将二进制可执行文件改名为protoc.exe(Windows平台)，并且放置在如下目录(下载的protocol buffer源码包解压目录下的src子目录下)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/4Qdnw7s.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意2：&lt;/strong&gt;需要将java目录下的pom.xml(即maven执行所依据的文件，类似于ant构建时候的build.xml)中添加编码格式，否则构建会采用操作系统默认的编码，Windows平台中文的话是GBK，而我们在Android平台采用的是UTF_8。添加部分代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- pom.xml --&amp;gt;
&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/q5WtQgd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-3-Run-the-tests-先测试运行，看看是否配置ok&quot;&gt;&lt;a href=&quot;#4-3-Run-the-tests-先测试运行，看看是否配置ok&quot; class=&quot;headerlink&quot; title=&quot;4.3 Run the tests(先测试运行，看看是否配置ok)&quot;&gt;&lt;/a&gt;4.3 Run the tests(先测试运行，看看是否配置ok)&lt;/h3&gt;&lt;p&gt;在命令输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确保成功再进行下一步。&lt;/p&gt;
&lt;h3 id=&quot;4-4-生成jar包&quot;&gt;&lt;a href=&quot;#4-4-生成jar包&quot; class=&quot;headerlink&quot; title=&quot;4.4 生成jar包&quot;&gt;&lt;/a&gt;4.4 生成jar包&lt;/h3&gt;&lt;p&gt;在命令输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的jar包放置在java目录的子目录target下面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/dLL5Os3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-Parsing-and-Serialization-解析和序列化&quot;&gt;&lt;a href=&quot;#5-Parsing-and-Serialization-解析和序列化&quot; class=&quot;headerlink&quot; title=&quot;5. Parsing and Serialization(解析和序列化)&quot;&gt;&lt;/a&gt;5. &lt;strong&gt;Parsing and Serialization(解析和序列化)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;这一步也就是最终我们在应用程序里面对数据进行解析读写等直观的操作，也是我们最关心的部分。&lt;/p&gt;
&lt;p&gt;将步骤3生成的java类复制进工程中(注意必须在其定义的包名结构下)，同时将步骤4生成的jar导入到工程中。&lt;/p&gt;
&lt;p&gt;对于步骤3生成的类，利用 protocol buffer的二进制格式，每个类均具有所选择类型的写和读消息功能。即可以进行解析和序列化操作。这里列举几个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes.

static Type(定义的类，比如步骤1中的Person) parseFrom(byte[] data);: parses a message from the given byte array.

void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream.

static Type(定义的类，比如步骤1中的Person) parseFrom(InputStream input);: reads and parses a message from an InputStream.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事实上，每个类包含有大量的解析和序列化的方法。 请参照&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Message&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Message API reference&lt;/a&gt;进行详细查阅。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      非典型程序员
    
    </summary>
    
      <category term="Java" scheme="http://cstsinghua.github.io/categories/Java/"/>
    
    
      <category term="Protocol Buffers" scheme="http://cstsinghua.github.io/tags/Protocol-Buffers/"/>
    
  </entry>
  
  <entry>
    <title>Github pages+Hexo+Nodejs搭建个人blog</title>
    <link href="http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/"/>
    <id>http://cstsinghua.github.io/2016/06/16/Github pages+Hexo+Nodejs搭建个人blog/</id>
    <published>2016-06-16T10:35:07.000Z</published>
    <updated>2016-07-04T08:38:36.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为一个IT技术人员，自然离不开技术的积累，而技术的积累则通过文档或代码的形式呈现出来。好记性不如烂笔头，程序员应该乐于并擅于记录总结工作中遇到的各种问题、工作成果、奇思异想和感悟等。&lt;/p&gt;
&lt;p&gt;程序员的世界是孤独的，但也是充满激情和阳光的。正是开源精神点亮了这一切。生命中最美丽的报偿之一便是帮助他人的同时，也帮助了自己 ─ 罗夫‧瓦尔多‧爱默生 &lt;/p&gt;
&lt;p&gt;因此，将个人的经验和感悟与他人分享，成就的不仅仅是个人，更可以帮助其他人少走弯路。那么就开始分享的旅程吧！&lt;/p&gt;
&lt;h1 id=&quot;传统的笔记或者blog平台&quot;&gt;&lt;a href=&quot;#传统的笔记或者blog平台&quot; class=&quot;headerlink&quot; title=&quot;传统的笔记或者blog平台&quot;&gt;&lt;/a&gt;传统的笔记或者blog平台&lt;/h1&gt;&lt;p&gt;在本地可以用各种文档格式保存自己的技术积累，也可以采用一些市面上的blog平台作为载体来存储自己的技术文章，但这类方式存在一些弊端，这点你可以打开你的脑洞，想想有哪些，本人不是来挑起舌战的。&lt;/p&gt;
&lt;h1 id=&quot;Github-pages-Hexo-Nodejs搭建个人blog&quot;&gt;&lt;a href=&quot;#Github-pages-Hexo-Nodejs搭建个人blog&quot; class=&quot;headerlink&quot; title=&quot;Github pages+Hexo+Nodejs搭建个人blog&quot;&gt;&lt;/a&gt;Github pages+Hexo+Nodejs搭建个人blog&lt;/h1&gt;&lt;p&gt;好处和缺点这里就暂不提了，请自行google。(本文仅仅是提供一种搭建Blog的方式，不牵涉任何利益方！！！)&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装git：&lt;a href=&quot;https://git-scm.com&quot; title=&quot;git下载&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git下载&lt;/a&gt;，注意：Windows平台需要下载对应的安装exe,安装之后后续的命令行操作需要在GitShell中打开而非Windows默认的命令行。不过，建议直接下载&lt;a href=&quot;https://desktop.github.com/&quot; title=&quot;Github桌面版&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github windows客户端&lt;/a&gt;，安装的时候会创建GitShell(正是下文提及的GitShell)和GitHub GUI工具。&lt;/li&gt;
&lt;li&gt;安装nodejs：&lt;a href=&quot;https://nodejs.org&quot; title=&quot;nodejs官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js官网&lt;/a&gt;，注意：请根据自己主机的平台下载对应版本。&lt;/li&gt;
&lt;li&gt;安装hexo及部署：&lt;a href=&quot;https://hexo.io/&quot; title=&quot;hexo官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo官网&lt;/a&gt;，注意：安装 Hexo 相当简单。然而在安装前，您必须确保先完成步骤1和2。Hexo网站可以选择语言为简体中文，方便使用。查看其中的文档可以看到hexo的详细使用说明，so easy！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重点阐述下步骤3的过程(hexo的详细信息可参加&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot; title=&quot;hexo说明文档&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo说明文档&lt;/a&gt;)：&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;p&gt;在Gitshell(已经安装了git并且将git加入到path环境变量中)输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ npm install -g hexo-cli&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;建站&quot;&gt;&lt;a href=&quot;#建站&quot; class=&quot;headerlink&quot; title=&quot;建站&quot;&gt;&lt;/a&gt;建站&lt;/h2&gt;&lt;p&gt;安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹(自行选定的文件夹folder)中新建所需要的文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ hexo init folder&lt;br&gt;$ cd folder&lt;br&gt;$ npm install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建完成后，指定文件夹的目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br&gt;网站的 配置 信息，您可以在此配置大部分的参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;package.json&lt;/strong&gt;&lt;br&gt;应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &quot;name&quot;: &quot;hexo-site&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &quot;version&quot;: &quot;0.0.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &quot;private&quot;: true,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &quot;hexo&quot;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;version&quot;: &quot;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;dependencies&quot;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo&quot;: &quot;^3.0.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&quot;hexo-server&quot;: &quot;^0.1.2&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;scaffolds&lt;/strong&gt;&lt;br&gt;模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;source&lt;/strong&gt;&lt;br&gt;资源文件夹是存放用户资源的地方。除 &lt;em&gt;posts 文件夹之外，开头命名为 &lt;/em&gt; (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;themes&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://hexo.io/docs/themes.html&quot; title=&quot;hexo主题&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主题&lt;/a&gt; 文件夹。Hexo 会根据主题来生成静态页面。&lt;/p&gt;
&lt;h2 id=&quot;本地启动server&quot;&gt;&lt;a href=&quot;#本地启动server&quot; class=&quot;headerlink&quot; title=&quot;本地启动server&quot;&gt;&lt;/a&gt;本地启动server&lt;/h2&gt;&lt;p&gt;该步骤可以检验安装是否ok。如果能成功，那么恭喜你离成功更近一步了。&lt;/p&gt;
&lt;p&gt;在Gitshell中进入前面指定的folder(建立的站点的根目录)，输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ hexo server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以观察命令行的输出，然后通过浏览器打开&lt;a href=&quot;http://localhost:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000/&lt;/a&gt;，成功的情况下则会看到默认的欢迎页面。&lt;/p&gt;
&lt;h2 id=&quot;部署到github-pages&quot;&gt;&lt;a href=&quot;#部署到github-pages&quot; class=&quot;headerlink&quot; title=&quot;部署到github pages&quot;&gt;&lt;/a&gt;部署到github pages&lt;/h2&gt;&lt;p&gt;(&lt;a href=&quot;https://help.github.com/categories/github-pages-basics/&quot; title=&quot;github pages介绍&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击了解Github Pages&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ hexo deploy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开始之前，您必须先在站点的配置文件_config.yml(前面建立的folder目录下)中修改参数，一个正确的部署配置中至少要有 type 参数，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	type: git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	repo:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	type: heroku&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	repo:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里重点提及部署到Github pages的方法(步骤)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.首先在Github上面创建一个新的Repository，仓库命名格式为yourname.github.io，注意：yourname是你自己定义的一个名称，后面的github.io是统一的，格式一定需要符合这个样式。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;b.然后，配置文件_config.yml&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repository: git@github.com:your_github_account/yourname.github.io.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  message: [message]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;repo&lt;/td&gt;
&lt;td&gt;库（Repository）地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;branch&lt;/td&gt;
&lt;td&gt;分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;自定义提交信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;eg(我的Github账号是cstsinghua，而我新建的仓库名称是cstsinghua.github.io):&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repository: git@github.com:cstsinghua/cstsinghua.github.io.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：如果是建立项目网站，则branch需要修改为gh-pages，详细情况请参见&lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github pages中User, Organization, and Project Pages的差异&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.安装hexo的git插件&lt;a href=&quot;https://github.com/hexojs/hexo-deployer-git&quot; title=&quot;hexo的git插件&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-deployer-git&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ npm install hexo-deployer-git –save&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;d.部署前面建立的站点(folder下面的内容)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行完，开始部署，即先hexo generate，然后hexo deploy。也可以一步到位：hexo d -g&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  $ hexo clean&lt;br&gt;    $ hexo generate&lt;br&gt;    $ hexo deploy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ hexo d -g&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：在这一步可能报错，已知的一些错误可以参见&lt;a href=&quot;https://hexo.io/zh-cn/docs/troubleshooting.html#Git-部署问题&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo git部署常见问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，可能遇到SSH publickey接入问题，可以参见&lt;a href=&quot;https://help.github.com/articles/generating-an-ssh-key/&quot; title=&quot;创建github ssh key&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创建github SSH key&lt;/a&gt;和&lt;a href=&quot;https://github.com/settings/keys&quot; title=&quot;github SSH key管理&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github SSH key管理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;optional-重绑定域名&quot;&gt;&lt;a href=&quot;#optional-重绑定域名&quot; class=&quot;headerlink&quot; title=&quot;(optional)重绑定域名&quot;&gt;&lt;/a&gt;(optional)重绑定域名&lt;/h2&gt;&lt;p&gt;Custom domain redirects for GitHub Pages sites(将独立(个性)域名与GitHub Pages的空间域名绑定)&lt;/p&gt;
&lt;p&gt;yourname.github.io的域名格式比较固定，那么是否可以设置一个个性化的域名呢，另外需要注意的是Github pages的容量受限于github的要求，目前是1GB(请参见&lt;a href=&quot;https://help.github.com/articles/what-are-github-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://help.github.com/articles/what-are-github-pages/&lt;/a&gt;)。因此，建立一个独立的个性化(blog)网站(域名是个性化独立的，容量也可以调整)，在某些情况下还是有必要的(请参见&lt;a href=&quot;https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/&quot; title=&quot;github pages域名重定向&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github pages域名重定向&lt;/a&gt;)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Github pages 设置：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如cstsinghua.me。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DNS设置：注册DNSpod，添加域名，不是必要的步骤，但是据说可以提高解析效率。本人没有测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在域名服务商，如net.cn中修改增加两条A记录，指向github pages 提供的 ip&lt;br&gt;  192.30.252.153&lt;br&gt;  192.30.252.154&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;推广&quot;&gt;&lt;a href=&quot;#推广&quot; class=&quot;headerlink&quot; title=&quot;推广&quot;&gt;&lt;/a&gt;推广&lt;/h2&gt;&lt;p&gt;一旦成功创建属于自己的blog，当然是想与他人分享，让小伙伴们都可以搜索到或者浏览自己的成果。很不幸的是，采用本文方式创建的blog默认情况下只会静静躺在互联网的一个角落，google或者百度等搜索引擎是无法知晓它的存在。因此，我们必须采用一些方式来推广自己的blog，让其他人能够通过Google或者百度等搜索引擎搜索到我们blog。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先验证博客是否被搜索引擎收录&lt;/p&gt;
&lt;p&gt;  在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的cstsinghua.github.io&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;site:cstsinghua.github.io&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  如下图：&lt;br&gt;  &lt;img src=&quot;http://i.imgur.com/gVZSKWY.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  如果已被搜索引擎收录，那恭喜你，可以不用看后面的内容了。你的blog已经在互联网上飘香四溢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在google和百度的站长管理平台验证并添加blog地址&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://www.google.com/webmasters/tools/home?hl=zh-CN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google站长管理平台地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;http://zhanzhang.baidu.com/linksubmit/url&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度站长管理平台地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  这里以Google为例(百度的类似)：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;1.&lt;/strong&gt;登录google站长管理平台，在首页中点击”添加属性”按钮，然后将你的blog地址填写并添加，如下图所示：&lt;br&gt;  &lt;img src=&quot;http://i.imgur.com/7Xp2CIP.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;  &lt;strong&gt;2.&lt;/strong&gt;blog网址添加完成之后，会跳转到验证所有权页面，验证方式有很多种，可以根据自己的情况选择，这里选择推荐的方法，即上传HTML文件的方式，其步骤在跳转的页面写得很清楚，按部就班地操作就行了(&lt;strong&gt;注意：先点击下载页面提示的HTML文件，报错&lt;/strong&gt;)。如下图所示：&lt;br&gt;  &lt;img src=&quot;http://i.imgur.com/tz37dOJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/UvrvykY.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;3.&lt;/strong&gt;生成并提交站点地图(sitemap.xml)&lt;br&gt;  站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。&lt;/p&gt;
&lt;p&gt;  怎么生成blog网站的站点地图呢？方式有很多种，hexo本身也自带了生成站点地图的插件。我们要先安装插件，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install hexo-generator-sitemap –save&lt;/p&gt;
&lt;p&gt;npm install hexo-generator-baidu-sitemap –save&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  在blog根目录的配置文件_config.yml中添加如下代码&lt;/p&gt;
  &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sitemap:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;path: sitemap.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baidusitemap:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;path: baidusitemap.xml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  然后，修改blog根目录的配置文件_config.yml中url参数为你blog的地址，比如我的是这样：&lt;/p&gt;
  &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# URL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url: https://cstsinghua.github.io/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  此时，可以重新生成你的blog&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo g&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  如果你在你的blog根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了。当然可以采用其他很多方式来生成sitemap.xml，网上也有很多在线工具或者提供下载的本地GUI工具来生成，可以参见&lt;a href=&quot;https://code.google.com/archive/p/sitemap-generators/wikis/SitemapGenerators.wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://code.google.com/archive/p/sitemap-generators/wikis/SitemapGenerators.wiki&lt;/a&gt;，里面提供了非常多的链接地址，本人使用过&lt;a href=&quot;https://xmlsitemapgenerator.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://xmlsitemapgenerator.org&lt;/a&gt;在线生成过。&lt;/p&gt;
&lt;p&gt;  最后，将生成的sitemap.xml提交到google站长管理平台，如下图所示：&lt;br&gt;  &lt;img src=&quot;http://i.imgur.com/T0ur897.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  蓝色表示sitem.xml里面上传的网页数，橙色表示已经被google加入索引(收录)的网页数，一旦被收录，这个时候就可以在google上面搜索到blog了！关于细节可以点击google站长页面上的帮助进行了解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为一个IT技术人员，自然离不开技术的积累，而技术的积累则通过文档或代码的形式呈现出来。好记性不如烂笔头，程序员应该乐于并擅于记录总结工作中
    
    </summary>
    
      <category term="杂项" scheme="http://cstsinghua.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="搭建个人Blog" scheme="http://cstsinghua.github.io/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BABlog/"/>
    
  </entry>
  
  <entry>
    <title>Zxing二维码开源库实战</title>
    <link href="http://cstsinghua.github.io/2016/06/13/ZXing%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://cstsinghua.github.io/2016/06/13/ZXing开源项目实战/</id>
    <published>2016-06-13T07:42:25.000Z</published>
    <updated>2016-12-07T06:56:56.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Zxing二维码开源库学习和优化&quot;&gt;&lt;a href=&quot;#Zxing二维码开源库学习和优化&quot; class=&quot;headerlink&quot; title=&quot;Zxing二维码开源库学习和优化&quot;&gt;&lt;/a&gt;Zxing二维码开源库学习和优化&lt;/h1&gt;&lt;p&gt;  本文对Google官方开源的二维码扫描库ZXing做一个总体概述，然后进行Android开发环境下的实战(二次)开发和优化，并用于生产项目。&lt;br&gt;  ZXing开源项目官方地址:&lt;a href=&quot;https://github.com/zxing/zxing&quot; title=&quot;ZXing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zxing/zxing&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前期学习和准备&quot;&gt;&lt;a href=&quot;#前期学习和准备&quot; class=&quot;headerlink&quot; title=&quot;前期学习和准备&quot;&gt;&lt;/a&gt;前期学习和准备&lt;/h2&gt;&lt;p&gt; 各种百度和google，先了解二维码的技术概念和原理，他人经验和文章等等。以下摘自百度百科：&lt;/p&gt;
&lt;p&gt; 国外对二维码技术的研究始于20世纪80年代末，在二维码符号表示技术研究方面已研制出多种码制，常见的有PDF417、QR Code、Code 49、Code 16K、Code One等。这些二维码的信息密度都比传统的一维码有了较大提高，如PDF417的信息密度是一维码CodeC39的20多倍。在二维码标准化研究方面，国际自动识别制造商协会（AIM）、美国标准化协会（ANSI）已完成了PDF417、QR Code、Code 49、Code 16K、Code One等码制的符号标准。国际标准技术委员会和国际电工委员会还成立了条码自动识别技术委员会（ISO/IEC/JTC1/SC31），已制定了QR Code的国际标准（ISO/IEC 18004：2000《自动识别与数据采集技术—条码符号技术规范—QR码》），起草了PDF417、Code 16K、Data Matrix、Maxi Code等二维码的ISO/IEC标准草案。在二维码设备开发研制、生产方面，美国、日本等国的设备制造商生产的识读设备、符号生成设备，已广泛应用于各类二维码应用系统。二维码作为一种全新的信息存储、传递和识别技术，自诞生之日起就得到了世界上许多国家的关注。美国、德国、日本等国家，不仅已将二维码技术应用于公安、外交、军事等部门对各类证件的管理，而且也将二维码应用于海关、税务等部门对各类报表和票据的管理，商业、交通运输等部门对商品及货物运输的管理、邮政部门对邮政包裹的管理、工业生产领域对工业生产线的自动化管理。&lt;/p&gt;
&lt;p&gt; 我国对二维码技术的研究开始于1993年。中国物品编码中心对几种常用的二维码PDF417、QRCCode、Data Matrix、Maxi Code、Code 49、Code 16K、Code One的技术规范进行了翻译和跟踪研究。随着我国市场经济的不断完善和信息技术的迅速发展，国内对二维码这一新技术的需求与日俱增。中国物品编码中心在原国家质量技术监督局和国家有关部门的大力支持下，对二维码技术的研究不断深入。在消化国外相关技术资料的基础上，制定了两个二维码的国家标准：二维码网格矩阵码（SJ/T 11349-2006）和二维码紧密矩阵码（SJ/T 11350-2006），从而大大促进了我国具有自主知识产权技术的二维码的研发。&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h2&gt;&lt;h3 id=&quot;1-下载ZXing并选择包&quot;&gt;&lt;a href=&quot;#1-下载ZXing并选择包&quot; class=&quot;headerlink&quot; title=&quot;1. 下载ZXing并选择包&quot;&gt;&lt;/a&gt;1. 下载ZXing并选择包&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;截止本文攥写之时，ZXing的最新版本为3.2.1，在Github网站上下载ZXing的主分支（zxing-master.zip），解压完成之后，目录树如下：&lt;br&gt;&lt;img src=&quot;http://172.20.154.39:8080/GodSDKBackground/ZXing-dirTree.png&quot; alt=&quot;ZXing项目解压的目录层次&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下对解压的目录结构(包含模块)的主要部分做一个概述(此处以3.2.1版本基准，不同的版本包含的模块可能稍有差异，请留意)：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;android&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Android client Barcode Scanner,中文意为“条形扫码器”，下文简称BS。可作为独立的扫码APP使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;android-core&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Android-related code shared among android, androidtest, glass，即android、androidtest和glass三个模块共享的android相关库，当前其实就是一个相机配置工具类(CameraConfigurationUtils.java).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;android-integration&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Supports integration with Barcode Scanner via Intent，即通过Intent的方式提供一种便捷的途径将BS整合到用户的APP中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;androidtest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Android test app, ZXing Test，即模拟调用方app(相当于用户APP的角色)，通过android-integration整合Barcode Scanner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;core&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  The core image decoding library, and test code.即核心的图片编解码库，整个条形码的核心处理库，另外还包括测试代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;glass    &lt;/p&gt;
&lt;p&gt;  Simple Google Glass application&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;zxingorg&lt;/p&gt;
&lt;p&gt;  The source behind zxing.org&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;zxing.appspot.com&lt;/p&gt;
&lt;p&gt;  The source behind web-based barcode generator at zxing.appspot.com&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;javase&lt;/p&gt;
&lt;p&gt;  JavaSE-specific client code&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，与开发Android二维码扫码相关的模块有android、android-core、android-integration、androidtest和core模块。&lt;/p&gt;
&lt;p&gt;androidtest、android-integration、android三个模块的关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ON8GvPu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-试用并厘清ZXing项目的源码&quot;&gt;&lt;a href=&quot;#2-试用并厘清ZXing项目的源码&quot; class=&quot;headerlink&quot; title=&quot;2.试用并厘清ZXing项目的源码&quot;&gt;&lt;/a&gt;2.试用并厘清ZXing项目的源码&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;试用：&lt;/p&gt;
&lt;p&gt;  用Eclipse导入(按照导入现有Android工程的方式)上面所述的androidtest模块，导入之后，源代码部分会报错。主要有以下两种错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于ZXing项目编写者采用的java编译版本不低于1.7.0，因此如果你的Eclipse的java编译版本设置为1.6.0或者更低版本时，将会报错，比如new ArrayList&amp;lt;&amp;gt;(),在1.6.0版本则不能省略具体的泛型类型，应该为new ArrayList&lt;yourclass&gt;()；&lt;/yourclass&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引用了大量core模块、android-integration和android-core的类，因此需要将core模块的jar包(当然也可以直接copy源码)添加到工程的构建路径(core包的下载地址:&lt;a href=&quot;http://repo1.maven.org/maven2/com/google/zxing/core/&quot; title=&quot;ZXing的core包&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://repo1.maven.org/maven2/com/google/zxing/core/&lt;/a&gt;)，另外需要将android-integration和android-core的源码复制到工程中(新建对应的package，copy类)；&lt;/p&gt;
&lt;p&gt;按照上面步骤处理完之后，则可以运行的测试APP诞生了。工程目录图如下：&lt;br&gt;&lt;img src=&quot;http://172.20.154.39:8080/GodSDKBackground/barcode_test_project.png&quot; alt=&quot;ZXing试用工程目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;运行并安装APK至手机或模拟器，测试APP界面如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://172.20.154.39:8080/GodSDKBackground/barcode_test_app.png&quot; alt=&quot;ZXing试用工程目录&quot;&gt;    &lt;/p&gt;
&lt;p&gt;可以体验扫码和生成二维码的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;源码分析&lt;/p&gt;
&lt;p&gt;  其实这里要关注的源码主要有四部分：core、android、android-integration和android-core，其中android-integration和android-core较为简单，这里不再赘述。而core涉及图片处理和二维码的理论技术，暂不做深入研究。&lt;/p&gt;
&lt;p&gt;  android模块即BS，可以作为单独APP使用，是一个功能强大的条码扫描器，不仅支持多种类型的条码，还支持多国语言，分享二维码，查看扫描历史，反向扫描等功能。&lt;/p&gt;
&lt;p&gt;  因此，这里主要就android模块进行分析阐述。导入Eclipse之后，android模块的包结构图如下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://172.20.154.39:8080/GodSDKBackground/barcode_BS_Hierarchy.png&quot; alt=&quot;BS包结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;  如上图所示，BS主要包括下列组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;android：与CaptureActivity直接相关的核心组件。包含了发生震动管理器，闪光灯等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;book：如果查询的结果是图书信息，用户可以选择查询该书的更进一步的详细信息，该包即包含了搜索与展示书籍的相关类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;camera/camera.open：摄像头相关组件，核心类是CameraManager&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;clipboard：剪贴板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;encode：编码功能的各个组件集合。核心类为QRCodeEncoder，最终实施编码的是MultiFormatWriter类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;history：扫描历史管理，核心类是HistoryManager&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;result：条码扫描的结果被分为不同的类型，所有的类型都定义在com.google.zxing.client.result.ParsedResultType中，对于不同的类型都有对应的处理方法：xxxResultHandler，所有的ResultHandler都包含在此包中。不同的xxxResultHandler还提供了扫描结果页面要展示几个button，每个button的文本以及需要绑定的事件等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;result.supplement：对已经扫描并解码的结果做额外处理的工具集。比如扫描出来的是isbn号，如果在设置中选择了“检索更多信息”则会在扫描出isbn号之后自动去网上查询该书的信息，最后将书的信息展示出来，而如果没选中，则只会将isbn号码展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;share：分享二维码功能，亦是编码功能的入口所在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;wifi：是WifiResultHandler的辅助类集合。如果扫描到的二维码是对wifi信息的编码，那么最终扫描结果页会展示一个“连接到网络”的按钮，点击此按钮就会自动尝试连接。该包中所包含的类则是链接网络所需的工具类。&lt;/p&gt;
&lt;p&gt;打开BS，即进入扫描界面时，BS大致做了如下的事情：配置Camera并启动Camera、构建preview与扫描窗口、捕捉画面并解码、将解码结果交给不同ResultHandler去处理。下面逐一进行分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置Camera并启动Camera&lt;/p&gt;
&lt;p&gt; 启动Camera是在CaptureActivity.initCamera中进行的，最重要的几句代码是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cameraManager.openDriver(surfaceHolder);
// Creating the handler starts the preview, which can also throw a
// RuntimeException.
if (handler == null) {
    handler = new CaptureActivityHandler(this, decodeFormats,
            decodeHints, characterSet, cameraManager);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; CameraManager是相机管理类，是BS中唯一与Camera打交道的类，CameraManager.openDriver主要做了三件事：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Opens the camera driver and initializes the hardware parameters.
 * 
 * @param holder
 *            The surface object which the camera will draw preview frames
 *            into.
 * @throws IOException
 *             Indicates the camera driver failed to open.
 */
public synchronized void openDriver(SurfaceHolder holder)
        throws IOException {
    Camera theCamera = camera;
    if (theCamera == null) {
        // 1. 获取手机背面的摄像头
        theCamera = OpenCameraInterface.open(requestedCameraId);
        if (theCamera == null) {
            throw new IOException();
        }
        camera = theCamera;
    }
    // 2. 设置摄像头预览view
    theCamera.setPreviewDisplay(holder);

    if (!initialized) {
        initialized = true;
        configManager.initFromCameraParameters(theCamera);
        if (requestedFramingRectWidth &amp;gt; 0 &amp;amp;&amp;amp; requestedFramingRectHeight &amp;gt; 0) {
            setManualFramingRect(requestedFramingRectWidth,
                    requestedFramingRectHeight);
            requestedFramingRectWidth = 0;
            requestedFramingRectHeight = 0;
        }
    }

    Camera.Parameters parameters = theCamera.getParameters();
    String parametersFlattened = parameters == null ? null : parameters
            .flatten(); // Save these, temporarily
    try {
        // 3. 读取配置并设置相机参数
        configManager.setDesiredCameraParameters(theCamera, false);
    } catch (RuntimeException re) {
        // Driver failed
        Log.w(TAG,
                &amp;quot;Camera rejected parameters. Setting only minimal safe-mode parameters&amp;quot;);
        Log.i(TAG, &amp;quot;Resetting to saved camera params: &amp;quot;
                + parametersFlattened);
        // Reset:
        if (parametersFlattened != null) {
            parameters = theCamera.getParameters();
            parameters.unflatten(parametersFlattened);
            try {
                theCamera.setParameters(parameters);
                configManager.setDesiredCameraParameters(theCamera, true);
            } catch (RuntimeException re2) {
                // Well, darn. Give up
                Log.w(TAG,
                        &amp;quot;Camera rejected even safe-mode parameters! No configuration&amp;quot;);
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; CameraConfigurationManager是相机辅助类，主要用于设置相机的各类参数。核心方法有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;initFromCameraParameters：计算了屏幕分辨率和当前最适合的相机像素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setDesiredCameraParameters：读取配置设置相机的对焦模式、闪光灯模式等等&lt;/p&gt;
&lt;p&gt;CaptureActivityHandler类是一个针对扫描任务的Handler，可接收的message有启动扫描（restart_preview）、扫描成功（decode_succeeded）、扫描失败（decode_failed）等等。&lt;/p&gt;
&lt;p&gt;在创建一个CaptureActivityHandler对象的时候也做了三件事：&lt;/p&gt;
&lt;p&gt;  CaptureActivityHandler(CaptureActivity activity,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;           Collection&amp;lt;BarcodeFormat&amp;gt; decodeFormats,
           Map&amp;lt;DecodeHintType,?&amp;gt; baseHints,
           String characterSet,
           CameraManager cameraManager) {
  this.activity = activity;
  // 1. 启动扫描线程
  decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
      new ViewfinderResultPointCallback(activity.getViewfinderView()));
  decodeThread.start();
  state = State.SUCCESS;

  // Start ourselves capturing previews and decoding.
  this.cameraManager = cameraManager;
  // 2. 开启相机预览界面
  cameraManager.startPreview();
  // 3. 将preview回调函数与decodeHandler绑定、调用viewfinderView
  restartPreviewAndDecode();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;restartPreviewAndDecode方法又调用了CameraManager.requestPreviewFrame：&lt;/p&gt;
&lt;p&gt;  /**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single preview frame will be returned to the handler supplied. The data&lt;/li&gt;
&lt;li&gt;will arrive as byte[] in the message.obj field, with width and height&lt;/li&gt;
&lt;li&gt;&lt;p&gt;encoded as message.arg1 and message.arg2, respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1：将handler与preview回调函数绑定；&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2：注册preview回调函数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;综上，该函数的作用是当相机的预览界面准备就绪后就会调用hander向其发送传入的message&lt;/li&gt;
&lt;li&gt;@param handler&lt;/li&gt;
&lt;li&gt;The handler to send the message to.&lt;/li&gt;
&lt;li&gt;@param message&lt;/li&gt;
&lt;li&gt;The what field of the message to be sent.&lt;br&gt;*/&lt;br&gt;public synchronized void requestPreviewFrame(Handler handler, int message) {&lt;br&gt;Camera theCamera = camera;&lt;br&gt;if (theCamera != null &amp;amp;&amp;amp; previewing) {&lt;br&gt;previewCallback.setHandler(handler, message);&lt;br&gt;/ 绑定相机回调函数，当预览界面准备就绪后会回调Camera.PreviewCallback.onPreviewFrame&lt;br&gt;theCamera.setOneShotPreviewCallback(previewCallback);&lt;br&gt;}&lt;br&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;2. 构建preview与扫描窗口

    首先相机有自己的preview界面，然后我们需要构造一个扫描窗口，引导用户将条码置于窗口中完成扫描。

    构造扫描窗口是在CaptureActivityHandler.restartPreviewAndDecode中，通过调用activity.drawViewfinder()来实现的。这里有个画扫描窗口的类叫ViewfinderView，该类也是想要改变扫描窗口风格所必须重构的一个类。

    重构ViewfinderView涉及Android的高级话题：自定义View及其属性，这里暂不赘述。

    相机的preview界面显示出来后即可开始扫描，所以需要监听preview是否已经显示这个事件，这就是Camera.PreviewCallback的作用。PreviewCallback.onPreviewFrame做的事便是当preview界面展示出来的时候向DecodeHandler发送一个decode消息，DecodeHandler收到该消息后会执行decode方法来解码。

    注意，检测并触发捕获画面动作的，是Camera.setOneShotPreviewCallback()这个方法。该函数被调用后，如果预览界面已经打开，就会将包含当前preview frame的byte数组传给回调函数，此时再向DecodeHandler发送decode消息。

3. 捕捉画面并解码

    具体参考DecodeHandler.decode方法。（本文只从宏观上对zxing进行分析，对于解码的原理暂不做介绍）

4. 将解码结果交给不同ResultHandler去处理

    当DecodeHandler.decode完成解码后会向CaptureActivityHandler发消息。如果编码成功则调用CaptureActivity.handleDecode方法对扫描到的结果进行分类处理。

    该方法中首先获取ResultHandler：

        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(
                this, rawResult);
    然后调用handleDecodeInternally和handleDecodeExternally对ResultHandler进行处理。谈到这两个方法，就不得不再分析一下    IntentSource。

        enum IntentSource {

          /**
           * 本地app向BS(Barcode Scanner)发起的启动指令
           * 比如在androidtest项目中，利用整合的android-integration对BS发起调用指令：com.google.zxing.client.android.SCAN
           * BS中该启动命令对应的Source类型便是NATIVE_APP_INTENT
           */
            NATIVE_APP_INTENT,

          /**
           * 打开BS的时候传入查询商品的url，与最终扫描到的product id结合进行查询
           * 两种url的形式不同
           */
          PRODUCT_SEARCH_LINK,
          ZXING_LINK,

          /**
           * 直接打开BS
           */
          NONE

        }

    结合CaptureActivity.onResume中的部分代码来理解：

        else if (dataString != null
                    &amp;amp;&amp;amp; dataString.contains(&amp;quot;http://www.google&amp;quot;)
                    &amp;amp;&amp;amp; dataString.contains(&amp;quot;/m/products/scan&amp;quot;)) {

                // Scan only products and send the result to mobile Product
                // Search.
                source = IntentSource.PRODUCT_SEARCH_LINK;
                sourceUrl = dataString;
                decodeFormats = DecodeFormatManager.PRODUCT_FORMATS;

        } else if (isZXingURL(dataString)) {

            // Scan formats requested in query string (all formats if none
            // specified).
            // If a return URL is specified, send the results there.
            // Otherwise, handle it ourselves.
            source = IntentSource.ZXING_LINK;
            sourceUrl = dataString;
            Uri inputUri = Uri.parse(dataString);
            scanFromWebPageManager = new ScanFromWebPageManager(inputUri);
            decodeFormats = DecodeFormatManager
                    .parseDecodeFormats(inputUri);
            // Allow a sub-set of the hints to be specified by the caller.
            decodeHints = DecodeHintManager.parseDecodeHints(inputUri);

        }

    NATIVE_APP_INTENT和NONE很好理解，而PRODUCT_SEARCH_LINK和ZXING_LINK是指定查询商品的url（而不是交给zxing分析后再决定去哪里查询），将扫描出来的内容拼凑到url中，然后在浏览器中展示结果。

    理解了IntentSource，就容易看懂handleDecodeInternally其实就是将结果展示到界面上。handleDecodeExternally稍复杂些，当source == IntentSource.NATIVE_APP_INTENT时，BS会将扫描分析的结果存到Intent中返回给调用方app，因此调用方app在启动BS的时候一定要使用startActivityForResult。这一点可以在androidtest的IntentIntegrator.initiateScan方法的最后看到。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-BS优化&quot;&gt;&lt;a href=&quot;#3-BS优化&quot; class=&quot;headerlink&quot; title=&quot;3.BS优化&quot;&gt;&lt;/a&gt;3.BS优化&lt;/h3&gt;&lt;p&gt;BS可直接作为独立APP运行，但是项目中的很多功能我们并不需要，而且扫描的界面为横向，因此进行相关优化。接下来，我们在BS项目工程基础上，直接修改其中代码或者xml文件，达到修改扫码界面为竖屏且美化扫码界面的目的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改BS默认的横屏为竖屏&lt;/p&gt;
&lt;p&gt;针对ZXing3.2.1版本，这里一共需要6步，需要提醒的是：不同的ZXing版本需要的步骤可能有差异，因为里面的源代码逻辑有修改。因此，有的时候尽信书不如无书，本文的步骤可能仅适合ZXing3.2.1，如果在ZXing其他版本上完成以下六步无法实现竖屏，或者修改之后会出错，请仔细排查(可以断点调试跟踪)。其实，要实现竖屏，从原理上应该是共通的，主要包括Activity本身的方向(属性)设置，同时关联到相机的参数(如预览窗口)调整等方面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：调整CaptureActivity的方向为竖屏显示&lt;/p&gt;
&lt;p&gt;   修改工程的AndroidManifest.xml,CaptureActivity的android:screenOrientation属性，设置为portrait&lt;/p&gt;
   &lt;!-- 调整扫描activity为竖屏,step1.调整activity的方向为竖屏 --&gt;
   &lt;activity android:name=&quot;.CaptureActivity&quot; android:cleartaskonlaunch=&quot;true&quot; android:screenorientation=&quot;portrait&quot; android:statenotneeded=&quot;true&quot; android:theme=&quot;@style/CaptureTheme&quot; android:windowsoftinputmode=&quot;stateAlwaysHidden&quot;&gt;
&lt;/activity&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二步：调整相机预览界面方向&lt;/p&gt;
&lt;p&gt;   在 CameraConfigurationManager.setDesiredCameraParameters 的最后(或第一行也可)增加如下代码：&lt;br&gt;   //调整扫描activity为竖屏,step2.调整相机预览界面方向&lt;br&gt;   camera.setDisplayOrientation(90);&lt;br&gt;   注意：调整相机preview的时钟方向与手机竖屏的自然方向一致。该方法必须在相机的startPreview之前被调用，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在预览界面展示出来后设置是无效的。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三步：调整扫描窗口尺寸&lt;/p&gt;
&lt;p&gt;   修改 CameraManager.getFramingRectInPreview()方法中的部分代码：&lt;br&gt;   原代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rect.left = rect.left * cameraResolution.x / screenResolution.x;
rect.right = rect.right * cameraResolution.x / screenResolution.x;
rect.top = rect.top * cameraResolution.y / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
framingRectInPreview = rect;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   修改后代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 调整扫描activity为竖屏,step3.调整扫描窗口尺寸
 * 由于修改了屏幕的初始方向，手机分辨率由原来的 width\*height 变为 height\*width
 * 形式，但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
 */
rect.left = rect.left * cameraResolution.y / screenResolution.x;
rect.right = rect.right * cameraResolution.y / screenResolution.x;
rect.top = rect.top * cameraResolution.x / screenResolution.y;
rect.bottom = rect.bottom * cameraResolution.x / screenResolution.y;
framingRectInPreview = rect;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   原因：由于修改了屏幕的初始方向，手机分辨率由原来的 width*height 变为 height*width 形式，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第四步：将扫描框设置为正方形&lt;/p&gt;
&lt;p&gt;   修改 CameraManager.getFramingRect()方法中的部分代码：&lt;br&gt;   原代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int width = findDesiredDimensionInRange(screenResolution.x,
        MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = findDesiredDimensionInRange(screenResolution.y,
        MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
Log.d(TAG,&amp;quot;screenResolution.x:&amp;quot;+screenResolution.x+&amp;quot;,screenResolution.y:&amp;quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &amp;quot;Calculated framing rect: &amp;quot; + framingRect);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   修改后代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
  * 调整扫描activity为竖屏,step4.将扫描框设置为正方形
 */
//后面设置height = width的前提下，如x&amp;gt;y时可能会导致topOffset为负值，因此需要对此进行修正，加入下面这行代码
int resolutionMin = Math.min(screenResolution.x, screenResolution.y);
int width = findDesiredDimensionInRange(resolutionMin,
MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);

int height = width;//宽度等于高度，即为正方形
Log.d(TAG,&amp;quot;screenResolution.x:&amp;quot;+screenResolution.x+&amp;quot;,screenResolution.y:&amp;quot;+screenResolution.y);
int leftOffset = (screenResolution.x - width) / 2;
int topOffset = (screenResolution.y - height) / 2;
framingRect = new Rect(leftOffset, topOffset, leftOffset + width,
        topOffset + height);
Log.d(TAG, &amp;quot;Calculated framing rect: &amp;quot; + framingRect);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第五步：反转扫描到的图形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;修改 DecodeHandler.decode 方法，增加以下代码：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   private void decode(byte[] data, int width, int height) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long start = System.currentTimeMillis();
Result rawResult = null;

/*
 * 调整扫描activity为竖屏,step5.反转扫描到的图形
 */
// 新增反转数据代码开始
byte[] rotatedData = new byte[data.length];
for (int y = 0; y &amp;lt; height; y++) {
    for (int x = 0; x &amp;lt; width; x++)
        rotatedData[x * height + height - y - 1] = data[x + y * width];
}
int tmp = width;
width = height;
height = tmp;
// 新增代码结束

PlanarYUVLuminanceSource source = activity.getCameraManager()
        .buildLuminanceSource(rotatedData, width, height);
//...后续代码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第六步：(关键)修改CaptureActivity的onresume方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;完成以上五步后，在ZXing的某些版本上应该是可以实现竖屏了，但是在3.2.1版本上，由于在CaptureActivity
的onresume方法里面涉及到了修改activity的方向，因此需要针对性修改这部分代码。
原代码段为：
   if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
   true)) {
       setRequestedOrientation(getCurrentOrientation());
   } else {
       setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   修改后代码段为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION,
true)) {
    setRequestedOrientation(getCurrentOrientation());
} else {
    // setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   同时，需要修改getCurrentOrientation方法：&lt;br&gt;   原方法为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
    default:
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   修改后为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private int getCurrentOrientation() {
    int rotation = getWindowManager().getDefaultDisplay().getRotation();
    switch (rotation) {
    case Surface.ROTATION_0:
    case Surface.ROTATION_90:
        // return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
    default:
        // return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
        return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;美化扫描界面&lt;/p&gt;
&lt;p&gt;原生的扫描界面比较朴素，如果需要做出更漂亮些的扫描界面，就必须重写ViewfinderView类(res/layout/capture.xml布局中使用该类作为扫描窗口界面)。这里，我们为了实现类微信或支付宝的扫描界面效果，在将扫码界面修改为竖屏的基础上，可以做如下修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在ViewfinderView类添加变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 四个边角对应的宽度
 */
 private static final int CORNER_WIDTH = 8;

/**
 * 四个边角对应的长度
 */
private int ScreenRate;

/**
 * 手机的屏幕密度
 */
private static float density;

/**
 * 四个边角的颜色
 */
private final int cornerColor;

/**
 * 扫描框中的中间线的宽度
 */
private static final int MIDDLE_LINE_WIDTH = 2;

/**
 * 扫描框中的中间线的与扫描框左右的间隙
 */
private static final int MIDDLE_LINE_PADDING = 10;

/**
 * 中间那条线每次刷新移动的距离
 */
private static final int SPEEN_DISTANCE = 5;

/**
 * 中间滑动线的最顶端位置
 */
private int slideTop;

/**
 * 中间滑动线的最底端位置
 */
private int slideBottom;

boolean isFirst;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改ViewfinderView类的构造方法和onDraw方法。注：对于Android自定义View，绘制的核心就是onDraw方法。&lt;/p&gt;
&lt;p&gt; a.在构造方法中添加初始化或设置变量的值：&lt;/p&gt;
&lt;p&gt;   // This constructor is used when the class is built from an XML resource.&lt;br&gt;   public ViewfinderView(Context context, AttributeSet attrs) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super(context, attrs);

// Initialize these once for performance rather than calling them every
// time in onDraw().
paint = new Paint(Paint.ANTI_ALIAS_FLAG);
Resources resources = getResources();
maskColor = resources.getColor(R.color.viewfinder_mask);
resultColor = resources.getColor(R.color.result_view);
laserColor = resources.getColor(R.color.viewfinder_laser);

//设置添加的变量值--start
cornerColor = Color.GREEN;
density = context.getResources().getDisplayMetrics().density;  
//将像素转换成dp  
ScreenRate = (int)(20 * density);  
//设置添加的变量值--end

resultPointColor = resources.getColor(R.color.possible_result_points);
scannerAlpha = 0;
possibleResultPoints = new ArrayList&amp;lt;&amp;gt;(5);
lastPossibleResultPoints = null;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;b.修改onDraw方法中部分代码：&lt;/p&gt;
&lt;p&gt;修改前代码段：&lt;/p&gt;
&lt;p&gt;   if (resultBitmap != null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Draw the opaque result bitmap over the scanning rectangle
paint.setAlpha(CURRENT_POINT_OPACITY);
canvas.drawBitmap(resultBitmap, null, frame, paint);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   } else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Draw a red &amp;quot;laser scanner&amp;quot; line through the middle to show
// decoding is active
paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&amp;lt;ResultPoint&amp;gt; currentPossible = possibleResultPoints;
List&amp;lt;ResultPoint&amp;gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&amp;lt;&amp;gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

// Request another update at the animation interval, but only
// repaint the laser line,
// not the entire viewfinder mask.
postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
        frame.top - POINT_SIZE, frame.right + POINT_SIZE,
        frame.bottom + POINT_SIZE);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;修改后代码段：&lt;/p&gt;
&lt;p&gt;   if (resultBitmap != null) {&lt;br&gt;   // Draw the opaque result bitmap over the scanning rectangle&lt;br&gt;   paint.setAlpha(CURRENT_POINT_OPACITY);&lt;br&gt;   canvas.drawBitmap(resultBitmap, null, frame, paint);&lt;br&gt;   } else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Draw a red &amp;quot;laser scanner&amp;quot; line through the middle to show
// decoding is active
/*paint.setColor(laserColor);
paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);
scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;
int middle = frame.height() / 2 + frame.top;
canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1,
        middle + 2, paint);*/

float scaleX = frame.width() / (float) previewFrame.width();
float scaleY = frame.height() / (float) previewFrame.height();

List&amp;lt;ResultPoint&amp;gt; currentPossible = possibleResultPoints;
List&amp;lt;ResultPoint&amp;gt; currentLast = lastPossibleResultPoints;
int frameLeft = frame.left;
int frameTop = frame.top;
if (currentPossible.isEmpty()) {
    lastPossibleResultPoints = null;
} else {
    possibleResultPoints = new ArrayList&amp;lt;&amp;gt;(5);
    lastPossibleResultPoints = currentPossible;
    paint.setAlpha(CURRENT_POINT_OPACITY);
    paint.setColor(resultPointColor);
    synchronized (currentPossible) {
        for (ResultPoint point : currentPossible) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), POINT_SIZE,
                    paint);
        }
    }
}
if (currentLast != null) {
    paint.setAlpha(CURRENT_POINT_OPACITY / 2);
    paint.setColor(resultPointColor);
    synchronized (currentLast) {
        float radius = POINT_SIZE / 2.0f;
        for (ResultPoint point : currentLast) {
            canvas.drawCircle(frameLeft
                    + (int) (point.getX() * scaleX), frameTop
                    + (int) (point.getY() * scaleY), radius, paint);
        }
    }
}

/*
 * 如下为了优化扫描框，绘制边角
 */
paint.setColor(cornerColor);
canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
        frame.top + CORNER_WIDTH, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right,
        frame.top + ScreenRate, paint);
canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
        + ScreenRate, frame.bottom, paint);
canvas.drawRect(frame.left, frame.bottom - ScreenRate, frame.left
        + CORNER_WIDTH, frame.bottom, paint);
canvas.drawRect(frame.right - ScreenRate, frame.bottom
        - CORNER_WIDTH, frame.right, frame.bottom, paint);
canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom
        - ScreenRate, frame.right, frame.bottom, paint);

/*
 * 如下绘制中间上下滚动的横线
 */
//初始化中间线滑动的最上边和最下边
if(!isFirst){
    isFirst = true;
    slideTop = frame.top;
    slideBottom = frame.bottom;
}

//绘制中间的线,每次刷新界面，中间的线往下移动SPEEN_DISTANCE
slideTop += SPEEN_DISTANCE;
if(slideTop &amp;gt;= frame.bottom){
    slideTop = frame.top;
}
canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
            frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;            // Request another update at the animation interval, but only
            // repaint the laser line,
            // not the entire viewfinder mask.
            postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE,
                    frame.top - POINT_SIZE, frame.right + POINT_SIZE,
                    frame.bottom + POINT_SIZE);
        }

**注意**：上面的代码中，中间那根线微信是用的图片(图片可以自己制作，也可以反编译微信apk从中获取)，这里是画的线条，如果你想更加仿真点就将下面的代码：

    canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2,
                frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint);



修改为：

    Rect lineRect = new Rect();  
    lineRect.left = frame.left;  
    lineRect.right = frame.right;  
    lineRect.top = slideTop;  
    lineRect.bottom = slideTop + 18;  
    canvas.drawBitmap(((BitmapDrawable)(getResources().getDrawable(R.drawable.qrcode_scan_line))).getBitmap(), null, lineRect, paint);  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-实战并整合&quot;&gt;&lt;a href=&quot;#4-实战并整合&quot; class=&quot;headerlink&quot; title=&quot;4.实战并整合&quot;&gt;&lt;/a&gt;4.实战并整合&lt;/h3&gt;&lt;p&gt;待续(实际使用中，一般都是应用APP包括了扫描功能，而不是将扫码功能单独作为一个APP，因此需要对BS工程进行简化，使其可以作为其他应用工程的依赖lib，并去除那些不需要的功能，然后就直接整合进APP。)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zxing二维码开源库学习和优化&quot;&gt;&lt;a href=&quot;#Zxing二维码开源库学习和优化&quot; class=&quot;headerlink&quot; title=&quot;Zxing二维码开源库学习和优化&quot;&gt;&lt;/a&gt;Zxing二维码开源库学习和优化&lt;/h1&gt;&lt;p&gt;  本文对Google官方开
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="Zxing" scheme="http://cstsinghua.github.io/tags/Zxing/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse动态调试Android应用指南</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Eclipse%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Eclipse动态调试指南/</id>
    <published>2016-06-13T07:41:13.000Z</published>
    <updated>2017-10-11T11:34:42.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Eclipse动态调试指南&quot;&gt;&lt;a href=&quot;#Eclipse动态调试指南&quot; class=&quot;headerlink&quot; title=&quot;Eclipse动态调试指南&quot;&gt;&lt;/a&gt;Eclipse动态调试指南&lt;/h1&gt;&lt;p&gt;本文对Eclipse进行动态调试做一个全面的讲解（动态调试还可以采用Android studio、netbeans等工具，请参见&lt;a href=&quot;http://cstsinghua.github.io/2016/06/13/Android%20studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/&quot; title=&quot;Android studio动态调试指南&quot;&gt;Android studio动态调试指南&lt;/a&gt;），旨在为广大只有apk而没有源代码的程序猿提供排查bug的另辟蹊径。&lt;/p&gt;
&lt;h1 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h1&gt;&lt;h2 id=&quot;1-反编译&quot;&gt;&lt;a href=&quot;#1-反编译&quot; class=&quot;headerlink&quot; title=&quot;1.反编译&quot;&gt;&lt;/a&gt;1.反编译&lt;/h2&gt;&lt;p&gt;对目标apk使用apktool反编译出可调试的smali代码到out文件夹，目前apktool最新的版本是2.0.1。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;e.g. java -jar apktool_2.0.1.jar d -d target.apk -o out
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:-d参数是必须的，因为这样反编译出来的代码后缀均是java，因为只有java文件才能被eclipse/netbeans识别调试。&lt;/p&gt;
&lt;h2 id=&quot;2-设置调试标记&quot;&gt;&lt;a href=&quot;#2-设置调试标记&quot; class=&quot;headerlink&quot; title=&quot;2.设置调试标记&quot;&gt;&lt;/a&gt;2.设置调试标记&lt;/h2&gt;&lt;p&gt;在输出的out文件夹中，用文本编辑工具打开AndroidManifest.xml，在application节点中设置属性android:debuggable=”true”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;e.g. &amp;lt;application android:debuggable=&amp;quot;true&amp;quot; android:icon=&amp;quot;@drawable/icon&amp;quot; android:label=&amp;quot;@string/app_name&amp;quot; android:name=&amp;quot;com.boyaa.godsdk.core.MutiUnipayApplication&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;3-在主Activity的onCreate事件中添加调试等待-可选&quot;&gt;&lt;a href=&quot;#3-在主Activity的onCreate事件中添加调试等待-可选&quot; class=&quot;headerlink&quot; title=&quot;3.在主Activity的onCreate事件中添加调试等待(可选)&quot;&gt;&lt;/a&gt;3.在主Activity的onCreate事件中添加调试等待(可选)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意:如果不需要在程序的开头调试的话，建议忽略这一步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用文本编辑工具打开主类文件，找到onCreate方法，在第一句前插入invoke-static {}, Landroid/os/Debug;-&amp;gt;waitForDebugger()V，记得添加a=0;//的前缀保持上下一致，结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a=0;// # virtual methods
a=0;// .method protected onCreate(Landroid/os/Bundle;)V
a=0;//     invoke-static {}, Landroid/os/Debug;-&amp;gt;waitForDebugger()V
a=0;// 
a=0;//     .locals 1
a=0;//     .param p1, &amp;quot;savedInstanceState&amp;quot;    # Landroid/os/Bundle;
a=0;// 
a=0;//     .prologue
a=0;//     .line 11
a=0;//     invoke-super {p0, p1}, Landroid/app/Activity;-&amp;gt;onCreate(Landroid/os/Bundle;)V
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;4-保存文件，用apktool重新编译打包为debug-apk&quot;&gt;&lt;a href=&quot;#4-保存文件，用apktool重新编译打包为debug-apk&quot; class=&quot;headerlink&quot; title=&quot;4.保存文件，用apktool重新编译打包为debug.apk&quot;&gt;&lt;/a&gt;4.保存文件，用apktool重新编译打包为debug.apk&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;e.g. java -jar apktool_2.0.1.jar b -d out -o debug.apk
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk&quot;&gt;&lt;a href=&quot;#5-对debug-apk签名-建议采用安卓逆向助手-，生成debug-sign-apk&quot; class=&quot;headerlink&quot; title=&quot;5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk&quot;&gt;&lt;/a&gt;5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk&lt;/h2&gt;&lt;p&gt;当然也可以直接采用JDK里面的签名工具通过命令行手动进行签名：&lt;br&gt;    e.g. “jarsigner” -keystore “C:\Users\CoulsonChen\Desktop\kop.keystore” -storepass “kop1122334” -keypass “kop1122334” “D:\t\125.apk” “kop” -sigalg SHA1withRSA -digestalg SHA1&lt;/p&gt;
&lt;h2 id=&quot;6-上传debug-sign-apk至手机或模拟器，然后安装并运行。&quot;&gt;&lt;a href=&quot;#6-上传debug-sign-apk至手机或模拟器，然后安装并运行。&quot; class=&quot;headerlink&quot; title=&quot;6.上传debug_sign.apk至手机或模拟器，然后安装并运行。&quot;&gt;&lt;/a&gt;6.上传debug_sign.apk至手机或模拟器，然后安装并运行。&lt;/h2&gt;&lt;p&gt;如果启用第3步，这时你会看到程序运行后停留在白屏界面，这时不要动设备和退出程序，因为程序现在是运行到刚才添加的waitForDebugger代码这里，这行代码的意思是一直挂起中，等待调试器。&lt;/p&gt;
&lt;p&gt;如果未启用第3步，则apk正常运行(与普通安装apk无异)。&lt;/p&gt;
&lt;h2 id=&quot;7-启动eclipse，构建java项目&quot;&gt;&lt;a href=&quot;#7-启动eclipse，构建java项目&quot; class=&quot;headerlink&quot; title=&quot;7.启动eclipse，构建java项目&quot;&gt;&lt;/a&gt;7.启动eclipse，构建java项目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;File -&amp;gt; New -&amp;gt; Project -&amp;gt; Java Project -&amp;gt; Next&lt;/li&gt;
&lt;li&gt;Project Name随便起，Use default location选项去掉，Location选择第1步指定的out文件夹，然后Next&lt;/li&gt;
&lt;li&gt;把smali文件夹设为Source Folder，然后Finish&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;8-在eclipse中，在需要关注的地方添加断点&quot;&gt;&lt;a href=&quot;#8-在eclipse中，在需要关注的地方添加断点&quot; class=&quot;headerlink&quot; title=&quot;8.在eclipse中，在需要关注的地方添加断点&quot;&gt;&lt;/a&gt;8.在eclipse中，在需要关注的地方添加断点&lt;/h2&gt;&lt;p&gt;设置断点示例：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/0GOzzsD.png&quot; alt=&quot;设置断点示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;打开DDMS（路径在%android-sdks%\tools\ddms.bat）,如果在第6步中运行了修改后的程序，在DDMS的设备列表中会显示可以调试的程序。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/oD7NFxk.png&quot; alt=&quot;DDMS的设备列表&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，调试的端口为8608&lt;/p&gt;
&lt;h2 id=&quot;9-现在要做的就是把代码与调试程序关联即可&quot;&gt;&lt;a href=&quot;#9-现在要做的就是把代码与调试程序关联即可&quot; class=&quot;headerlink&quot; title=&quot;9.现在要做的就是把代码与调试程序关联即可&quot;&gt;&lt;/a&gt;9.现在要做的就是把代码与调试程序关联即可&lt;/h2&gt;&lt;p&gt;回到eclipse，配置远程调试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;菜单Run -&amp;gt; Debug -&amp;gt; Debug Configurations&lt;/li&gt;
&lt;li&gt;双击Remote Java Application，Host处默认localhost就行，Port填第9步得到的8608，然后Apply -&amp;gt; Debug。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示意图：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/n8R9QJs.png&quot; alt=&quot;关联源码和程序&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;10-切换至debug视图&quot;&gt;&lt;a href=&quot;#10-切换至debug视图&quot; class=&quot;headerlink&quot; title=&quot;10.切换至debug视图&quot;&gt;&lt;/a&gt;10.切换至debug视图&lt;/h2&gt;&lt;p&gt;看到程序已经运行并中断在下一行可执行的代码了，相关的变量可以直接查看了。示意图：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/w4AFI4x.png&quot; alt=&quot;最终调试&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Eclipse动态调试指南&quot;&gt;&lt;a href=&quot;#Eclipse动态调试指南&quot; class=&quot;headerlink&quot; title=&quot;Eclipse动态调试指南&quot;&gt;&lt;/a&gt;Eclipse动态调试指南&lt;/h1&gt;&lt;p&gt;本文对Eclipse进行动态调试做一个全面的讲解（动
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="动态调试" scheme="http://cstsinghua.github.io/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>apktool打包之后apk包体变大</title>
    <link href="http://cstsinghua.github.io/2016/06/13/apktool%E6%89%93%E5%8C%85%E4%B9%8B%E5%90%8E%E5%8C%85%E4%BD%93%E5%8F%98%E5%A4%A7/"/>
    <id>http://cstsinghua.github.io/2016/06/13/apktool打包之后包体变大/</id>
    <published>2016-06-13T07:40:18.000Z</published>
    <updated>2017-01-22T10:04:48.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;apktool重-编译-打包之后apk包体变大&quot;&gt;&lt;a href=&quot;#apktool重-编译-打包之后apk包体变大&quot; class=&quot;headerlink&quot; title=&quot;apktool重(编译)打包之后apk包体变大&quot;&gt;&lt;/a&gt;apktool重(编译)打包之后apk包体变大&lt;/h1&gt;&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;原因：应该是&lt;code&gt;apktool 2.0.3&lt;/code&gt;版本之后引入了两个字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;compressionType: &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;doNotCompress:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个字段会决定重新编译apk时哪些类型的文件不会压缩，从而影响最终生成的apk的包体大小。&lt;/p&gt;
&lt;h2 id=&quot;解决办法一：调整不压缩的文件类型&quot;&gt;&lt;a href=&quot;#解决办法一：调整不压缩的文件类型&quot; class=&quot;headerlink&quot; title=&quot;解决办法一：调整不压缩的文件类型&quot;&gt;&lt;/a&gt;解决办法一：调整不压缩的文件类型&lt;/h2&gt;&lt;p&gt;请对比&lt;code&gt;apktool 2.0.1&lt;/code&gt;和&lt;code&gt;2.1.1&lt;/code&gt;版本反编译之后目录下的&lt;code&gt;apktool.yml&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.0.1：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/IO5RRBr.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.1：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/SOVelmB.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;因此，可以动态调整doNotCompress字段中不压缩的文件类型(比如删除图中的- lua行)，来达到压缩的效果，从而使得包体大小保持与原有大小基本一致。&lt;/p&gt;
&lt;h2 id=&quot;解决办法二：利用apktool低版本及apktool高版本释放的1-apk&quot;&gt;&lt;a href=&quot;#解决办法二：利用apktool低版本及apktool高版本释放的1-apk&quot; class=&quot;headerlink&quot; title=&quot;解决办法二：利用apktool低版本及apktool高版本释放的1.apk&quot;&gt;&lt;/a&gt;解决办法二：利用apktool低版本及apktool高版本释放的1.apk&lt;/h2&gt;&lt;p&gt;既然&lt;code&gt;apktool 2.0.1&lt;/code&gt;及其之下版本未引入doNotCompress字段，那么可以采用高版本的apktool释放的1.apk(framework)来作为&lt;code&gt;apktool 2.0.1&lt;/code&gt;及其之下版本重编译时的框架依赖。这样可以解决2.0.1重编译依赖&lt;code&gt;Android6.0&lt;/code&gt;系统特性的apk失败的问题。&lt;/p&gt;
&lt;p&gt;举例：首先用&lt;code&gt;apktool 2.0.1&lt;/code&gt;反编译&lt;code&gt;target.apk&lt;/code&gt;，然后将更高版本的apktool释放(反编译操作时候就会自动释放出来)的1.apk覆盖掉&lt;code&gt;apktool 2.0.1&lt;/code&gt;的&lt;code&gt;1.apk&lt;/code&gt;，&lt;code&gt;1.apk&lt;/code&gt;文件一般放在&lt;code&gt;Home_dir\apktool\framework\1.apk&lt;/code&gt;,其中Home_dir是操作系统的默认Home目录，windows平台可以打开cmd，提示的目录即为Home_dir。当然也可以采用Everything搜索等工具全局搜索下就知道其路径了。最后，用&lt;code&gt;apktool 2.0.1&lt;/code&gt;版本重新编译&lt;code&gt;target.apk&lt;/code&gt;反编译时生成的目录，即可编译成功。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;apktool重-编译-打包之后apk包体变大&quot;&gt;&lt;a href=&quot;#apktool重-编译-打包之后apk包体变大&quot; class=&quot;headerlink&quot; title=&quot;apktool重(编译)打包之后apk包体变大&quot;&gt;&lt;/a&gt;apktool重(编译)打包之后a
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="apktool" scheme="http://cstsinghua.github.io/tags/apktool/"/>
    
      <category term="Apktool打包" scheme="http://cstsinghua.github.io/tags/Apktool%E6%89%93%E5%8C%85/"/>
    
      <category term="apk" scheme="http://cstsinghua.github.io/tags/apk/"/>
    
      <category term="size" scheme="http://cstsinghua.github.io/tags/size/"/>
    
  </entry>
  
  <entry>
    <title>Android热修复</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Android热修复的思路/</id>
    <published>2016-06-13T07:38:15.000Z</published>
    <updated>2016-06-13T07:36:18.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Android热修复的方式&quot;&gt;&lt;a href=&quot;#Android热修复的方式&quot; class=&quot;headerlink&quot; title=&quot;Android热修复的方式&quot;&gt;&lt;/a&gt;Android热修复的方式&lt;/h1&gt;&lt;p&gt;关于动态热修复，目前发现的思路集中在三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方式1：既然是热修复，那么就是新的类替换掉旧的类，而java世界类的加载是通过类加载器来实现，而Android应用程序的默认类加载器PathClassLoader加载的时候其实是通过关联的DexFile来实现(动态加载的时候已经反复涉及，这里不再赘述)，当有多个Dex文件的时候，是按照dexElements中的顺序来执行，如果一旦加载到则返回该类，否则遍历查询dexElements中的所有元素，直到最终查询完，那么基于这个事实，则可以将新类的dex文件加载的时候对应的Element放置在最前面，这样PathClassLoader加载的时候就自然先加载到新类而不是旧的有问题的类，但是这种机制在多个mutildex时存在缺陷，具体请参见下面转发链接的阐述，另外一旦某个类已经被加载，则失效了，因为一旦被加载之后，PathClassLoader的loadClass已经直接返回class而不会去查询，这样使得往往下载修复包之后需要在下次启动才能加载。当然这个办法基于纯java实现，非侵入性，与平台无关；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方式2：基于阿里的AndFix开源项目，这个的出发点是另外一个角度，类被类加载器加载进来之后，那么其实本质还是虚拟机在管理，而根据java虚拟机包括Dalvik虚拟机的内存模型(可以查看我那本深入理解java虚拟机书籍相关章节)，类的class文件加载进来之后存放在方法区，那么既然已经认定这个类被加载了，怎么做到热修复，阿里的方式确实巧妙，因为java虚拟机本身是C++语言实现的，通过JNI的方式可以获取到方法区中方法的引用，修改方法内部的执行引用，具体的还需要更加深入研究，将方法的执行逻辑指向了新方法，这种情况下可以做到及时加载及时修复，不用重启应用，缺点是通过JNI方式，so的兼容性决定了适用性，不过阿里的做得已经不错，当然一旦Android平台的虚拟机内部实现改变，就需要重新修改so对应的C++代码，目前首选这个方式；&lt;/p&gt;
&lt;p&gt;  另外，生成新旧dex的patch也是一个关键点，阿里提供了这样一个工具：AppPatch。生成patch的过程，大概是基于smali和baksmali，先加载新的和旧的两个dex文件得到所有的class，然后通过getImplementation()方法可对比他们的方法实现是否一致，将对比结果分成添加的方法/字段和修改的方法/字段分别保存起来，在重新生成的差异化dex文件时，根据对比结果在相应的方法或者字段前添加注解标志。要深入理解的话需要熟悉一下smali/baksmali的源码以及dalvik虚拟机的文件结构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;方式3：阿里的Dexposed开源项目，也是纯java实现，基于大名鼎鼎的 Xposed framework project开源项目，面向AOP切面编程的思想，目前还没有很深入研究，可能与方式1有些类似，也可能基于动态代理等方式来做到。不过目前这个项目只能适用于5.0以下系统，目前不建议使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于方式1：&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://blog.csdn.net/lzyzsd/article/details/49843581&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lzyzsd/article/details/49843581&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/jasonross/Nuwa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/jasonross/Nuwa&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于方式2：&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/alibaba/AndFix&quot; title=&quot;阿里的AndFix开源项目&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/alibaba/AndFix&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于方式3：&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/alibaba/dexposed&quot; title=&quot;阿里的dexposed开源项目&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/alibaba/dexposed&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android热修复的方式&quot;&gt;&lt;a href=&quot;#Android热修复的方式&quot; class=&quot;headerlink&quot; title=&quot;Android热修复的方式&quot;&gt;&lt;/a&gt;Android热修复的方式&lt;/h1&gt;&lt;p&gt;关于动态热修复，目前发现的思路集中在三点：&lt;/p&gt;

    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
      <category term="插件化和热修复" scheme="http://cstsinghua.github.io/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Android热修复" scheme="http://cstsinghua.github.io/tags/Android%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android动态加载机制</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Android动态加载机制/</id>
    <published>2016-06-13T07:36:18.000Z</published>
    <updated>2016-12-22T10:46:24.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h1&gt;&lt;p&gt;在Android开发中，存在一些场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？&lt;br&gt; 引用官方原文&lt;a href=&quot;http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about&quot; title=&quot;每个Dex的方法数不能超过65535&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`Both these error conditions display a common number: 65,536. This number is significant in that it represents the total number of references that can be invoked by the code within a single Dalvik Executable (dex) bytecode file. If you have built an Android app and received this error, then congratulations, you have a lot of code! This document explains how to move past this limitation and continue building your app.`
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;众所周知，Android进行反编译APK获取其中的资源和代码相对比较容易，那么在某些特定场景和功能，开发者不希望其核心代码被他人轻易反编译破解，此时应该怎么办？安全方面的考虑，比如in-app purchase？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;随着Android的发展，应用的功能越来越多，越来越复杂，其APK大小也跟随着膨胀，而APK的大小影响着用户的接受程度，许多应用市场也会限制上传包的大小，如何做到既减小APK的大小，同时又可以扩展更多功能？扩展考虑？&lt;/li&gt;
&lt;li&gt;其他？热插拔？类似插件的机制？…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的问题自然就引出一个概念，能不能动态地加载Android代码或者资源，甚至动态加载APK执行？&lt;/p&gt;
&lt;p&gt;答案是肯定的！熟悉Java的朋友应该了解JVM可以动态加载类，核心思想是通过ClassLoader加载本地的或者从网络传输获得的类代码，从而可以在运行时动态加载类。Android平台的应用开发主要采用Java语言，而dalvik虚拟机的类加载机制类似于JVM。&lt;/p&gt;
&lt;p&gt;本文先介绍JVM的类加载原理，讲述Java最基本的类加载机制，为Android类加载做铺垫。然后，重点介绍Android的类加载机制，及常见的实现方式。最后，在前面的基础上，扩展开来，从Android的类加载引申到更广泛的层面上，即动态加载机制(插件机制)、安全方面。从这里可以看到，整个发展历程成阶梯上升，前面的是基础也是基石，而越到后面才是实际开发中更常见的场景，也是更加复杂和综合的应用。概括之，&lt;strong&gt;Android的动态加载机制发展历程：普通的类(Class文件)加载-&amp;gt;普通jar包(包含dex)加载-&amp;gt;包含资源的jar加载-&amp;gt;直接加载其他应用程序APK&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;2-JVM的类加载机制&quot;&gt;&lt;a href=&quot;#2-JVM的类加载机制&quot; class=&quot;headerlink&quot; title=&quot;2.JVM的类加载机制&quot;&gt;&lt;/a&gt;2.JVM的类加载机制&lt;/h1&gt;&lt;p&gt;Java的类(class)文件是通过类加载器来加载的，每一个类加载器，都拥有一个独立的类名称空间，因此，只有比较两类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：上面提及的“相等”概念，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象关系判断等情况。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-1-双亲委派模型&quot;&gt;&lt;a href=&quot;#2-1-双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;2.1 双亲委派模型&quot;&gt;&lt;/a&gt;2.1 双亲委派模型&lt;/h2&gt;&lt;p&gt;从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器均由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。&lt;/p&gt;
&lt;p&gt;从Java程序员的角度来看，类加载器划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动类加载器(Bootstrap ClassLoader):这个类加载器负责将存放在&lt;java_home&gt;/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可。&lt;/java_home&gt;&lt;/li&gt;
&lt;li&gt;扩展类加载器(Extension ClassLoader)：该加载器由sun.misc.Launcher$ExtClassLoader实现，其负责加载&lt;java_home&gt;/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/java_home&gt;&lt;/li&gt;
&lt;li&gt;应用程序类加载器(Application ClassLoader)：该类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般也称它为系统类加载器。其负责加载用户类路径(ClassPath)上所指定的库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的关系一般如下图所示：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/YR2iX5b.png&quot; alt=&quot;ClassLoader之间关系&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中的这种层次关系，被称为类加载器的双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合的关系来复用父类加载器的代码。&lt;/p&gt;
&lt;p&gt;类加载器的双亲委派模型在JDK1.2期间被引入并被广发应用于之后的几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双亲委派模型的工作过程：&lt;/strong&gt;如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。&lt;/p&gt;
&lt;p&gt;类加载由类加载器的loadClass方法执行，而&lt;strong&gt;实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass方法之中&lt;/strong&gt;，如下面代码(基于JDK 1.7版本的源码)所示，其逻辑为：&lt;strong&gt;先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法执行自定义的加载过程&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Loads the class with the specified &amp;lt;a href=&amp;quot;#name&amp;quot;&amp;gt;binary name&amp;lt;/a&amp;gt;.  The
 * default implementation of this method searches for classes in the
 * following order:
 *
 * &amp;lt;p&amp;gt;&amp;lt;ol&amp;gt;
 *
 *   &amp;lt;li&amp;gt;&amp;lt;p&amp;gt; Invoke {@link #findLoadedClass(String)} to check if the class
 *   has already been loaded.  &amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
 *
 *   &amp;lt;li&amp;gt;&amp;lt;p&amp;gt; Invoke the {@link #loadClass(String) &amp;lt;tt&amp;gt;loadClass&amp;lt;/tt&amp;gt;} method
 *   on the parent class loader.  If the parent is &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; the class
 *   loader built-in to the virtual machine is used, instead.  &amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
 *
 *   &amp;lt;li&amp;gt;&amp;lt;p&amp;gt; Invoke the {@link #findClass(String)} method to find the
 *   class.  &amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
 *
 * &amp;lt;/ol&amp;gt;
 *
 * &amp;lt;p&amp;gt; If the class was found using the above steps, and the
 * &amp;lt;tt&amp;gt;resolve&amp;lt;/tt&amp;gt; flag is true, this method will then invoke the {@link
 * #resolveClass(Class)} method on the resulting &amp;lt;tt&amp;gt;Class&amp;lt;/tt&amp;gt; object.
 *
 * &amp;lt;p&amp;gt; Subclasses of &amp;lt;tt&amp;gt;ClassLoader&amp;lt;/tt&amp;gt; are encouraged to override {@link
 * #findClass(String)}, rather than this method.  &amp;lt;/p&amp;gt;
 *
 * &amp;lt;p&amp;gt; Unless overridden, this method synchronizes on the result of
 * {@link #getClassLoadingLock &amp;lt;tt&amp;gt;getClassLoadingLock&amp;lt;/tt&amp;gt;} method
 * during the entire class loading process.
 *
 * @param  name
 *         The &amp;lt;a href=&amp;quot;#name&amp;quot;&amp;gt;binary name&amp;lt;/a&amp;gt; of the class
 *
 * @param  resolve
 *         If &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; then resolve the class
 *
 * @return  The resulting &amp;lt;tt&amp;gt;Class&amp;lt;/tt&amp;gt; object
 *
 * @throws  ClassNotFoundException
 *          If the class could not be found
 */
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-类加载过程&quot;&gt;&lt;a href=&quot;#2-2-类加载过程&quot; class=&quot;headerlink&quot; title=&quot;2.2 类加载过程&quot;&gt;&lt;/a&gt;2.2 类加载过程&lt;/h2&gt;&lt;p&gt;类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)，这7个阶段顺序如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wwFyQk9.png&quot; alt=&quot;ClassLoading process&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地执行，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也被称为动态绑定或晚期绑定)。&lt;/p&gt;
&lt;h1 id=&quot;3-Android中的类加载机制&quot;&gt;&lt;a href=&quot;#3-Android中的类加载机制&quot; class=&quot;headerlink&quot; title=&quot;3.Android中的类加载机制&quot;&gt;&lt;/a&gt;3.Android中的类加载机制&lt;/h1&gt;&lt;p&gt;Android的类加载机制与JVM的类加载机制类似。也采用了双亲委派模型。Android系统定义的ClassLoader相关类的架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/FWdhXzZ.png&quot; alt=&quot;Android的ClassLoader架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，ClassLoader是整个类加载器的顶层类，其为抽象类，实现了类加载器所要求的通用架构。Android中提供了几个该类的具体实现类，比如dalvik.system.PathClassLoader，应用程序可以实现ClassLoader来提供加载类的特殊方式。&lt;/p&gt;
&lt;h2 id=&quot;3-1-Android中的主要类加载器介绍&quot;&gt;&lt;a href=&quot;#3-1-Android中的主要类加载器介绍&quot; class=&quot;headerlink&quot; title=&quot;3.1 Android中的主要类加载器介绍&quot;&gt;&lt;/a&gt;3.1 Android中的主要类加载器介绍&lt;/h2&gt;&lt;p&gt;从上图可知，java.lang.ClassLoader是类加载器的顶层类，dalvik.system.BaseDexClassLoader是为各种基于dex的类加载器的实现提供一个基本功能的基类。其子类dalvik.system.PathClassLoader和dalvik.system.DexClassLoader是我们关注的重点，负责具体的类加载。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dalvik.system.PathClassLoader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Android源码的解释是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Provides a simple ClassLoader implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 大意是，PathClassLoader可以加载包含在本地文件系统中的文件和目录列表中代码和资源，但是无法从网络加载类。Android本身采用该类加载器作为其系统的和应用程序的默认类加载器，换句话说，Android系统的框架层的类和应用程序默认情况下的类加载均有该类来完成。那么要实现自定义的类加载器，采用该类就不太可行了，那只能另辟蹊径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dalvik.system.DexClassLoader&lt;/strong&gt;&lt;br&gt; Android源码的解释是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A class loader that loads classes from .jar and .apk files containing a classes.dex entry. This can be used to execute code not installed as part of an application.

This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getCodeCacheDir() to create such a directory:

   File dexOutputDir = context.getCodeCacheDir();

Do not cache optimized classes on external storage. External storage does not provide access controls necessary to protect your application from code injection attacks.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 从上面说明不难看出，DexClassLoader可以从包含dex的jar或者apk文件中加载类和资源，用于加载应用程序非安装时附带的代码。这恰恰就是我们所需要的，因为我们希望在应用运行期间，动态地从文件系统或者从网络下载包含dex的文件，然后加载进内存执行。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;请注意：DexClassLoader需要提供一个目录用于缓存优化的class文件，因此为了安全，请将该目录设置为应用程序私有的目录，不要采用外部存储目录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; DexClassLoader有一个构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 其中，dexPath为包含dex的jar或者apk的存放路径，optimizedDirectory代表存放优化的dex的目录，libraryPath代表本地代码存放的路径，parent指定父加载器，一般采用Context调用getClassLoader()获取并传入，如果传入null，则采用启动类加载器作为父加载器。&lt;/p&gt;
&lt;p&gt; DexClassLoader负责加载类的方法仍是继承自ClassLoader的loadClass方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class&amp;lt;?&amp;gt; java.lang.ClassLoader.loadClass(String className) throws ClassNotFoundException
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3-2-DexClassLoader加载类示例&quot;&gt;&lt;a href=&quot;#3-2-DexClassLoader加载类示例&quot; class=&quot;headerlink&quot; title=&quot;3.2 DexClassLoader加载类示例&quot;&gt;&lt;/a&gt;3.2 DexClassLoader加载类示例&lt;/h2&gt;&lt;p&gt;既然我们可以直接使用DexClassLoader来动态加载应用程序外部的dex，那么这个过程具体是怎样的呢，且看下文分解。&lt;/p&gt;
&lt;h3 id=&quot;3-2-1-DexClassLoader加载示例1&quot;&gt;&lt;a href=&quot;#3-2-1-DexClassLoader加载示例1&quot; class=&quot;headerlink&quot; title=&quot;3.2.1 DexClassLoader加载示例1&quot;&gt;&lt;/a&gt;3.2.1 DexClassLoader加载示例1&lt;/h3&gt;&lt;p&gt;本示例来自Google官方blog，具体地址为&lt;a href=&quot;http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html&quot; title=&quot;Custom Class Loading in Dalvik&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html&lt;/a&gt;，源码也可以从该网址中的链接下载&lt;a href=&quot;http://code.google.com/p/android-custom-class-loading-sample&quot; title=&quot;sample下载&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://code.google.com/p/android-custom-class-loading-sample&lt;/a&gt;，本文另外提供一个地址下载(本文作者修改后在本地运行的版本，主要涉及修改里面的local.properties，配置本地的Android SDK tools的安装目录)，下载请点击：&lt;a href=&quot;http://172.20.154.39:8080/android-custom-class-loading-sample.zip&quot; title=&quot;Sample本地下载地址&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本地Sample下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里摘录其中的步骤，并做一个简单描述。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码结构：&lt;/p&gt;
&lt;p&gt; 该应用程序包含三个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;com.example.dex.MainActivity: 调用库代码的UI组件&lt;/li&gt;
&lt;li&gt;com.example.dex.LibraryInterface: 库代码API的接口定义&lt;/li&gt;
&lt;li&gt;&lt;p&gt;com.example.dex.lib.LibraryProvider: lib库的实现&lt;/p&gt;
&lt;p&gt;lib库打包进第二个dex, 而剩下的类被装入主dex(也就是默认的dex)。下面的构建章节详细地阐述了怎么实现这个目的。当然，实际情况下的的打包的策略依赖于开发者实际要处理的特定场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类加载和方法调用：&lt;/p&gt;
&lt;p&gt; 包含lib库的第二个dex文件，存储在应用程序的assets目录。首先，第二个dex文件必须复制到类加载可以直接加载的文件路径(Android内核是Linux，则path的形式与普通的linux文件路径类似)，本示例代码采用应用APP的私有内部储存区域来存放该dex(从技术层面来说，外部存储也可以满足需求，但是考虑到安全性，建议保存在内部存储)。&lt;br&gt; 如下是MainActivity的代码片段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Before the secondary dex file can be processed by the DexClassLoader,
// it has to be first copied from asset resource to a storage location.
File dexInternalStoragePath = new File(getDir(&amp;quot;dex&amp;quot;, Context.MODE_PRIVATE),
        SECONDARY_DEX_NAME);
...
BufferedInputStream bis = null;
OutputStream dexWriter = null;

static final int BUF_SIZE = 8 * 1024;
try {
    bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));
    dexWriter = new BufferedOutputStream(
        new FileOutputStream(dexInternalStoragePath));
    byte[] buf = new byte[BUF_SIZE];
    int len;
    while((len = bis.read(buf, 0, BUF_SIZE)) &amp;gt; 0) {
        dexWriter.write(buf, 0, len);
    }
    dexWriter.close();
    bis.close();

} catch (. . .) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 下一步，初始化创建一个DexClassLoader去加载从第二个dex中提取出来的库。有几种方式可以调用加载类的方法。在本示例中，类实例被强制转换成其实现的接口，这样就通过调用接口中定义的方法直接调用。这样的方式更方便，当然，通过反射获取Method，然后Method调用invoke方法也是可行，但反射更加复杂且比较慢。但利用反射也有其优点，即不需要第二个dex文件中的lib库实现特定的接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Internal storage where the DexClassLoader writes the optimized dex file to
final File optimizedDexOutputPath = getDir(&amp;quot;outdex&amp;quot;, Context.MODE_PRIVATE);

DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),
                                       optimizedDexOutputPath.getAbsolutePath(),
                                       null,
                                       getClassLoader());
Class libProviderClazz = null;
try {
    // Load the library.
    libProviderClazz =
        cl.loadClass(&amp;quot;com.example.dex.lib.LibraryProvider&amp;quot;);
    // Cast the return object to the library interface so that the
    // caller can directly invoke methods in the interface.
    // Alternatively, the caller can invoke methods through reflection,
    // which is more verbose. 
    LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();
    lib.showAwesomeToast(this, &amp;quot;hello&amp;quot;);
} catch (Exception e) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构建过程(build process)&lt;/p&gt;
&lt;p&gt; 为了生成两个独立的dex文件，我们需要调整标准的构建过程。为了实现该技巧，可以简单地修改工程的Ant构建配置文件build.xml中到的”dex” target标签。&lt;/p&gt;
&lt;p&gt; 修改后的”dex” target标签执行下列操作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;a. 创建两个存储目录，用于存储默认dex和第二个dex；

b. 选择性地从PROJECT_ROOT/bin/classes复制class文件至上面的两个目录；

    &amp;lt;!-- Primary dex to include everything but the concrete library
             implementation. --&amp;gt;
        &amp;lt;copy todir=&amp;quot;${out.classes.absolute.dir}.1&amp;quot; &amp;gt;
            &amp;lt;fileset dir=&amp;quot;${out.classes.absolute.dir}&amp;quot; &amp;gt;
                    &amp;lt;exclude name=&amp;quot;com/example/dex/lib/**&amp;quot; /&amp;gt;
            &amp;lt;/fileset&amp;gt;
        &amp;lt;/copy&amp;gt;
        &amp;lt;!-- Secondary dex to include the concrete library implementation. --&amp;gt;
        &amp;lt;copy todir=&amp;quot;${out.classes.absolute.dir}.2&amp;quot; &amp;gt;
            &amp;lt;fileset dir=&amp;quot;${out.classes.absolute.dir}&amp;quot; &amp;gt;
                    &amp;lt;include name=&amp;quot;com/example/dex/lib/**&amp;quot; /&amp;gt;
            &amp;lt;/fileset&amp;gt;
        &amp;lt;/copy&amp;gt;   

 c.将上述两个目录中的.class文件转换成两个独立的dex文件；

 d.将第二个dex文件添加到一个jar文件中，jar文件是DexClassLoader期望的输入格式(其实只要里面包含dex即可)。最后，存储该jar文件至工程的assets目录。

     &amp;lt;!-- Package the output in the assets directory of the apk. --&amp;gt;
        &amp;lt;jar destfile=&amp;quot;${asset.absolute.dir}/secondary_dex.jar&amp;quot;
               basedir=&amp;quot;${out.absolute.dir}/secondary_dex_dir&amp;quot;
               includes=&amp;quot;classes.dex&amp;quot; /&amp;gt;

为了达成上面的构建目的，需要在工程目录下执行&amp;quot;ant debug&amp;quot;或者&amp;quot;ant release&amp;quot;命令(前提是需要下载apache的[Ant构建工具](https://www.apache.org/dist/ant/ &amp;quot;Ant&amp;quot;)，且不能使用Eclipse的自动构建方式)。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-2-2-DexClassLoader加载示例2&quot;&gt;&lt;a href=&quot;#3-2-2-DexClassLoader加载示例2&quot; class=&quot;headerlink&quot; title=&quot;3.2.2 DexClassLoader加载示例2&quot;&gt;&lt;/a&gt;3.2.2 DexClassLoader加载示例2&lt;/h3&gt;&lt;p&gt;示例1主要是定制了ant的构建过程，这样在生成apk的时候已经对class文件加以分割，生成了独立的多个dex文件，并且自动地放入了apk的assets目录。运行时，非默认dex采用DexClassLoader加载。如果觉得修改Eclipse自动构建过程麻烦(主要是需要配置build.xml)，更直观的方式是，新建一个空工程，将lib库的包copy进去，编译该工程，会在工程的bin目录下生成代码相关的jar文件，再利用dex2jar工具将jar转换成第二个dex即可，将第二个dex放入工程的assets目录，其他步骤与示例1完全一致。或者，直接新建的工程，从生成的apk从提取dex(即第二个dex)，然后放入工程的assets目录，其他方面别无二样。&lt;/p&gt;
&lt;h3 id=&quot;3-3-DexClassLoader加载的缺点，类加载的进一步探索&quot;&gt;&lt;a href=&quot;#3-3-DexClassLoader加载的缺点，类加载的进一步探索&quot; class=&quot;headerlink&quot; title=&quot;3.3 DexClassLoader加载的缺点，类加载的进一步探索&quot;&gt;&lt;/a&gt;3.3 DexClassLoader加载的缺点，类加载的进一步探索&lt;/h3&gt;&lt;p&gt;从上面的示例和DexClassLoader的API不难发现，DexClassLoader加载类的时候必须知道dex path，而且需要指定存放优化的dex目录，这就是说，DexClassLoader工作前提是必须将&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;dex存放在文件系统&lt;/strong&gt;&lt;/font&gt;中，虽然可以存放在应用程序私有的目录中，但是一旦黑客绕过这道Android系统的文件权限管理的篱笆，那么就能获取到dex文件，然后反编译并获取其中的内容。所以，DexClassLoader这样的加载机制存在安全问题。那么，怎么样回避这个问题呢？&lt;/p&gt;
&lt;p&gt;一个直观的方法，就是能不能直接对dex文件进行加密，这样即使保存在文件系统，其他人要想破解则必须先解密dex。但是，一旦加密dex，那么在加载的时候也必须先进行解密，解密的过程如果用java来完成，那仍然是不安全的。另外，优化的dex仍然需保存在文件系统中，这还是不可行。&lt;/p&gt;
&lt;p&gt;从上面讲述的类加载的双亲委派模型可知，一个类加载器，先委派父类加载器去加载，如果无法加载，则调用自身的findClass方法去按照自定义方式加载类。关键就在于此，其实DexClassLoader替我们处理好了底层的封装细节，我们只是调用了DexClassLoader的loadClass方法而已。那么，要想突破DexClassLoader的缺陷，也就不得不深入研究下DexClassLoader本身的loadClass和findClass方法，从中寻找蛛丝马迹，抑或一种启发，进而编写属于我们自己的DexClassLoader。&lt;/p&gt;
&lt;p&gt;其实，Android4.0版本增加了对内存中DEX数据的动态加载(稍后看源码可以确认这一点)，这样就克服了使用DexClassLoader时DEX以文件形式明文存放在存储设备上的缺点，内存中DEX数据可以来源于解密后的文件或者网络。这样就增加了DEX数据的安全性。但是DexClassLoader并没有暴露该种加载方式。开发者需要在JAVA层实现自己的Dex ClassLoader。本文提供两个Android源码下载的链接地址：&lt;/p&gt;
&lt;p&gt;Android官方下载地址：&lt;a href=&quot;https://android.googlesource.com&quot; title=&quot;Android官方源码&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://android.googlesource.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web在线浏览及下载地址：&lt;a href=&quot;http://androidxref.com&quot; title=&quot;Android源码web在线浏览和下载&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://androidxref.com&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DexClassLoader的源码(下面基于ICS4.0.3的源码)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * A class loader that loads classes from {@code .jar} and {@code .apk} files
 * containing a {@code classes.dex} entry. This can be used to execute code not
 * installed as part of an application.
 *
 * &amp;lt;p&amp;gt;This class loader requires an application-private, writable directory to
 * cache optimized classes. Use {@code Context.getDir(String, int)} to create
 * such a directory: &amp;lt;pre&amp;gt;   {@code
 *   File dexOutputDir = context.getDir(&amp;quot;dex&amp;quot;, 0);
 * }&amp;lt;/pre&amp;gt;
 *
 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Do not cache optimized classes on external storage.&amp;lt;/strong&amp;gt;
 * External storage does not provide access controls necessary to protect your
 * application from code injection attacks.
 */
public class DexClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code DexClassLoader} that finds interpreted and native
     * code.  Interpreted classes are found in a set of DEX files contained
     * in Jar or APK files.
     *
     * &amp;lt;p&amp;gt;The path lists are separated using the character specified by the
     * {@code path.separator} system property, which defaults to {@code :}.
     *
     * @param dexPath the list of jar/apk files containing classes and
     *     resources, delimited by {@code File.pathSeparator}, which
     *     defaults to {@code &amp;quot;:&amp;quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     *     should be written; must not be {@code null}
     * @param libraryPath the list of directories containing native
     *     libraries, delimited by {@code File.pathSeparator}; may be
     *     {@code null}
     * @param parent the parent class loader
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，DexClassLoader本身没有任何逻辑，只是继承了BaseDexClassLoader，并提供了一个构造器而已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BaseDexClassLoader源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Base class for common functionality between various dex-based
 * {@link ClassLoader} implementations.
 */
public class BaseDexClassLoader extends ClassLoader {
    /** originally specified path (just used for {@code toString()}) */
    private final String originalPath;

    /** structured lists of path elements */
    private final DexPathList pathList;

    /**
     * Constructs an instance.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &amp;quot;:&amp;quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     * should be written; may be {@code null}
     * @param libraryPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
    public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(parent);

        this.originalPath = dexPath;
        this.pathList =
            new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        Class clazz = pathList.findClass(name);

        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }

        return clazz;
    }

    @Override
    protected URL findResource(String name) {
        return pathList.findResource(name);
    }

    @Override
    protected Enumeration&amp;lt;URL&amp;gt; findResources(String name) {
        return pathList.findResources(name);
    }

    @Override
    public String findLibrary(String name) {
        return pathList.findLibrary(name);
    }

    /**
     * Returns package information for the given package.
     * Unfortunately, instances of this class don&amp;apos;t really have this
     * information, and as a non-secure {@code ClassLoader}, it isn&amp;apos;t
     * even required to, according to the spec. Yet, we want to
     * provide it, in order to make all those hopeful callers of
     * {@code myClass.getPackage().getName()} happy. Thus we construct
     * a {@code Package} object the first time it is being requested
     * and fill most of the fields with dummy values. The {@code
     * Package} object is then put into the {@code ClassLoader}&amp;apos;s
     * package cache, so we see the same one next time. We don&amp;apos;t
     * create {@code Package} objects for {@code null} arguments or
     * for the default package.
     *
     * &amp;lt;p&amp;gt;There is a limited chance that we end up with multiple
     * {@code Package} objects representing the same package: It can
     * happen when when a package is scattered across different JAR
     * files which were loaded by different {@code ClassLoader}
     * instances. This is rather unlikely, and given that this whole
     * thing is more or less a workaround, probably not worth the
     * effort to address.
     *
     * @param name the name of the class
     * @return the package information for the class, or {@code null}
     * if there is no package information available for it
     */
    @Override
    protected synchronized Package getPackage(String name) {
        if (name != null &amp;amp;&amp;amp; !name.isEmpty()) {
            Package pack = super.getPackage(name);

            if (pack == null) {
                pack = definePackage(name, &amp;quot;Unknown&amp;quot;, &amp;quot;0.0&amp;quot;, &amp;quot;Unknown&amp;quot;,
                        &amp;quot;Unknown&amp;quot;, &amp;quot;0.0&amp;quot;, &amp;quot;Unknown&amp;quot;, null);
            }

            return pack;
        }

        return null;
    }

    @Override
    public String toString() {
        return getClass().getName() + &amp;quot;[&amp;quot; + originalPath + &amp;quot;]&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析得之，BaseDexClassLoader覆写了ClassLoader的findClass方法(loadClass方法根据前面所述的双亲委派模型介绍可知是实现双亲委派模型的基础，官方是建议不要修改该方法，而覆写findClass方法)。findClass方法中其实是调用pathList.findClass(name)，而pathList是DexPathList类的实例，那么接着跟踪进入DexPathList的源码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DexPathList的源码(findClass方法)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Finds the named class in one of the dex files pointed at by
 * this instance. This will find the one in the earliest listed
 * path element. If the class is found but has not yet been
 * defined, then this method will define it in the defining
 * context that this instance was constructed with.
 *
 * @return the named class or {@code null} if the class is not
 * found in any of the dex files
 */
public Class findClass(String name) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext);
            if (clazz != null) {
                return clazz;
            }
        }
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，发现其实又调用DexFile dex.loadClassBinaryName(name, definingContext),根据进入DexFile的源码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DexFile的源码(loadClassBinaryName方法)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Opens a DEX file from a given filename. This will usually be a ZIP/JAR
 * file with a &amp;quot;classes.dex&amp;quot; inside.
 *
 * The VM will generate the name of the corresponding file in
 * /data/dalvik-cache and open it, possibly creating or updating
 * it first if system permissions allow.  Don&amp;apos;t pass in the name of
 * a file in /data/dalvik-cache, as the named file is expected to be
 * in its original (pre-dexopt) state.
 *
 * @param fileName
 *            the filename of the DEX file
 *
 * @throws IOException
 *             if an I/O error occurs, such as the file not being found or
 *             access rights missing for opening it
 */
public DexFile(String fileName) throws IOException {
    mCookie = openDexFile(fileName, null, 0);
    mFileName = fileName;
    guard.open(&amp;quot;close&amp;quot;);
    //System.out.println(&amp;quot;DEX FILE cookie is &amp;quot; + mCookie);
}
...
/**
 * See {@link #loadClass(String, ClassLoader)}.
 *
 * This takes a &amp;quot;binary&amp;quot; class name to better match ClassLoader semantics.
 *
 * @hide
 */
public Class loadClassBinaryName(String name, ClassLoader loader) {
    return defineClass(name, loader, mCookie);
}

private native static Class defineClass(String name, ClassLoader loader, int cookie);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终，通过JNI调用了本地方法defineClass(String name, ClassLoader loader, int cookie)。在实例化DexFile类的时候，在构造方法里面， 关键处为mCookie = openDexFile(fileName, null, 0)，这里即将dex文件打开并加装，而在DexFile里面还有几个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * Open a DEX file.  The value returned is a magic VM cookie.  On
 * failure, an IOException is thrown.
 */
native private static int openDexFile(String sourceName, String outputName,
    int flags) throws IOException;

/*
 * Open a DEX file based on a {@code byte[]}. The value returned
 * is a magic VM cookie. On failure, a RuntimeException is thrown.
 */
native private static int openDexFile(byte[] fileContents);

/*
 * Close DEX file.
 */
native private static void closeDexFile(int cookie);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这些本地方法实现是在/dalvik/vm/native/dalvik_system_DexFile.cpp里面。&lt;br&gt;native private static int openDexFile(byte[] fileContents)方法正是Android 4.0之后引入的，即前面所述的增加了对内存中DEX数据的动态加载。byte[] fileContents可以来自于网络或者解密dex文件。利用这一点，开发者可以解决DexClassLoader的缺点。&lt;/p&gt;
&lt;h4 id=&quot;3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1&quot;&gt;&lt;a href=&quot;#3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1&quot;&gt;&lt;/a&gt;3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1&lt;/h4&gt;&lt;p&gt;通过上面内容，我们知道DexClassLoader自身加载类的逻辑实质上是通过DexFile类的loadClassBinaryName方法(该方法被隐藏)完成，而该方法最终调用dalvik_system_DexFile.cpp里面的本地方法defineClass来完成，同时DexFile的实例化调用了dalvik_system_DexFile.cpp里面的openDexFile方法来完成文件加载。&lt;/p&gt;
&lt;p&gt;DexFile加载类的关键：defineClass和openDexFile方法，因为安全方面考虑，自然我们这里选择的openDexFile方法是openDexFile(byte[] fileContents)。&lt;/p&gt;
&lt;p&gt;实现自定义的DexClassLoader，那么原理上我们可以通过反射调用DexFile的defineClass和openDexFile方法。首先，从本地获取或者从网络获取到dex文件的字节流byte[] fileContents，然后反射调用openDexFile(byte[] fileContents)获得magic VM cookie值，最后反射调用defineClass(String name, ClassLoader loader, int cookie)返回加载的Class。&lt;/p&gt;
&lt;h4 id=&quot;3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2&quot;&gt;&lt;a href=&quot;#3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2&quot; class=&quot;headerlink&quot; title=&quot;3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2&quot;&gt;&lt;/a&gt;3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2&lt;/h4&gt;&lt;p&gt;该方法参考&lt;a href=&quot;http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf&quot; title=&quot;JNI实现加载Dex&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自定义DexClassLoader方式1存在一个问题，即dex的字节流存在Java层，因此相对来说还是不够安全。这种需求下，就需要开发者直接通过JNI调用底层函数解析。在dalvik_system_DexFile.cpp中，定义了DalvikNativeMethod：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const DalvikNativeMethod dvm_dalvik_system_DexFile[] = {
{ &amp;quot;openDexFile&amp;quot;,        &amp;quot;(Ljava/lang/String;Ljava/lang/String;I)I&amp;quot;,
    Dalvik_dalvik_system_DexFile_openDexFile },
{ &amp;quot;openDexFile&amp;quot;,        &amp;quot;([B)I&amp;quot;,
    Dalvik_dalvik_system_DexFile_openDexFile_bytearray },
{ &amp;quot;closeDexFile&amp;quot;,       &amp;quot;(I)V&amp;quot;,
    Dalvik_dalvik_system_DexFile_closeDexFile },
{ &amp;quot;defineClass&amp;quot;,        &amp;quot;(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;&amp;quot;,
    Dalvik_dalvik_system_DexFile_defineClass },
{ &amp;quot;getClassNameList&amp;quot;,   &amp;quot;(I)[Ljava/lang/String;&amp;quot;,
    Dalvik_dalvik_system_DexFile_getClassNameList },
{ &amp;quot;isDexOptNeeded&amp;quot;,     &amp;quot;(Ljava/lang/String;)Z&amp;quot;,
    Dalvik_dalvik_system_DexFile_isDexOptNeeded },
{ NULL, NULL, NULL },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;};&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OnLoad method + dlsym获取Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JNINativeMethod *dvm_dalvik_system_DexFile;
JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    void *ldvm = (void*)dlopen(&amp;quot;libdvm.so&amp;quot;, RTLD_LAZY);
    dvm_dalvik_system_DexFile = (JNINativeMethod*)dlsym(ldvm, &amp;quot;dvm_dalvik_system_DexFile&amp;quot;);
    void (*openDexFile)(const u4* args, JValue* pResult);
    lookup(openDexFile, &amp;quot;dvm_dalvik_system_DexFile&amp;quot;, &amp;quot;([B)I&amp;quot;, &amp;amp;openDexFile);
}

int lookup (JNINativeMethod *table, const char *name, const char *sig, void (**fnPtrout)
    (u4 const *, union JValue *)) {
     int i = 0;
     while (table[i].name != NULL) {
     if ( (strcmp(name, table[i].name) == 0) &amp;amp;&amp;amp; (strcmp(sig, table[i].signature) == 0) ) {
     *fnPtrout = table[i].fnPtr;
     return 1;
     }
     i++;
     }
     return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析Dex数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayObject *ao; // header+dex content
u4 args[] = { (u4)ao };
JValue pResult ;
jint result ;
openDexFile(args, &amp;amp;pResult);
result = (jint)pResult.l;
return result;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三步实现JAVA层Dex ClassLoader完成类的加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int cookie = openDexFile(...);
Class&amp;lt;?&amp;gt; cls = null;
String as[] = getClassNameList(cookie);
for(int z=0; z&amp;lt;as.length; z++) {
 if(as[z].equals(&amp;quot;com.immunapp.hes2013.MainActivity&amp;quot;)) {
      cls=defineClass(as[z].replace(&amp;apos;.&amp;apos;, &amp;apos;/&amp;apos;), context.getClassLoader(), cookie );
} else {
     defineClass(as[z].replace(&amp;apos;.&amp;apos;, &amp;apos;/&amp;apos;), context.getClassLoader(), cookie );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3&quot;&gt;&lt;a href=&quot;#3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3&quot; class=&quot;headerlink&quot; title=&quot;3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3&quot;&gt;&lt;/a&gt;3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3&lt;/h4&gt;&lt;p&gt;该方式源自&lt;a href=&quot;http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf&quot; title=&quot;自修改Dalvik字节码加载dex&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自定义DexClassLoader方式2也存在确定，即只支持Android4.0以上系统，因为Android4.0系统才在底层引入了Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析。要想克服这个问题，就需要自修改Dalvik字节码(即按照上面dalvik_system_DexFile.cpp的逻辑，我们自定义实现其逻辑)。大致流程如下(由于本文作者对C++不熟悉，因此只能是浅尝辄止，有兴趣的开发者可以自行实践)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;搜索内存查找DEX特征（dex\n035）&lt;/p&gt;
&lt;p&gt;  读取/proc/self/maps文件获取dex map地址,它将以_SC_PAGESIZE内存页对齐, 相对Map开始地址偏移0x28&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DEX格式解析(请参考&lt;a href=&quot;https://source.android.com/tech/dalvik/dex-format.html&quot; title=&quot;Dex格式解析&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://source.android.com/tech/dalvik/dex-format.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找到代码正确的位置&lt;/p&gt;
&lt;p&gt;  第一步定位到具体类，第二步定位到具体方法，获取方法字节码相对data section偏移量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解锁内存&lt;/p&gt;
&lt;p&gt;  mprotect((unsigned char*)aligned,PROT_WRITE | PROT_READ, len);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改相应的代码&lt;/p&gt;
&lt;p&gt;  memcpy((unsigned char*)code_off,opcodes, len);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里提供一个示例，下载地址：&lt;a href=&quot;http://172.20.154.39:8080/DemoActivity.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自修改Dalvik字节码实现Dex加载Sample&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-Android动态加载引申&quot;&gt;&lt;a href=&quot;#4-Android动态加载引申&quot; class=&quot;headerlink&quot; title=&quot;4.Android动态加载引申&quot;&gt;&lt;/a&gt;4.Android动态加载引申&lt;/h1&gt;&lt;p&gt;前面提到，Android动态加载机制的发展历程，随着需求的扩展，人们不仅仅满足于加载jar，还希望加载包含资源的jar甚至直接加载第三方APK，这样就带来更强的扩展性。我们知道，正常情况下，Android应用的APK需要安装注册，然后才能运行，怎样才能通过宿主程序打开别的APK呢，就如同通过安装运行一样。&lt;/p&gt;
&lt;p&gt;很明显，前提仍然是类和资源的动态加载，即前面章节描述的内容。但是仅仅做到这些不够，还有很多问题需要解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需加载的apk中的资源怎样引用？&lt;/li&gt;
&lt;li&gt;需加载的apk的界面就算被加载，怎么与用户交互?&lt;/li&gt;
&lt;li&gt;怎样管理加载的APK中的组件的生命周期？&lt;/li&gt;
&lt;li&gt;…等等…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需求产生动力，有了动力就有才能的发挥。聪明的人们自然会想到各种办法解决这些问题。当前，BAT等公司都有自己成熟的动态加载机制，但是不是开源的。而开源的加载机制方面，比较有影响的有：&lt;a href=&quot;https://github.com/singwhatiwanna/dynamic-load-apk&quot; title=&quot;dynamic-load-apk地址&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dynamic-load-apk&lt;/a&gt;和360的&lt;a href=&quot;https://github.com/Qihoo360/DroidPlugin&quot; title=&quot;DroidPlugin开源项目&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DroidPlugin&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;开发者如果对动态加载APK感兴趣，建议深入研究上述的开源项目，这里就不再赘述其中的原理了。里面很多思路值得借鉴，但同时还有很大的完善空间，发挥你的聪明才智，试试吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1.引言&quot;&gt;&lt;/a&gt;1.引言&lt;/h1&gt;&lt;p&gt;在Android开发中，存在一些场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在低版本的Android平台(Dalvik虚拟机执行
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="动态加载" scheme="http://cstsinghua.github.io/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android安装APK详解</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Android%E5%AE%89%E8%A3%85APK%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Android安装APK详解/</id>
    <published>2016-06-13T07:34:37.000Z</published>
    <updated>2016-12-21T06:40:20.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;众所周知，Android应用最终是打包成.apk格式（其实就是一个压缩包），然后安装至手机并运行的。APK即Android Package的缩写，那么，Android安装应用APK的具体方式及其详细过程是怎样的呢？下面，我们逐一揭开里面的层层面纱。&lt;/p&gt;
&lt;h2 id=&quot;Android应用APK安装的方式&quot;&gt;&lt;a href=&quot;#Android应用APK安装的方式&quot; class=&quot;headerlink&quot; title=&quot;Android应用APK安装的方式&quot;&gt;&lt;/a&gt;Android应用APK安装的方式&lt;/h2&gt;&lt;p&gt;一般而言，Android应用安装有如下四种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;系统应用安装&lt;/strong&gt;：开机时加载系统的APK和应用，没有安装界面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络下载应用安装&lt;/strong&gt;：通过各种market应用完成，没有安装界面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADB工具安装&lt;/strong&gt;：即通过Android的SDK开发tools里面的adb.exe程序安装，没有安装界面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三方应用安装&lt;/strong&gt;：通过SD卡里的APK文件安装(比如双击APK文件触发)，有安装界面，系统默认已经安装了一个安装卸载应用的程序，即由packageinstaller.apk应用处理安装及卸载过程的界面。&lt;h2 id=&quot;Android-APK安装概述&quot;&gt;&lt;a href=&quot;#Android-APK安装概述&quot; class=&quot;headerlink&quot; title=&quot;Android APK安装概述&quot;&gt;&lt;/a&gt;Android APK安装概述&lt;/h2&gt;&lt;h3 id=&quot;应用安装涉及到的目录&quot;&gt;&lt;a href=&quot;#应用安装涉及到的目录&quot; class=&quot;headerlink&quot; title=&quot;应用安装涉及到的目录&quot;&gt;&lt;/a&gt;应用安装涉及到的目录&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;/system/app       ：系统自带的应用程序，获得adb root权限才能删除&lt;/li&gt;
&lt;li&gt;/data/app         ：用户程序安装的目录。安装时把apk文件复制到此目录&lt;/li&gt;
&lt;li&gt;/data/data        ：存放应用程序的数据&lt;/li&gt;
&lt;li&gt;/data/dalvik-cache：将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,当然，ART–Android Runtime的可执行文件格式为oat，启用ART时，系统会执行dex文件转换至oat文件)   &lt;/li&gt;
&lt;li&gt;&lt;p&gt;/data/system      ：该目录下的packages.xml文件，类似于Windows的注册表，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。&lt;/p&gt;
&lt;p&gt; /data/system/packages.xml中内容详解(这里列举的标签内容不一定完整，只是列举核心内容，packages.xml的完整定义详见官方文档)：&lt;br&gt; 该文件的根节点是&lt;packages&gt;…&lt;/packages&gt;，内容树结构如下图所示：&lt;br&gt; &lt;img src=&quot;http://i.imgur.com/9QZs6oN.png&quot; alt=&quot;/data/system/packages.xml结构图&quot;&gt;&lt;/p&gt;
&lt;p&gt; (1)permissions标签定义了目前系统中定义的所有权限。主要分为两类：系统定义的（package属性为android）和APK定义的（package属性为APK的包名）。&lt;/p&gt;
&lt;p&gt; (2)package代表一个APK的属性，它的属性含义如下（这里并未完全列出，如需了解全部属性，请查看官方文档）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name：APK的包名

codePath:安装路径。有/system/app系统APK和/data/app两种。/system/app存放系统出厂时预置的一些APK，/data/app存放用户安装的第三方APK。

system:如果APK被安装在/system/app下，system的值为true；安装在/data/app下面的话，值为true。

ts:时间戳

version:APK的版本号

sharedUserId/userId:Android系统启动一个普通的APK时，会为这个APK分配一个独立的UID，这就是userId。如果APK要和系统中其它APK使用相同的UID的话，那就是sharedUserId。关于共享UID，下面有更详细的描述。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  package的子标签perms:APK的AndroidManifest.xml文件中，每使用一个&lt;uses-permission&gt;标签，&lt;perms&gt;标签中就会增加一项。&lt;/perms&gt;&lt;/uses-permission&gt;&lt;/p&gt;
&lt;p&gt; (3)&lt;shared-user&gt;代表一个共享UID，通常，共同实现一系列相似功能的APK共享一个UID。其子标签&lt;perms&gt;中的权限代表了这个共享UID的权限，所有使用的同一个共享UID的APK运行在同一进程中，这个进程的UID就是这个共享UID，这些APK都具有这个共享UID的权限。其属性包括：&lt;/perms&gt;&lt;/shared-user&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name:共享UID的名字，在APK的android:sharedUserId属性中使用。

userId：使用这个共享UID的所有APK运行时所在的进程的UID。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;安装过程总述&quot;&gt;&lt;a href=&quot;#安装过程总述&quot; class=&quot;headerlink&quot; title=&quot;安装过程总述&quot;&gt;&lt;/a&gt;安装过程总述&lt;/h3&gt;&lt;p&gt;安卓系统安装一个应用时，系统大致会进行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制APK安装包到data/app目录下，文件名会以应用的package命名；&lt;/li&gt;
&lt;li&gt;解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录(一般情况下，会先执行dexopt即dex文件的优化，将优化后的dex文件保存至该目录下)，并data/data目录下创建对应的应用数据目录(data/data目录可读可写)；&lt;/li&gt;
&lt;li&gt;更新/data/system/packages.xml中的内容，将APK的信息加入进去。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;卸载过程概述&quot;&gt;&lt;a href=&quot;#卸载过程概述&quot; class=&quot;headerlink&quot; title=&quot;卸载过程概述&quot;&gt;&lt;/a&gt;卸载过程概述&lt;/h3&gt;&lt;p&gt;对照安装过程，卸载过程与之相逆：&lt;/p&gt;
&lt;p&gt;删除安装过程中在上述目录下创建的文件及目录。&lt;/p&gt;
&lt;h2 id=&quot;安装应用的过程代码解析&quot;&gt;&lt;a href=&quot;#安装应用的过程代码解析&quot; class=&quot;headerlink&quot; title=&quot;安装应用的过程代码解析&quot;&gt;&lt;/a&gt;安装应用的过程代码解析&lt;/h2&gt;&lt;p&gt;鉴于APK安装有四种方式，这里分别对各种方式下的安装详细过程进行代码级的解析。&lt;/p&gt;
&lt;h3 id=&quot;安装过程代码解析的前奏&quot;&gt;&lt;a href=&quot;#安装过程代码解析的前奏&quot; class=&quot;headerlink&quot; title=&quot;安装过程代码解析的前奏&quot;&gt;&lt;/a&gt;安装过程代码解析的前奏&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;注意：由于Android API迭代较快，版本众多，不过关于安装和卸载的逻辑核心（代码主干）是不变的，最新level级别的API可能会加入更多分支或细节完善代码，一般建议以低版本的API作为分析基础，这样便于更加快速地厘清代码流程和主干，本文以API level14的源码做切入点,引用源代码部分前面的数字表示行号，对应于源文件里面的行号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，Android里面的包信息管理、安装和卸载等均是通过android/content/pm/PackageManager.java()这个类来完成的。而获取PackageManager的方式一般是：android/content/Context.getPackageManager()方法获取。&lt;/p&gt;
&lt;p&gt;查看Context.java，可以发现Context类是抽象的，getPackageManager()也是抽象的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Interface to global information about an application environment.  This is
 * an abstract class whose implementation is provided by
 * the Android system.  It
 * allows access to application-specific resources and classes, as well as
 * up-calls for application-level operations such as launching activities,
 * broadcasting and receiving intents, etc.
 */
51 public abstract class Context {
       ...
196       /** Return PackageManager instance to find global package information. */
197       public abstract PackageManager getPackageManager();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而Context的具体实现是android/app/ContextImpl.java里面的ContextImpl类，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Common implementation of Context API, which provides the base
 * context object for Activity and other application components.
 */
138 class ContextImpl extends Context {
        ...
481        @Override
482        public PackageManager getPackageManager() {
483            if (mPackageManager != null) {
484                return mPackageManager;
485            }
486
487            IPackageManager pm = ActivityThread.getPackageManager();
488            if (pm != null) {
489               // Doesn&amp;apos;t matter if we make more than one instance.
490                return (mPackageManager = new ApplicationPackageManager(this, pm));
491            }
492
493            return null;
494        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，获取到的实际上是android/app/ApplicationPackageManager.java定义的ApplicationPackageManager类的实例。进入ApplicationPackageManager.java，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;60    /*package*/
61    final class ApplicationPackageManager extends PackageManager {
        ...
723        ApplicationPackageManager(ContextImpl context,
724                          IPackageManager pm) {
725            mContext = context;
726            mPM = pm;
727        }
        ...
934        @Override
935        public void installPackage(Uri packageURI, IPackageInstallObserver observer, int flags,
936                                   String installerPackageName) {
937            try {
938                mPM.installPackage(packageURI, observer, flags, installerPackageName);
939            } catch (RemoteException e) {
940                // Should never happen!
941            }
942        }
943
944        @Override
945        public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer,
946                int flags, String installerPackageName, Uri verificationURI,
947                ManifestDigest manifestDigest) {
948            try {
949                mPM.installPackageWithVerification(packageURI, observer, flags, installerPackageName,
950                        verificationURI, manifestDigest);
951            } catch (RemoteException e) {
952                // Should never happen!
953            }
954        }
955
956        @Override
957        public void verifyPendingInstall(int id, int response) {
958            try {
959                mPM.verifyPendingInstall(id, response);
960            } catch (RemoteException e) {
961                // Should never happen!
962            }
963        }
        ...
1226    private final IPackageManager mPM;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进入ApplicationPackageManager，其继承了PackageManager，这里其实采用了组合模式，其实ApplicationPackageManager的installPackage方法内部是调用内部组合变量mPM的installPackage方法，其实其他继承自PackageManager的方法的内部逻辑也都是实际调用了mPM变量的对应方法。而mPM变量是在ApplicationPackageManager的构造方法传入(726行，mPM = pm;)，因此回滚到Context.java的487行(IPackageManager pm = ActivityThread.getPackageManager();),这里的pm就是最终执行安装或者其他操作的对象。跟踪下去，android/app/ActivityThread.java：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;114    /**
115     * This manages the execution of the main thread in an
116     * application process, scheduling and executing activities,
117     * broadcasts, and other operations on it as the activity
118     * manager requests.
119     *
120     * {@hide}
121     */
122    public final class ActivityThread {
        ...
1395    public static IPackageManager getPackageManager() {
1396        if (sPackageManager != null) {
1397            //Slog.v(&amp;quot;PackageManager&amp;quot;, &amp;quot;returning cur default = &amp;quot; + sPackageManager);
1398            return sPackageManager;
1399        }
1400        IBinder b = ServiceManager.getService(&amp;quot;package&amp;quot;);
1401        //Slog.v(&amp;quot;PackageManager&amp;quot;, &amp;quot;default service binder = &amp;quot; + b);
1402        sPackageManager = IPackageManager.Stub.asInterface(b);
1403        //Slog.v(&amp;quot;PackageManager&amp;quot;, &amp;quot;default service = &amp;quot; + sPackageManager);
1404        return sPackageManager;
1405    }
1406    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面代码可以发现，最终返回的IPackageManager的实例对象是通过绑定系统的package服务获取到的，熟悉Android的朋友应该清楚，这实际就是调用PackageManager对应的service来完成。至此，可以明确PackageManager类的安装等等操作实际是通过com/android、server/pm/PackageManagerService.java中定义的类PackageManagerService来完成，其详细代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;140        /**
141         * Keep track of all those .apks everywhere.
142         * 
143         * This is very central to the platform&amp;apos;s security; please run the unit
144         * tests whenever making modifications here:
145         * 
146        mmm frameworks/base/tests/AndroidTests
147        adb install -r -f out/target/product/passion/data/app/AndroidTests.apk
148        adb shell am instrument -w -e class com.android.unit_tests.PackageManagerTests com.android.unit_tests/android.test.InstrumentationTestRunner
149         * 
150         * {@hide}
151         */
152        public class PackageManagerService extends IPackageManager.Stub {
            ...
439            class PackageHandler extends Handler {
440                private boolean mBound = false;
441                final ArrayList&amp;lt;HandlerParams&amp;gt; mPendingInstalls =
442                    new ArrayList&amp;lt;HandlerParams&amp;gt;();
443
444                private boolean connectToService() {
445                    if (DEBUG_SD_INSTALL) Log.i(TAG, &amp;quot;Trying to bind to&amp;quot; +
446                            &amp;quot; DefaultContainerService&amp;quot;);
447                    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
448                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
449                    if (mContext.bindService(service, mDefContainerConn,
450                            Context.BIND_AUTO_CREATE)) {
451                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
452                        mBound = true;
453                        return true;
454                    }
455                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
456                    return false;
457                }
458
459                private void disconnectService() {
460                    mContainerService = null;
461                    mBound = false;
462                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
463                    mContext.unbindService(mDefContainerConn);
464                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
465                }
466
467                PackageHandler(Looper looper) {
468                    super(looper);
469                }
470
471                public void handleMessage(Message msg) {
472                    try {
473                        doHandleMessage(msg);
474                    } finally {
475                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
476                    }
477                }
478                
479                void doHandleMessage(Message msg) {
480                    switch (msg.what) {
481                        case INIT_COPY: {
482                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;init_copy&amp;quot;);
483                            HandlerParams params = (HandlerParams) msg.obj;
484                            int idx = mPendingInstalls.size();
485                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;idx=&amp;quot; + idx);
486                            // If a bind was already initiated we dont really
487                            // need to do anything. The pending install
488                            // will be processed later on.
489                            if (!mBound) {
490                                // If this is the only one pending we might
491                                // have to bind to the service again.
492                                if (!connectToService()) {
493                                    Slog.e(TAG, &amp;quot;Failed to bind to media container service&amp;quot;);
494                                    params.serviceError();
495                                    return;
496                                } else {
497                                    // Once we bind to the service, the first
498                                    // pending request will be processed.
499                                    mPendingInstalls.add(idx, params);
500                                }
501                            } else {
502                                mPendingInstalls.add(idx, params);
503                                // Already bound to the service. Just make
504                                // sure we trigger off processing the first request.
505                                if (idx == 0) {
506                                    mHandler.sendEmptyMessage(MCS_BOUND);
507                                }
508                            }
509                            break;
510                        }
511                        case MCS_BOUND: {
512                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;mcs_bound&amp;quot;);
513                            if (msg.obj != null) {
514                                mContainerService = (IMediaContainerService) msg.obj;
515                            }
516                            if (mContainerService == null) {
517                                // Something seriously wrong. Bail out
518                                Slog.e(TAG, &amp;quot;Cannot bind to media container service&amp;quot;);
519                                for (HandlerParams params : mPendingInstalls) {
520                                    mPendingInstalls.remove(0);
521                                    // Indicate service bind error
522                                    params.serviceError();
523                                }
524                                mPendingInstalls.clear();
525                            } else if (mPendingInstalls.size() &amp;gt; 0) {
526                                HandlerParams params = mPendingInstalls.get(0);
527                                if (params != null) {
528                                    if (params.startCopy()) {
529                                        // We are done...  look for more work or to
530                                        // go idle.
531                                        if (DEBUG_SD_INSTALL) Log.i(TAG,
532                                                &amp;quot;Checking for more work or unbind...&amp;quot;);
533                                        // Delete pending install
534                                        if (mPendingInstalls.size() &amp;gt; 0) {
535                                            mPendingInstalls.remove(0);
536                                        }
537                                        if (mPendingInstalls.size() == 0) {
538                                            if (mBound) {
539                                                if (DEBUG_SD_INSTALL) Log.i(TAG,
540                                                        &amp;quot;Posting delayed MCS_UNBIND&amp;quot;);
541                                                removeMessages(MCS_UNBIND);
542                                                Message ubmsg = obtainMessage(MCS_UNBIND);
543                                                // Unbind after a little delay, to avoid
544                                                // continual thrashing.
545                                                sendMessageDelayed(ubmsg, 10000);
546                                            }
547                                        } else {
548                                            // There are more pending requests in queue.
549                                            // Just post MCS_BOUND message to trigger processing
550                                            // of next pending install.
551                                            if (DEBUG_SD_INSTALL) Log.i(TAG,
552                                                    &amp;quot;Posting MCS_BOUND for next woek&amp;quot;);
553                                            mHandler.sendEmptyMessage(MCS_BOUND);
554                                        }
555                                    }
556                                }
557                            } else {
558                                // Should never happen ideally.
559                                Slog.w(TAG, &amp;quot;Empty queue&amp;quot;);
560                            }
561                            break;
562                        }
563                        case MCS_RECONNECT: {
564                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;mcs_reconnect&amp;quot;);
565                            if (mPendingInstalls.size() &amp;gt; 0) {
566                                if (mBound) {
567                                    disconnectService();
568                                }
569                                if (!connectToService()) {
570                                    Slog.e(TAG, &amp;quot;Failed to bind to media container service&amp;quot;);
571                                    for (HandlerParams params : mPendingInstalls) {
572                                        mPendingInstalls.remove(0);
573                                        // Indicate service bind error
574                                        params.serviceError();
575                                    }
576                                    mPendingInstalls.clear();
577                                }
578                            }
579                            break;
580                        }
581                        case MCS_UNBIND: {
582                            // If there is no actual work left, then time to unbind.
583                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;mcs_unbind&amp;quot;);
584
585                            if (mPendingInstalls.size() == 0 &amp;amp;&amp;amp; mPendingVerification.size() == 0) {
586                                if (mBound) {
587                                    if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;calling disconnectService()&amp;quot;);
588
589                                    disconnectService();
590                                }
591                            } else if (mPendingInstalls.size() &amp;gt; 0) {
592                                // There are more pending requests in queue.
593                                // Just post MCS_BOUND message to trigger processing
594                                // of next pending install.
595                                mHandler.sendEmptyMessage(MCS_BOUND);
596                            }
597
598                            break;
599                        }
600                        case MCS_GIVE_UP: {
601                            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;mcs_giveup too many retries&amp;quot;);
602                            mPendingInstalls.remove(0);
603                            break;
604                        }
605                        case SEND_PENDING_BROADCAST: {
606                            String packages[];
607                            ArrayList&amp;lt;String&amp;gt; components[];
608                            int size = 0;
609                            int uids[];
610                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
611                            synchronized (mPackages) {
612                                if (mPendingBroadcasts == null) {
613                                    return;
614                                }
615                                size = mPendingBroadcasts.size();
616                                if (size &amp;lt;= 0) {
617                                    // Nothing to be done. Just return
618                                    return;
619                                }
620                                packages = new String[size];
621                                components = new ArrayList[size];
622                                uids = new int[size];
623                                Iterator&amp;lt;HashMap.Entry&amp;lt;String, ArrayList&amp;lt;String&amp;gt;&amp;gt;&amp;gt;
624                                        it = mPendingBroadcasts.entrySet().iterator();
625                                int i = 0;
626                                while (it.hasNext() &amp;amp;&amp;amp; i &amp;lt; size) {
627                                    HashMap.Entry&amp;lt;String, ArrayList&amp;lt;String&amp;gt;&amp;gt; ent = it.next();
628                                    packages[i] = ent.getKey();
629                                    components[i] = ent.getValue();
630                                    PackageSetting ps = mSettings.mPackages.get(ent.getKey());
631                                    uids[i] = (ps != null) ? ps.userId : -1;
632                                    i++;
633                                }
634                                size = i;
635                                mPendingBroadcasts.clear();
636                            }
637                            // Send broadcasts
638                            for (int i = 0; i &amp;lt; size; i++) {
639                                sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
640                            }
641                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
642                            break;
643                        }
644                        case START_CLEANING_PACKAGE: {
645                            String packageName = (String)msg.obj;
646                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
647                            synchronized (mPackages) {
648                                if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
649                                    mSettings.mPackagesToBeCleaned.add(packageName);
650                                }
651                            }
652                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
653                            startCleaningPackages();
654                        } break;
655                        case POST_INSTALL: {
656                            if (DEBUG_INSTALL) Log.v(TAG, &amp;quot;Handling post-install for &amp;quot; + msg.arg1);
657                            PostInstallData data = mRunningInstalls.get(msg.arg1);
658                            mRunningInstalls.delete(msg.arg1);
659                            boolean deleteOld = false;
660
661                            if (data != null) {
662                                InstallArgs args = data.args;
663                                PackageInstalledInfo res = data.res;
664
665                                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
666                                    res.removedInfo.sendBroadcast(false, true);
667                                    Bundle extras = new Bundle(1);
668                                    extras.putInt(Intent.EXTRA_UID, res.uid);
669                                    final boolean update = res.removedInfo.removedPackage != null;
670                                    if (update) {
671                                        extras.putBoolean(Intent.EXTRA_REPLACING, true);
672                                    }
673                                    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,
674                                            res.pkg.applicationInfo.packageName,
675                                            extras, null, null);
676                                    if (update) {
677                                        sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,
678                                                res.pkg.applicationInfo.packageName,
679                                                extras, null, null);
680                                        sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,
681                                                null, null,
682                                                res.pkg.applicationInfo.packageName, null);
683                                    }
684                                    if (res.removedInfo.args != null) {
685                                        // Remove the replaced package&amp;apos;s older resources safely now
686                                        deleteOld = true;
687                                    }
688                                }
689                                // Force a gc to clear up things
690                                Runtime.getRuntime().gc();
691                                // We delete after a gc for applications  on sdcard.
692                                if (deleteOld) {
693                                    synchronized (mInstallLock) {
694                                        res.removedInfo.args.doPostDeleteLI(true);
695                                    }
696                                }
697                                if (args.observer != null) {
698                                    try {
699                                        args.observer.packageInstalled(res.name, res.returnCode);
700                                    } catch (RemoteException e) {
701                                        Slog.i(TAG, &amp;quot;Observer no longer exists.&amp;quot;);
702                                    }
703                                }
704                            } else {
705                                Slog.e(TAG, &amp;quot;Bogus post-install token &amp;quot; + msg.arg1);
706                            }
707                        } break;
708                        case UPDATED_MEDIA_STATUS: {
709                            if (DEBUG_SD_INSTALL) Log.i(TAG, &amp;quot;Got message UPDATED_MEDIA_STATUS&amp;quot;);
710                            boolean reportStatus = msg.arg1 == 1;
711                            boolean doGc = msg.arg2 == 1;
712                            if (DEBUG_SD_INSTALL) Log.i(TAG, &amp;quot;reportStatus=&amp;quot; + reportStatus + &amp;quot;, doGc = &amp;quot; + doGc);
713                            if (doGc) {
714                                // Force a gc to clear up stale containers.
715                                Runtime.getRuntime().gc();
716                            }
717                            if (msg.obj != null) {
718                                @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
719                                Set&amp;lt;SdInstallArgs&amp;gt; args = (Set&amp;lt;SdInstallArgs&amp;gt;) msg.obj;
720                                if (DEBUG_SD_INSTALL) Log.i(TAG, &amp;quot;Unloading all containers&amp;quot;);
721                                // Unload containers
722                                unloadAllContainers(args);
723                            }
724                            if (reportStatus) {
725                                try {
726                                    if (DEBUG_SD_INSTALL) Log.i(TAG, &amp;quot;Invoking MountService call back&amp;quot;);
727                                    PackageHelper.getMountService().finishMediaUpdate();
728                                } catch (RemoteException e) {
729                                    Log.e(TAG, &amp;quot;MountService not running?&amp;quot;);
730                                }
731                            }
732                        } break;
733                        case WRITE_SETTINGS: {
734                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
735                            synchronized (mPackages) {
736                                removeMessages(WRITE_SETTINGS);
737                                removeMessages(WRITE_STOPPED_PACKAGES);
738                                mSettings.writeLPr();
739                            }
740                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
741                        } break;
742                        case WRITE_STOPPED_PACKAGES: {
743                            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
744                            synchronized (mPackages) {
745                                removeMessages(WRITE_STOPPED_PACKAGES);
746                                mSettings.writeStoppedLPr();
747                            }
748                            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
749                        } break;
750                        case CHECK_PENDING_VERIFICATION: {
751                            final int verificationId = msg.arg1;
752                            final PackageVerificationState state = mPendingVerification.get(verificationId);
753
754                            if (state != null) {
755                                final InstallArgs args = state.getInstallArgs();
756                                Slog.i(TAG, &amp;quot;Verification timed out for &amp;quot; + args.packageURI.toString());
757                                mPendingVerification.remove(verificationId);
758
759                                int ret = PackageManager.INSTALL_FAILED_VERIFICATION_TIMEOUT;
760                                processPendingInstall(args, ret);
761
762                                mHandler.sendEmptyMessage(MCS_UNBIND);
763                            }
764
765                            break;
766                        }
767                        case PACKAGE_VERIFIED: {
768                            final int verificationId = msg.arg1;
769
770                            final PackageVerificationState state = mPendingVerification.get(verificationId);
771                            if (state == null) {
772                                Slog.w(TAG, &amp;quot;Invalid verification token &amp;quot; + verificationId + &amp;quot; received&amp;quot;);
773                                break;
774                            }
775
776                            final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
777
778                            state.setVerifierResponse(response.callerUid, response.code);
779
780                            if (state.isVerificationComplete()) {
781                                mPendingVerification.remove(verificationId);
782
783                                final InstallArgs args = state.getInstallArgs();
784
785                                int ret;
786                                if (state.isInstallAllowed()) {
787                                    ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
788                                    try {
789                                        ret = args.copyApk(mContainerService, true);
790                                    } catch (RemoteException e) {
791                                        Slog.e(TAG, &amp;quot;Could not contact the ContainerService&amp;quot;);
792                                    }
793                                } else {
794                                    ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
795                                }
796
797                                processPendingInstall(args, ret);
798
799                                mHandler.sendEmptyMessage(MCS_UNBIND);
800                            }
801
802                            break;
803                        }
804                    }
805                }
806            }
            ...
            ...
831            public static final IPackageManager main(Context context, boolean factoryTest,
832                    boolean onlyCore) {
833                PackageManagerService m = new PackageManagerService(context, factoryTest, onlyCore);
834                ServiceManager.addService(&amp;quot;package&amp;quot;, m);
835                return m;
836            }
            ...
            ...
860         public PackageManagerService(Context context, boolean factoryTest, boolean onlyCore) {
861             EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,
862                     SystemClock.uptimeMillis());
863 
864             if (mSdkVersion &amp;lt;= 0) {
865                 Slog.w(TAG, &amp;quot;**** ro.build.version.sdk not set!&amp;quot;);
866             }
867 
868             mContext = context;
869             mFactoryTest = factoryTest;
870             mOnlyCore = onlyCore;
871             mNoDexOpt = &amp;quot;eng&amp;quot;.equals(SystemProperties.get(&amp;quot;ro.build.type&amp;quot;));
872             mMetrics = new DisplayMetrics();
873             mSettings = new Settings();
874             mSettings.addSharedUserLPw(&amp;quot;android.uid.system&amp;quot;,
875                     Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
876             mSettings.addSharedUserLPw(&amp;quot;android.uid.phone&amp;quot;,
877                     MULTIPLE_APPLICATION_UIDS
878                             ? RADIO_UID : FIRST_APPLICATION_UID,
879                     ApplicationInfo.FLAG_SYSTEM);
880             mSettings.addSharedUserLPw(&amp;quot;android.uid.log&amp;quot;,
881                     MULTIPLE_APPLICATION_UIDS
882                             ? LOG_UID : FIRST_APPLICATION_UID,
883                     ApplicationInfo.FLAG_SYSTEM);
884             mSettings.addSharedUserLPw(&amp;quot;android.uid.nfc&amp;quot;,
885                     MULTIPLE_APPLICATION_UIDS
886                             ? NFC_UID : FIRST_APPLICATION_UID,
887                     ApplicationInfo.FLAG_SYSTEM);
888 
889             String separateProcesses = SystemProperties.get(&amp;quot;debug.separate_processes&amp;quot;);
890             if (separateProcesses != null &amp;amp;&amp;amp; separateProcesses.length() &amp;gt; 0) {
891                 if (&amp;quot;*&amp;quot;.equals(separateProcesses)) {
892                     mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;
893                     mSeparateProcesses = null;
894                     Slog.w(TAG, &amp;quot;Running with debug.separate_processes: * (ALL)&amp;quot;);
895                 } else {
896                     mDefParseFlags = 0;
897                     mSeparateProcesses = separateProcesses.split(&amp;quot;,&amp;quot;);
898                     Slog.w(TAG, &amp;quot;Running with debug.separate_processes: &amp;quot;
899                             + separateProcesses);
900                 }
901             } else {
902                 mDefParseFlags = 0;
903                 mSeparateProcesses = null;
904             }
905 
906             mInstaller = new Installer();
907 
908             WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
909             Display d = wm.getDefaultDisplay();
910             d.getMetrics(mMetrics);
911 
912             synchronized (mInstallLock) {
913             // writer
914             synchronized (mPackages) {
915                 mHandlerThread.start();
916                 mHandler = new PackageHandler(mHandlerThread.getLooper());
917 
918                 File dataDir = Environment.getDataDirectory();
919                 mAppDataDir = new File(dataDir, &amp;quot;data&amp;quot;);
920                 mUserAppDataDir = new File(dataDir, &amp;quot;user&amp;quot;);
921                 mDrmAppPrivateInstallDir = new File(dataDir, &amp;quot;app-private&amp;quot;);
922 
923                 mUserManager = new UserManager(mInstaller, mUserAppDataDir);
924 
925                 readPermissions();
926 
927                 mRestoredSettings = mSettings.readLPw();
928                 long startTime = SystemClock.uptimeMillis();
929 
930                 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,
931                         startTime);
932 
933                 // Set flag to monitor and not change apk file paths when
934                 // scanning install directories.
935                 int scanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;
936                 if (mNoDexOpt) {
937                     Slog.w(TAG, &amp;quot;Running ENG build: no pre-dexopt!&amp;quot;);
938                     scanMode |= SCAN_NO_DEX;
939                 }
940 
941                 final HashSet&amp;lt;String&amp;gt; libFiles = new HashSet&amp;lt;String&amp;gt;();
942 
943                 mFrameworkDir = new File(Environment.getRootDirectory(), &amp;quot;framework&amp;quot;);
944                 mDalvikCacheDir = new File(dataDir, &amp;quot;dalvik-cache&amp;quot;);
945 
946                 boolean didDexOpt = false;
947 
948                 /**
949                  * Out of paranoia, ensure that everything in the boot class
950                  * path has been dexed.
951                  */
952                 String bootClassPath = System.getProperty(&amp;quot;java.boot.class.path&amp;quot;);
953                 if (bootClassPath != null) {
954                     String[] paths = splitString(bootClassPath, &amp;apos;:&amp;apos;);
955                     for (int i=0; i&amp;lt;paths.length; i++) {
956                         try {
957                             if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
958                                 libFiles.add(paths[i]);
959                                 mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true);
960                                 didDexOpt = true;
961                             }
962                         } catch (FileNotFoundException e) {
963                             Slog.w(TAG, &amp;quot;Boot class path not found: &amp;quot; + paths[i]);
964                         } catch (IOException e) {
965                             Slog.w(TAG, &amp;quot;Cannot dexopt &amp;quot; + paths[i] + &amp;quot;; is it an APK or JAR? &amp;quot;
966                                     + e.getMessage());
967                         }
968                     }
969                 } else {
970                     Slog.w(TAG, &amp;quot;No BOOTCLASSPATH found!&amp;quot;);
971                 }
972 
973                 /**
974                  * Also ensure all external libraries have had dexopt run on them.
975                  */
976                 if (mSharedLibraries.size() &amp;gt; 0) {
977                     Iterator&amp;lt;String&amp;gt; libs = mSharedLibraries.values().iterator();
978                     while (libs.hasNext()) {
979                         String lib = libs.next();
980                         try {
981                             if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
982                                 libFiles.add(lib);
983                                 mInstaller.dexopt(lib, Process.SYSTEM_UID, true);
984                                 didDexOpt = true;
985                             }
986                         } catch (FileNotFoundException e) {
987                             Slog.w(TAG, &amp;quot;Library not found: &amp;quot; + lib);
988                         } catch (IOException e) {
989                             Slog.w(TAG, &amp;quot;Cannot dexopt &amp;quot; + lib + &amp;quot;; is it an APK or JAR? &amp;quot;
990                                     + e.getMessage());
991                         }
992                     }
993                 }
994 
995                 // Gross hack for now: we know this file doesn&amp;apos;t contain any
996                 // code, so don&amp;apos;t dexopt it to avoid the resulting log spew.
997                 libFiles.add(mFrameworkDir.getPath() + &amp;quot;/framework-res.apk&amp;quot;);
998 
999                 /**
1000                 * And there are a number of commands implemented in Java, which
1001                 * we currently need to do the dexopt on so that they can be
1002                 * run from a non-root shell.
1003                 */
1004                String[] frameworkFiles = mFrameworkDir.list();
1005                if (frameworkFiles != null) {
1006                    for (int i=0; i&amp;lt;frameworkFiles.length; i++) {
1007                        File libPath = new File(mFrameworkDir, frameworkFiles[i]);
1008                        String path = libPath.getPath();
1009                        // Skip the file if we alrady did it.
1010                        if (libFiles.contains(path)) {
1011                            continue;
1012                        }
1013                        // Skip the file if it is not a type we want to dexopt.
1014                        if (!path.endsWith(&amp;quot;.apk&amp;quot;) &amp;amp;&amp;amp; !path.endsWith(&amp;quot;.jar&amp;quot;)) {
1015                            continue;
1016                        }
1017                        try {
1018                            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
1019                                mInstaller.dexopt(path, Process.SYSTEM_UID, true);
1020                                didDexOpt = true;
1021                            }
1022                        } catch (FileNotFoundException e) {
1023                            Slog.w(TAG, &amp;quot;Jar not found: &amp;quot; + path);
1024                        } catch (IOException e) {
1025                            Slog.w(TAG, &amp;quot;Exception reading jar: &amp;quot; + path, e);
1026                        }
1027                    }
1028                }
1029
1030                if (didDexOpt) {
1031                    // If we had to do a dexopt of one of the previous
1032                    // things, then something on the system has changed.
1033                    // Consider this significant, and wipe away all other
1034                    // existing dexopt files to ensure we don&amp;apos;t leave any
1035                    // dangling around.
1036                    String[] files = mDalvikCacheDir.list();
1037                    if (files != null) {
1038                        for (int i=0; i&amp;lt;files.length; i++) {
1039                            String fn = files[i];
1040                            if (fn.startsWith(&amp;quot;data@app@&amp;quot;)
1041                                    || fn.startsWith(&amp;quot;data@app-private@&amp;quot;)) {
1042                                Slog.i(TAG, &amp;quot;Pruning dalvik file: &amp;quot; + fn);
1043                                (new File(mDalvikCacheDir, fn)).delete();
1044                            }
1045                        }
1046                    }
1047                }
1048
1049                // Find base frameworks (resource packages without code).
1050                mFrameworkInstallObserver = new AppDirObserver(
1051                    mFrameworkDir.getPath(), OBSERVER_EVENTS, true);
1052                mFrameworkInstallObserver.startWatching();
1053                scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM
1054                        | PackageParser.PARSE_IS_SYSTEM_DIR,
1055                        scanMode | SCAN_NO_DEX, 0);
1056                
1057                // Collect all system packages.
1058                mSystemAppDir = new File(Environment.getRootDirectory(), &amp;quot;app&amp;quot;);
1059                mSystemInstallObserver = new AppDirObserver(
1060                    mSystemAppDir.getPath(), OBSERVER_EVENTS, true);
1061                mSystemInstallObserver.startWatching();
1062                scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM
1063                        | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);
1064                
1065                // Collect all vendor packages.
1066                mVendorAppDir = new File(&amp;quot;/vendor/app&amp;quot;);
1067                mVendorInstallObserver = new AppDirObserver(
1068                    mVendorAppDir.getPath(), OBSERVER_EVENTS, true);
1069                mVendorInstallObserver.startWatching();
1070                scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM
1071                        | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);
1072
1073                if (DEBUG_UPGRADE) Log.v(TAG, &amp;quot;Running installd update commands&amp;quot;);
1074                mInstaller.moveFiles();
1075
1076                // Prune any system packages that no longer exist.
1077                if (!mOnlyCore) {
1078                    Iterator&amp;lt;PackageSetting&amp;gt; psit = mSettings.mPackages.values().iterator();
1079                    while (psit.hasNext()) {
1080                        PackageSetting ps = psit.next();
1081                        if ((ps.pkgFlags&amp;amp;ApplicationInfo.FLAG_SYSTEM) != 0
1082                                &amp;amp;&amp;amp; !mPackages.containsKey(ps.name)
1083                                &amp;amp;&amp;amp; !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
1084                            psit.remove();
1085                            String msg = &amp;quot;System package &amp;quot; + ps.name
1086                                    + &amp;quot; no longer exists; wiping its data&amp;quot;;
1087                            reportSettingsProblem(Log.WARN, msg);
1088                            mInstaller.remove(ps.name, 0);
1089                            mUserManager.removePackageForAllUsers(ps.name);
1090                        }
1091                    }
1092                }
1093                
1094                mAppInstallDir = new File(dataDir, &amp;quot;app&amp;quot;);
1095                //look for any incomplete package installations
1096                ArrayList&amp;lt;PackageSetting&amp;gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();
1097                //clean up list
1098                for(int i = 0; i &amp;lt; deletePkgsList.size(); i++) {
1099                    //clean up here
1100                    cleanupInstallFailedPackage(deletePkgsList.get(i));
1101                }
1102                //delete tmp files
1103                deleteTempPackageFiles();
1104
1105                if (!mOnlyCore) {
1106                    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,
1107                            SystemClock.uptimeMillis());
1108                    mAppInstallObserver = new AppDirObserver(
1109                        mAppInstallDir.getPath(), OBSERVER_EVENTS, false);
1110                    mAppInstallObserver.startWatching();
1111                    scanDirLI(mAppInstallDir, 0, scanMode, 0);
1112        
1113                    mDrmAppInstallObserver = new AppDirObserver(
1114                        mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false);
1115                    mDrmAppInstallObserver.startWatching();
1116                    scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,
1117                            scanMode, 0);
1118                } else {
1119                    mAppInstallObserver = null;
1120                    mDrmAppInstallObserver = null;
1121                }
1122
1123                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,
1124                        SystemClock.uptimeMillis());
1125                Slog.i(TAG, &amp;quot;Time to scan packages: &amp;quot;
1126                        + ((SystemClock.uptimeMillis()-startTime)/1000f)
1127                        + &amp;quot; seconds&amp;quot;);
1128
1129                // If the platform SDK has changed since the last time we booted,
1130                // we need to re-grant app permission to catch any new ones that
1131                // appear.  This is really a hack, and means that apps can in some
1132                // cases get permissions that the user didn&amp;apos;t initially explicitly
1133                // allow...  it would be nice to have some better way to handle
1134                // this situation.
1135                final boolean regrantPermissions = mSettings.mInternalSdkPlatform
1136                        != mSdkVersion;
1137                if (regrantPermissions) Slog.i(TAG, &amp;quot;Platform changed from &amp;quot;
1138                        + mSettings.mInternalSdkPlatform + &amp;quot; to &amp;quot; + mSdkVersion
1139                        + &amp;quot;; regranting permissions for internal storage&amp;quot;);
1140                mSettings.mInternalSdkPlatform = mSdkVersion;
1141                
1142                updatePermissionsLPw(null, null, true, regrantPermissions, regrantPermissions);
1143
1144                // can downgrade to reader
1145                mSettings.writeLPr();
1146
1147                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,
1148                        SystemClock.uptimeMillis());
1149
1150                // Now after opening every single application zip, make sure they
1151                // are all flushed.  Not really needed, but keeps things nice and
1152                // tidy.
1153                Runtime.getRuntime().gc();
1154
1155                mRequiredVerifierPackage = getRequiredVerifierLPr();
1156            } // synchronized (mPackages)
1157            } // synchronized (mInstallLock)
1158        }
            ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仔细分析上述代码，主要分两个部分：PackageManagerService的构造方法(启动流程)（860-1158行）、PackageHandler的逻辑(439-806行)。PackageManagerService是在系统启动阶段由systemserver启动的一个java层服务，用来管理/system/framework，/system/app，/data/app，/data/app-private等目录下的apk文件，PackageManagerService的启动流程主要包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/aXWwlfs.png&quot; alt=&quot;PackageManagerService init&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下是PackageManagerService主要的工作内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立java层的installer与c层的installd的socket联接，使得在上层的install,remove,dexopt等功能最终由installd在底层实现；&lt;/li&gt;
&lt;li&gt;建立PackageHandler消息循环，用于处理外部的apk安装请求消息，如adb install,packageinstaller安装apk时会发送消息；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解析/system/etc/permission下xml文件(framework/base/data/etc/)，包括platform.xml和系统支持的各种硬件模块的feature.主要工作：&lt;/p&gt;
&lt;p&gt; (1)建立底层user ids和group ids 同上层permissions之间的映射；可以指定一个权限与几个组ID对应。当一个APK被授予这个权限时，它也同时属于这几个组。&lt;/p&gt;
&lt;p&gt; (2)给一些底层用户分配权限，如给shell授予各种permission权限；把一个权限赋予一个UID，当进程使用这个UID运行时，就具备了这个权限。&lt;/p&gt;
&lt;p&gt; (3) library,系统增加的一些应用需要link的扩展jar库；&lt;/p&gt;
&lt;p&gt; (4) feature,系统每增加一个硬件，都要添加相应的feature.将解析结果放入mSystemPermissions,mSharedLibraries,mSettings.mPermissions,mAvailableFeatures等几个集合中供系统查询和权限配置使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;检查/data/system/packages.xml是否存在，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通过apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。&lt;/li&gt;
&lt;li&gt;检查BootClassPath，mSharedLibraries及/system/framework下的jar是否需要dexopt，需要的则通过dexopt进行优化；&lt;/li&gt;
&lt;li&gt;启动AppDirObserver线程监测/system/framework,/system/app,/data/app,/data/app-private目录的事件,主要监听add和remove事件。对于目录监听底层通过inotify机制实现，inotify 是一种文件系统的变化通知机制，如文件增加、删除等事件可以立刻让用户态得知,它为用户态监视文件系统的变化提供了强大的支持。当有add event时调用scanPackageLI(File , int , int)处理；当有remove event时调用removePackageLI()处理;&lt;/li&gt;
&lt;li&gt;对于以上几个目录下的apk逐个解析，主要是解析每个apk的AndroidMa-nifest.xml文件，处理asset/res等资源文件，建立起每个apk的配置结构信息，并将每个apk的配置信息添加到全局列表进行管理。调用installer.install()进行安装工作,检查apk里的dex文件是否需要再优化,如果需要优化则通过辅助工具dexopt进行优化处理；将解析出的componet添加到pkg的对应列表里；对apk进行签名和证书校验,进行完整性验证。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将解析的每个apk的信息保存到packages.xml和packages.list文件里，packages.list记录了如下数据：pkgName，userId，debugFlag，dataPath（包的数据路径）。&lt;/p&gt;
&lt;h3 id=&quot;开机安装过程代码解析&quot;&gt;&lt;a href=&quot;#开机安装过程代码解析&quot; class=&quot;headerlink&quot; title=&quot;开机安装过程代码解析&quot;&gt;&lt;/a&gt;开机安装过程代码解析&lt;/h3&gt;&lt;p&gt;有了上面的认识，接下来分析安装的过程就比较轻松了(均围绕PackageManagerService.java展开)。开机安装过程的代码流程如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扫描各目录(/system/framework、/system/app、/vendor/app、/data/app/、/data/app-private)下的jar包或安装包：&lt;/p&gt;
&lt;p&gt;  a.扫描安装“/system/framework”目录下的jar包(1049-1055行);&lt;/p&gt;
&lt;p&gt;  b.扫描安装系统/system/app的应用程序(1057-1063行);&lt;/p&gt;
&lt;p&gt;  c.制造商的目录下/vendor/app应用包(1065-1071行);&lt;/p&gt;
&lt;p&gt;  d.扫描“/data/app”目录，即用户安装的第三方应用(1108-1111行);&lt;/p&gt;
&lt;p&gt;  e.扫描” data\app-private”目录，即安装DRM保护的APK文件（一个受保护的歌曲或受保护的视频是使用DRM保护的文件）（1113-1117行）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扫描目录关键方法的代码清单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2732        private void scanDirLI(File dir, int flags, int scanMode, long currentTime) {
2733            String[] files = dir.list();
2734            if (files == null) {
2735                Log.d(TAG, &amp;quot;No files in app dir &amp;quot; + dir);
2736                return;
2737            }
2738
2739            if (DEBUG_PACKAGE_SCANNING) {
2740                Log.d(TAG, &amp;quot;Scanning app dir &amp;quot; + dir);
2741            }
2742
2743            int i;
2744            for (i=0; i&amp;lt;files.length; i++) {
2745                File file = new File(dir, files[i]);
2746                if (!isPackageFilename(files[i])) {
2747                    // Ignore entries which are not apk&amp;apos;s
2748                    continue;
2749                }
2750                PackageParser.Package pkg = scanPackageLI(file,
2751                        flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);
2752                // Don&amp;apos;t mess around with apps in system partition.
2753                if (pkg == null &amp;amp;&amp;amp; (flags &amp;amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;amp;&amp;amp;
2754                        mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) {
2755                    // Delete the apk
2756                    Slog.w(TAG, &amp;quot;Cleaning up failed install of &amp;quot; + file);
2757                    file.delete();
2758                }
2759            }
2760        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从上面扫描方法的代码中可以看出实质是调用了scanPackageLI(File scanFile,&lt;br&gt;int parseFlags, int scanMode, long currentTime) ，其代码在2814-2923行定义。分析其代码，发现最终实质是调用scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime)。而后者这个方法代码定义在3106-3905行之间，前面一段主要是各种校验和检查，关键部分代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3495        //invoke installer to do the actual installation
3496        int ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,
3497                pkg.applicationInfo.uid);
3498        if (ret &amp;lt; 0) {
3499            // Error from installer
3500            mLastScanError = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
3501            return null;
3502        }
3503        // Create data directories for all users
3504        mUserManager.installPackageForAllUsers(pkgName, pkg.applicationInfo.uid);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 不难看出，mInstaller.install是真正执行安装之处。而看看mInstaller的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;258  // Used for priviledge escalation.  MUST NOT BE CALLED WITH mPackages
259  // LOCK HELD.  Can be called with mInstallLock held.
260  final Installer mInstaller;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 查看com/android/server/pm/Installer.java，其代码相对比较少，分析起来比较容易，其install方法调用了execute(String cmd)方法，而execute(String cmd)又调用transaction(cmd)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;148        private synchronized String transaction(String cmd) {
149        if (!connect()) {
150            Slog.e(TAG, &amp;quot;connection failed&amp;quot;);
151            return &amp;quot;-1&amp;quot;;
152        }
153
154        if (!writeCommand(cmd)) {
155            /*
156             * If installd died and restarted in the background (unlikely but
157             * possible) we&amp;apos;ll fail on the next write (this one). Try to
158             * reconnect and write the command one more time before giving up.
159             */
160            Slog.e(TAG, &amp;quot;write command failed? reconnect!&amp;quot;);
161            if (!connect() || !writeCommand(cmd)) {
162                return &amp;quot;-1&amp;quot;;
163            }
164        }
165        if (LOCAL_DEBUG) {
166            Slog.i(TAG, &amp;quot;send: &amp;apos;&amp;quot; + cmd + &amp;quot;&amp;apos;&amp;quot;);
167        }
168        if (readReply()) {
169            String s = new String(buf, 0, buflen);
170            if (LOCAL_DEBUG) {
171                Slog.i(TAG, &amp;quot;recv: &amp;apos;&amp;quot; + s + &amp;quot;&amp;apos;&amp;quot;);
172            }
173            return s;
174        } else {
175            if (LOCAL_DEBUG) {
176                Slog.i(TAG, &amp;quot;fail&amp;quot;);
177            }
178            return &amp;quot;-1&amp;quot;;
179        }
180    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 首先是149行的connect方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;43        private boolean connect() {
44            if (mSocket != null) {
45                return true;
46            }
47            Slog.i(TAG, &amp;quot;connecting...&amp;quot;);
48            try {
49                mSocket = new LocalSocket();
50
51                LocalSocketAddress address = new LocalSocketAddress(&amp;quot;installd&amp;quot;,
52                        LocalSocketAddress.Namespace.RESERVED);
53
54                mSocket.connect(address);
55
56                mIn = mSocket.getInputStream();
57                mOut = mSocket.getOutputStream();
58            } catch (IOException ex) {
59                disconnect();
60                return false;
61            }
62            return true;
63        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 到这里已经很清楚了，实则是通过socket连接到本地方法，即指挥installd在C语言的文件中完成工作。&lt;/p&gt;
&lt;h3 id=&quot;网络下载应用安装过程代码解析&quot;&gt;&lt;a href=&quot;#网络下载应用安装过程代码解析&quot; class=&quot;headerlink&quot; title=&quot;网络下载应用安装过程代码解析&quot;&gt;&lt;/a&gt;网络下载应用安装过程代码解析&lt;/h3&gt;&lt;p&gt;当从网络上下载APK完成后，自动调用Packagemanager的安装方法installPackage。如前面所述，最终是调用PackageManagerService的installPackage方法。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4882        /* Called when a downloaded package installation has been confirmed by the user */
4883        public void installPackage(
4884                final Uri packageURI, final IPackageInstallObserver observer, final int flags) {
4885            installPackage(packageURI, observer, flags, null);
4886        }
4887
4888        /* Called when a downloaded package installation has been confirmed by the user */
4889        public void installPackage(
4890                final Uri packageURI, final IPackageInstallObserver observer, final int flags,
4891                final String installerPackageName) {
4892            installPackageWithVerification(packageURI, observer, flags, installerPackageName, null,
4893                    null);
4894        }
4895
4896        @Override
4897        public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer,
4898                int flags, String installerPackageName, Uri verificationURI,
4899                ManifestDigest manifestDigest) {
4900            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
4901
4902            final int uid = Binder.getCallingUid();
4903
4904            final int filteredFlags;
4905
4906            if (uid == Process.SHELL_UID || uid == 0) {
4907                if (DEBUG_INSTALL) {
4908                    Slog.v(TAG, &amp;quot;Install from ADB&amp;quot;);
4909                }
4910                filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;
4911            } else {
4912                filteredFlags = flags &amp;amp; ~PackageManager.INSTALL_FROM_ADB;
4913            }
4914
4915            final Message msg = mHandler.obtainMessage(INIT_COPY);
4916            msg.obj = new InstallParams(packageURI, observer, filteredFlags, installerPackageName,
4917                    verificationURI, manifestDigest);
4918            mHandler.sendMessage(msg);
4919        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以发现，调用之后进入到4945-4918行，通过PackageHandler的实例mhandler.sendMessage（msg）把信息发给继承Handler的类HandleMessage()方法。在前面章节已经介绍了PackageManagerService中PackageHandler的定义。HandleMessage()把信息发给doHandleMessage()方法,方法中用switch语句进行判定传来Message进行分支处理。这里传入的消息的msg.what是INIT_COPY，进入到INIT_COPY分支，可以看到，一旦成功绑定了com.android.defcontainer.DefaultContainerService服务，则进入506行–mHandler.sendEmptyMessage(MCS_BOUND);此时进入doHandleMessage方法的switch语句的MCS_BOUND分支，跟踪进去，关键代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;528     if (params.startCopy()) {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;params是PackageManagerService中内部抽象类HandlerParams的子类InstallParams(参见上面4916行)的实例，HandlerParams代码清单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5202    private abstract class HandlerParams {
5203        private static final int MAX_RETRIES = 4;
5204
5205        /**
5206         * Number of times startCopy() has been attempted and had a non-fatal
5207         * error.
5208         */
5209        private int mRetries = 0;
5210
5211        final boolean startCopy() {
5212            boolean res;
5213            try {
5214                if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;startCopy&amp;quot;);
5215
5216                if (++mRetries &amp;gt; MAX_RETRIES) {
5217                    Slog.w(TAG, &amp;quot;Failed to invoke remote methods on default container service. Giving up&amp;quot;);
5218                    mHandler.sendEmptyMessage(MCS_GIVE_UP);
5219                    handleServiceError();
5220                    return false;
5221                } else {
5222                    handleStartCopy();
5223                    res = true;
5224                }
5225            } catch (RemoteException e) {
5226                if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;Posting install MCS_RECONNECT&amp;quot;);
5227                mHandler.sendEmptyMessage(MCS_RECONNECT);
5228                res = false;
5229            }
5230            handleReturnCode();
5231            return res;
5232        }
5233
5234        final void serviceError() {
5235            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;serviceError&amp;quot;);
5236            handleServiceError();
5237            handleReturnCode();
5238        }
5239
5240        abstract void handleStartCopy() throws RemoteException;
5241        abstract void handleServiceError();
5242        abstract void handleReturnCode();
5243    }
5244
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;startCopy()方法中关键代码是先调用handleStartCopy()方法，再调用handleReturnCode()方法(由子类实现，这里即InstallParams的handleStartCopy()方法和handleReturnCode()方法)，handleStartCopy()代码较多，但是前面基本是校验相关逻辑，关键部分在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5557    } else {
5558        /*
5559         * No package verification is enabled, so immediately start
5560         * the remote call to initiate copy using temporary file.
5561         */
5562        ret = args.copyApk(mContainerService, true);
5563    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;args是抽象类InstallArgs的子类实现类SdInstallArgs(安装在SD卡时)或FileInstallArgs(非安装在)的实例对象，copyApk是负责将下载的APK文件copy到/data/app目录下。而handleReturnCode方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5569    @Override
5570    void handleReturnCode() {
5571        // If mArgs is null, then MCS couldn&amp;apos;t be reached. When it
5572        // reconnects, it will try again to install. At that point, this
5573        // will succeed.
5574        if (mArgs != null) {
5575            processPendingInstall(mArgs, mRet);
5576        }
5577    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时可以清楚的看见processPendingInstall()被调用。其代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5129    private void processPendingInstall(final InstallArgs args, final int currentStatus) {
5130        // Queue up an async operation since the package installation may take a little while.
5131        mHandler.post(new Runnable() {
5132            public void run() {
5133                mHandler.removeCallbacks(this);
5134                 // Result object to be returned
5135                PackageInstalledInfo res = new PackageInstalledInfo();
5136                res.returnCode = currentStatus;
5137                res.uid = -1;
5138                res.pkg = null;
5139                res.removedInfo = new PackageRemovedInfo();
5140                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
5141                    args.doPreInstall(res.returnCode);
5142                    synchronized (mInstallLock) {
5143                        installPackageLI(args, true, res);
5144                    }
5145                    args.doPostInstall(res.returnCode);
5146                }
5147
5148                // A restore should be performed at this point if (a) the install
5149                // succeeded, (b) the operation is not an update, and (c) the new
5150                // package has a backupAgent defined.
5151                final boolean update = res.removedInfo.removedPackage != null;
5152                boolean doRestore = (!update
5153                        &amp;amp;&amp;amp; res.pkg != null
5154                        &amp;amp;&amp;amp; res.pkg.applicationInfo.backupAgentName != null);
5155
5156                // Set up the post-install work request bookkeeping.  This will be used
5157                // and cleaned up by the post-install event handling regardless of whether
5158                // there&amp;apos;s a restore pass performed.  Token values are &amp;gt;= 1.
5159                int token;
5160                if (mNextInstallToken &amp;lt; 0) mNextInstallToken = 1;
5161                token = mNextInstallToken++;
5162
5163                PostInstallData data = new PostInstallData(args, res);
5164                mRunningInstalls.put(token, data);
5165                if (DEBUG_INSTALL) Log.v(TAG, &amp;quot;+ starting restore round-trip &amp;quot; + token);
5166
5167                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;amp;&amp;amp; doRestore) {
5168                    // Pass responsibility to the Backup Manager.  It will perform a
5169                    // restore if appropriate, then pass responsibility back to the
5170                    // Package Manager to run the post-install observer callbacks
5171                    // and broadcasts.
5172                    IBackupManager bm = IBackupManager.Stub.asInterface(
5173                            ServiceManager.getService(Context.BACKUP_SERVICE));
5174                    if (bm != null) {
5175                        if (DEBUG_INSTALL) Log.v(TAG, &amp;quot;token &amp;quot; + token
5176                                + &amp;quot; to BM for possible restore&amp;quot;);
5177                        try {
5178                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
5179                        } catch (RemoteException e) {
5180                            // can&amp;apos;t happen; the backup manager is local
5181                        } catch (Exception e) {
5182                            Slog.e(TAG, &amp;quot;Exception trying to enqueue restore&amp;quot;, e);
5183                            doRestore = false;
5184                        }
5185                    } else {
5186                        Slog.e(TAG, &amp;quot;Backup Manager not found!&amp;quot;);
5187                        doRestore = false;
5188                    }
5189                }
5190
5191                if (!doRestore) {
5192                    // No restore possible, or the Backup Manager was mysteriously not
5193                    // available -- just fire the post-install work request directly.
5194                    if (DEBUG_INSTALL) Log.v(TAG, &amp;quot;No restore - queue post-install for &amp;quot; + token);
5195                    Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
5196                    mHandler.sendMessage(msg);
5197                }
5198            }
5199        });
5200    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键部分代码为5140-5146行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5140                if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
5141                    args.doPreInstall(res.returnCode);
5142                    synchronized (mInstallLock) {
5143                        installPackageLI(args, true, res);
5144                    }
5145                    args.doPostInstall(res.returnCode);
5146                }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里installPackageLI(args, true, res)的代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5573    private void installPackageLI(InstallArgs args,
5574            boolean newInstall, PackageInstalledInfo res) {
5575        int pFlags = args.flags;
5576        String installerPackageName = args.installerPackageName;
5577        File tmpPackageFile = new File(args.getCodePath());
5578        boolean forwardLocked = ((pFlags &amp;amp; PackageManager.INSTALL_FORWARD_LOCK) != 0);
5579        boolean onSd = ((pFlags &amp;amp; PackageManager.INSTALL_EXTERNAL) != 0);
5580        boolean replace = false;
5581        int scanMode = (onSd ? 0 : SCAN_MONITOR) | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE
5582                | (newInstall ? SCAN_NEW_INSTALL : 0);
5583        // Result object to be returned
5584        res.returnCode = PackageManager.INSTALL_SUCCEEDED;
5585
5586        // Retrieve PackageSettings and parse package
5587        int parseFlags = PackageParser.PARSE_CHATTY |
5588        (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) |
5589        (onSd ? PackageParser.PARSE_ON_SDCARD : 0);
5590        parseFlags |= mDefParseFlags;
5591        PackageParser pp = new PackageParser(tmpPackageFile.getPath());
5592        pp.setSeparateProcesses(mSeparateProcesses);
5593        final PackageParser.Package pkg = pp.parsePackage(tmpPackageFile,
5594                null, mMetrics, parseFlags);
5595        if (pkg == null) {
5596            res.returnCode = pp.getParseError();
5597            return;
5598        }
5599        String pkgName = res.name = pkg.packageName;
5600        if ((pkg.applicationInfo.flags&amp;amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) {
5601            if ((pFlags&amp;amp;PackageManager.INSTALL_ALLOW_TEST) == 0) {
5602                res.returnCode = PackageManager.INSTALL_FAILED_TEST_ONLY;
5603                return;
5604            }
5605        }
5606        if (GET_CERTIFICATES &amp;amp;&amp;amp; !pp.collectCertificates(pkg, parseFlags)) {
5607            res.returnCode = pp.getParseError();
5608            return;
5609        }
5610
5611        /* If the installer passed in a manifest digest, compare it now. */
5612        if (args.manifestDigest != null) {
5613            if (DEBUG_INSTALL) {
5614                final String parsedManifest = pkg.manifestDigest == null ? &amp;quot;null&amp;quot;
5615                        : pkg.manifestDigest.toString();
5616                Slog.d(TAG, &amp;quot;Comparing manifests: &amp;quot; + args.manifestDigest.toString() + &amp;quot; vs. &amp;quot;
5617                        + parsedManifest);
5618            }
5619
5620            if (!args.manifestDigest.equals(pkg.manifestDigest)) {
5621                res.returnCode = PackageManager.INSTALL_FAILED_PACKAGE_CHANGED;
5622                return;
5623            }
5624        } else if (DEBUG_INSTALL) {
5625            final String parsedManifest = pkg.manifestDigest == null
5626                    ? &amp;quot;null&amp;quot; : pkg.manifestDigest.toString();
5627            Slog.d(TAG, &amp;quot;manifestDigest was not present, but parser got: &amp;quot; + parsedManifest);
5628        }
5629
5630        // Get rid of all references to package scan path via parser.
5631        pp = null;
5632        String oldCodePath = null;
5633        boolean systemApp = false;
5634        synchronized (mPackages) {
5635            // Check if installing already existing package
5636            if ((pFlags&amp;amp;PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
5637                String oldName = mSettings.mRenamedPackages.get(pkgName);
5638                if (pkg.mOriginalPackages != null
5639                        &amp;amp;&amp;amp; pkg.mOriginalPackages.contains(oldName)
5640                        &amp;amp;&amp;amp; mPackages.containsKey(oldName)) {
5641                    // This package is derived from an original package,
5642                    // and this device has been updating from that original
5643                    // name.  We must continue using the original name, so
5644                    // rename the new package here.
5645                    pkg.setPackageName(oldName);
5646                    pkgName = pkg.packageName;
5647                    replace = true;
5648                } else if (mPackages.containsKey(pkgName)) {
5649                    // This package, under its official name, already exists
5650                    // on the device; we should replace it.
5651                    replace = true;
5652                }
5653            }
5654            PackageSetting ps = mSettings.mPackages.get(pkgName);
5655            if (ps != null) {
5656                oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
5657                if (ps.pkg != null &amp;amp;&amp;amp; ps.pkg.applicationInfo != null) {
5658                    systemApp = (ps.pkg.applicationInfo.flags &amp;amp;
5659                            ApplicationInfo.FLAG_SYSTEM) != 0;
5660                }
5661            }
5662        }
5663
5664        if (systemApp &amp;amp;&amp;amp; onSd) {
5665            // Disable updates to system apps on sdcard
5666            Slog.w(TAG, &amp;quot;Cannot install updates to system apps on sdcard&amp;quot;);
5667            res.returnCode = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
5668            return;
5669        }
5670
5671        if (!args.doRename(res.returnCode, pkgName, oldCodePath)) {
5672            res.returnCode = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
5673            return;
5674        }
5675        // Set application objects path explicitly after the rename
5676        setApplicationInfoPaths(pkg, args.getCodePath(), args.getResourcePath());
5677        pkg.applicationInfo.nativeLibraryDir = args.getNativeLibraryPath();
5678        if (replace) {
5679            replacePackageLI(pkg, parseFlags, scanMode,
5680                    installerPackageName, res);
5681        } else {
5682            installNewPackageLI(pkg, parseFlags, scanMode,
5683                    installerPackageName,res);
5684        }
5685    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键部分在最后的5678-5684行，如果是重复安装则调用replacePackageLI，负责调用installNewPackageLI(pkg, parseFlags, scanMode,installerPackageName,res);这里以installNewPackageLI为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6259    /*
6260     * Install a non-existing package.
6261     */
6262    private void installNewPackageLI(PackageParser.Package pkg,
6263            int parseFlags,
6264            int scanMode,
6265            String installerPackageName, PackageInstalledInfo res) {
6266        // Remember this for later, in case we need to rollback this install
6267        String pkgName = pkg.packageName;
6268
6269        boolean dataDirExists = getDataPathForPackage(pkg.packageName, 0).exists();
6270        res.name = pkgName;
6271        synchronized(mPackages) {
6272            if (mSettings.mRenamedPackages.containsKey(pkgName)) {
6273                // A package with the same name is already installed, though
6274                // it has been renamed to an older name.  The package we
6275                // are trying to install should be installed as an update to
6276                // the existing one, but that has not been requested, so bail.
6277                Slog.w(TAG, &amp;quot;Attempt to re-install &amp;quot; + pkgName
6278                        + &amp;quot; without first uninstalling package running as &amp;quot;
6279                        + mSettings.mRenamedPackages.get(pkgName));
6280                res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
6281                return;
6282            }
6283            if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
6284                // Don&amp;apos;t allow installation over an existing package with the same name.
6285                Slog.w(TAG, &amp;quot;Attempt to re-install &amp;quot; + pkgName
6286                        + &amp;quot; without first uninstalling.&amp;quot;);
6287                res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
6288                return;
6289            }
6290        }
6291        mLastScanError = PackageManager.INSTALL_SUCCEEDED;
6292        PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode,
6293                System.currentTimeMillis());
6294        if (newPackage == null) {
6295            Slog.w(TAG, &amp;quot;Package couldn&amp;apos;t be installed in &amp;quot; + pkg.mPath);
6296            if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
6297                res.returnCode = PackageManager.INSTALL_FAILED_INVALID_APK;
6298            }
6299        } else {
6300            updateSettingsLI(newPackage,
6301                    installerPackageName,
6302                    res);
6303            // delete the partially installed application. the data directory will have to be
6304            // restored if it was already existing
6305            if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
6306                // remove package from internal structures.  Note that we want deletePackageX to
6307                // delete the package data and cache directories that it created in
6308                // scanPackageLocked, unless those directories existed before we even tried to
6309                // install.
6310                deletePackageLI(
6311                        pkgName, false,
6312                        dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,
6313                                res.removedInfo, true);
6314            }
6315        }
6316    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键代码部分为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6292        PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode,
6293                System.currentTimeMillis());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最终回到了和开机安装一样的地方，与开机方式安装调用统一方法scanPackageLI。后续步骤则完全一致了。&lt;/p&gt;
&lt;h3 id=&quot;从ADB工具安装过程代码解析&quot;&gt;&lt;a href=&quot;#从ADB工具安装过程代码解析&quot; class=&quot;headerlink&quot; title=&quot;从ADB工具安装过程代码解析&quot;&gt;&lt;/a&gt;从ADB工具安装过程代码解析&lt;/h3&gt;&lt;p&gt;通过adb命令方式，真实的入口其实是com/android/commands/pm/Pm.java，其中showUsage方法为使用方法说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1111    private static void showUsage() {
1112        System.err.println(&amp;quot;usage: pm list packages [-f] [-d] [-e] [-s] [-e] [-u] [FILTER]&amp;quot;);
1113        System.err.println(&amp;quot;       pm list permission-groups&amp;quot;);
1114        System.err.println(&amp;quot;       pm list permissions [-g] [-f] [-d] [-u] [GROUP]&amp;quot;);
1115        System.err.println(&amp;quot;       pm list instrumentation [-f] [TARGET-PACKAGE]&amp;quot;);
1116        System.err.println(&amp;quot;       pm list features&amp;quot;);
1117        System.err.println(&amp;quot;       pm list libraries&amp;quot;);
1118        System.err.println(&amp;quot;       pm path PACKAGE&amp;quot;);
1119        System.err.println(&amp;quot;       pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] [-s] [-f] PATH&amp;quot;);
1120        System.err.println(&amp;quot;       pm uninstall [-k] PACKAGE&amp;quot;);
1121        System.err.println(&amp;quot;       pm clear PACKAGE&amp;quot;);
1122        System.err.println(&amp;quot;       pm enable PACKAGE_OR_COMPONENT&amp;quot;);
1123        System.err.println(&amp;quot;       pm disable PACKAGE_OR_COMPONENT&amp;quot;);
1124        System.err.println(&amp;quot;       pm disable-user PACKAGE_OR_COMPONENT&amp;quot;);
1125        System.err.println(&amp;quot;       pm set-install-location [0/auto] [1/internal] [2/external]&amp;quot;);
1126        System.err.println(&amp;quot;       pm get-install-location&amp;quot;);
1127        System.err.println(&amp;quot;       pm createUser USER_NAME&amp;quot;);
1128        System.err.println(&amp;quot;       pm removeUser USER_ID&amp;quot;);
1129        System.err.println(&amp;quot;&amp;quot;);
1130        System.err.println(&amp;quot;pm list packages: prints all packages, optionally only&amp;quot;);
1131        System.err.println(&amp;quot;  those whose package name contains the text in FILTER.  Options:&amp;quot;);
1132        System.err.println(&amp;quot;    -f: see their associated file.&amp;quot;);
1133        System.err.println(&amp;quot;    -d: filter to only show disbled packages.&amp;quot;);
1134        System.err.println(&amp;quot;    -e: filter to only show enabled packages.&amp;quot;);
1135        System.err.println(&amp;quot;    -s: filter to only show system packages.&amp;quot;);
1136        System.err.println(&amp;quot;    -3: filter to only show third party packages.&amp;quot;);
1137        System.err.println(&amp;quot;    -u: also include uninstalled packages.&amp;quot;);
            ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而安装时调用的方法即runInstall(),方法内的关键代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;798        PackageInstallObserver obs = new PackageInstallObserver();
799        try {
800            mPm.installPackageWithVerification(apkURI, obs, installFlags, installerPackageName,
801                    verificationURI, null);
802
803            synchronized (obs) {
804                while (!obs.finished) {
805                    try {
806                        obs.wait();
807                    } catch (InterruptedException e) {
808                    }
809                }
810                if (obs.result == PackageManager.INSTALL_SUCCEEDED) {
811                    System.out.println(&amp;quot;Success&amp;quot;);
812                } else {
813                    System.err.println(&amp;quot;Failure [&amp;quot;
814                            + installFailureToString(obs.result)
815                            + &amp;quot;]&amp;quot;);
816                }
817            }
818        } catch (RemoteException e) {
819            System.err.println(e.toString());
820            System.err.println(PM_NOT_RUNNING_ERR);
821        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，实则调用mPm变量的installPackageWithVerification方法。mPm变量为IPackageManager接口的实现类的对象，通过78行，不难发现，其实又是绑定远程的PackageManagerService来完成具体的操作，此时就回到与网络下载的地方了，后续步骤可参加网络下载部分的分析。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;53        public final class Pm {
54            IPackageManager mPm;
55
56            private WeakHashMap&amp;lt;String, Resources&amp;gt; mResourceCache
57                    = new WeakHashMap&amp;lt;String, Resources&amp;gt;();
58
59            private String[] mArgs;
60            private int mNextArg;
61            private String mCurArgData;
62
63            private static final String PM_NOT_RUNNING_ERR =
64                &amp;quot;Error: Could not access the Package Manager.  Is the system running?&amp;quot;;
65            private static final int ROOT_UID = 0;
66
67            public static void main(String[] args) {
68                new Pm().run(args);
69            }
70
71            public void run(String[] args) {
72                boolean validCommand = false;
73                if (args.length &amp;lt; 1) {
74                    showUsage();
75                    return;
76                }
77
78                mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(&amp;quot;package&amp;quot;));
79                if (mPm == null) {
80                    System.err.println(PM_NOT_RUNNING_ERR);
81                    return;
82                }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通过第三方应用从SD卡安装的过程代码分析&quot;&gt;&lt;a href=&quot;#通过第三方应用从SD卡安装的过程代码分析&quot; class=&quot;headerlink&quot; title=&quot;通过第三方应用从SD卡安装的过程代码分析&quot;&gt;&lt;/a&gt;通过第三方应用从SD卡安装的过程代码分析&lt;/h3&gt;&lt;p&gt;这其实相当于在PackagManager之上提供一个更便捷的方式给用户安装APK，系统上层的源码中有一个类(Activity)com/android/packageinstaller/PackageInstallerActivity.java，通过它可以便捷地使UI方式安装APK。PackageInstallerActivity的oncreate方法如下(本文的采用的版本可能与读者的版本不同，所以行号和代码细节会有差异，请注意)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;235        @Override
236        protected void onCreate(Bundle icicle) {
237            super.onCreate(icicle);
238            //get intent information
239            final Intent intent = getIntent();
240            mPackageURI = intent.getData();
241            mPm = getPackageManager();
242            mPkgInfo = PackageUtil.getPackageInfo(mPackageURI);
243            
244            // Check for parse errors
245            if(mPkgInfo == null) {
246                Log.w(TAG, &amp;quot;Parse error when parsing manifest. Discontinuing installation&amp;quot;);
247                showDialogInner(DLG_PACKAGE_ERROR);
248                return;
249            }
250            
251            //set view
252            requestWindowFeature(Window.FEATURE_NO_TITLE);
253            setContentView(R.layout.install_start);
254            mInstallConfirm = findViewById(R.id.install_confirm_panel);
255            mInstallConfirm.setVisibility(View.INVISIBLE);
256            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this,
257                    mPkgInfo.applicationInfo, mPackageURI);
258            PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);
259           //check setting
260            if(!isInstallingUnknownAppsAllowed()) {
261                //ask user to enable setting first
262                showDialogInner(DLG_UNKNOWN_APPS);
263                return;
264            }
265            initiateInstall();
266        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如265行所示，进入initiateInstall方法，跟踪可以发现，又进入startInstallConfirm()方法，这主要是弹出对话框，让用户确认是否安装，如果确认，那么即进入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;273        public void onClick(View v) {
274        if(v == mOk) {
275            // Start subactivity to actually install the application
276            Intent newIntent = new Intent();
277            newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
278                    mPkgInfo.applicationInfo);
279            newIntent.setData(mPackageURI);
280            newIntent.setClass(this, InstallAppProgress.class);
281            String installerPackageName = getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME);
282            if (installerPackageName != null) {
283                newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName);
284            }
285            if(localLOGV) Log.i(TAG, &amp;quot;downloaded app uri=&amp;quot;+mPackageURI);
286            startActivity(newIntent);
287            finish();
288        } else if(v == mCancel) {
289            // Cancel and finish
290            finish();
291        }
292    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认后，打开新的activity：InstallAppProgress，com/android/packageinstaller/InstallAppProgress．java的关键代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;126        @Override
127        public void onCreate(Bundle icicle) {
128            super.onCreate(icicle);
129            Intent intent = getIntent();
130            mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);
131            mPackageURI = intent.getData();
132            initView();
133        }
        ...
176        public void initView() {
177            requestWindowFeature(Window.FEATURE_NO_TITLE);
178            setContentView(R.layout.op_progress);
179            int installFlags = 0;
180            PackageManager pm = getPackageManager();
181            try {
182                PackageInfo pi = pm.getPackageInfo(mAppInfo.packageName, 
183                        PackageManager.GET_UNINSTALLED_PACKAGES);
184                if(pi != null) {
185                    installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;
186                }
187            } catch (NameNotFoundException e) {
188            }
189            if((installFlags &amp;amp; PackageManager.INSTALL_REPLACE_EXISTING )!= 0) {
190                Log.w(TAG, &amp;quot;Replacing package:&amp;quot; + mAppInfo.packageName);
191            }
192            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, mAppInfo,
193                    mPackageURI);
194            mLabel = as.label;
195            PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);
196            mStatusTextView = (TextView)findViewById(R.id.center_text);
197            mStatusTextView.setText(R.string.installing);
198            mProgressBar = (ProgressBar) findViewById(R.id.progress_bar);
199            mProgressBar.setIndeterminate(true);
200            // Hide button till progress is being displayed
201            mOkPanel = (View)findViewById(R.id.buttons_panel);
202            mDoneButton = (Button)findViewById(R.id.done_button);
203            mLaunchButton = (Button)findViewById(R.id.launch_button);
204            mOkPanel.setVisibility(View.INVISIBLE);
205
206            String installerPackageName = getIntent().getStringExtra(
207                    Intent.EXTRA_INSTALLER_PACKAGE_NAME);
208            PackageInstallObserver observer = new PackageInstallObserver();
209            pm.installPackage(mPackageURI, observer, installFlags, installerPackageName);
210        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上所示，209行则是执行安装的地方，不难发现，这里是pm对象在180行获取，到这里，又回到和网络下载一样的地方了，后续步骤可以参见网络下载安装部分解析。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装和卸载都是通过PackageManager，实质上是实现了PackageManager的远程服务PackageManagerService来完成具体的操作，所有细节和逻辑均可以在PackageManagerService中跟踪查看；&lt;/li&gt;
&lt;li&gt;所有安装方式殊途同归，最终就回到PackageManagerService中，然后调用底层本地代码的installd来完成。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;众所周知，Android应用最终是打包成.apk格式（其实就是一个压缩包），然后安装至手机并运行的。APK即Android Package的
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="APK安装" scheme="http://cstsinghua.github.io/tags/APK%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Android studio动态调试</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Android%20studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Android studio动态调试指南/</id>
    <published>2016-06-13T07:25:56.000Z</published>
    <updated>2017-10-17T07:42:06.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Android-studio动态调试&quot;&gt;&lt;a href=&quot;#Android-studio动态调试&quot; class=&quot;headerlink&quot; title=&quot;Android studio动态调试&quot;&gt;&lt;/a&gt;Android studio动态调试&lt;/h1&gt;&lt;p&gt;Android studio动态调试实际上是基于Smali Debugging(&lt;strong&gt;早期Android开发采用Eclipse ADT，其动态调试请参见&lt;a href=&quot;http://cstsinghua.github.io/2016/06/13/Eclipse%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/&quot; title=&quot;Eclipse动态调试&quot;&gt;Eclipse动态调试&lt;/a&gt;，可以作为本文的步骤参考&lt;/strong&gt;)，而Smali Debugging基于开源的Android反编译工具apktool。&lt;strong&gt;请注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SmaliDebugging has been marked as deprecated in 2.0.3, and will be removed in 2.1. Alternative tool(s) will be linked on 2.1 release.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;因此，apktool 2.0.3及其之前版本，可以直接使用apktool工具来实现动态调试；而采用apktool 2.1.0及其之后版本，需要采用独立出来的工具来调试，&lt;a href=&quot;#anchor&quot;&gt;请参见章节2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apktool makes possible to debug smali code step by step, watch variables, set breakpoints, etc.&lt;/p&gt;
&lt;p&gt;本文出自apktool官方网站说明&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/documentation/#smali-debugging&quot; title=&quot;smali debugging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://ibotpeaches.github.io/Apktool/documentation/#smali-debugging&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;General-information-概述&quot;&gt;&lt;a href=&quot;#General-information-概述&quot; class=&quot;headerlink&quot; title=&quot;General information(概述)&quot;&gt;&lt;/a&gt;General information(概述)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Generally we need several things to run Java debugging session: &lt;ol&gt;
&lt;li&gt;debugger server (usually Java VM)&lt;/li&gt;
&lt;li&gt;debugger client (usually IDE like IntelliJ, Eclipse or Netbeans)&lt;/li&gt;
&lt;li&gt;client must have sources of debugged application&lt;/li&gt;
&lt;li&gt;server must have binaries compiled with debugging symbols referencing these sources&lt;/li&gt;
&lt;li&gt;sources must be java files with at least package and class definitions, to properly connect them with debugging symbols&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;In our particular situation we have: &lt;ol&gt;
&lt;li&gt;server: Monitor (Previously DDMS), part of Android SDK, standard for debugging Android applications - explained here&lt;/li&gt;
&lt;li&gt;client: any JPDA client - most of decent IDEs have support for this protocol.&lt;/li&gt;
&lt;li&gt;sources: smali code modified by apktool to satisfy above requirements (“.java” extension, class declaration, etc.). Apktool modifies them when decoding apk in debug mode.&lt;/li&gt;
&lt;li&gt;binaries: when building apk in debug mode, apktool removes original symbols and adds new, which are referencing smali code (line numbers, registers/variables, etc.)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Info:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To successfully run debug sessions, the apk must be both decoded and built in debug mode. Decoding with debug decodes the application differently to allow the debug rebuild option to inject lines allowing the debugger to identify variables and types.-d / –debug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;General-instructions-一般性步骤&quot;&gt;&lt;a href=&quot;#General-instructions-一般性步骤&quot; class=&quot;headerlink&quot; title=&quot;General instructions(一般性步骤)&quot;&gt;&lt;/a&gt;General instructions(一般性步骤)&lt;/h2&gt;&lt;p&gt;Above information is enough to debug smali code using apktool, but if you aren’t familiar with DDMS and Java debugging, then you probably still don’t know how to do it. Below are simple instructions for doing it using IntelliJ or Netbeans. &lt;/p&gt;
&lt;p&gt;首先，请先下载apktool工具并熟悉其命令的使用，可参见其官网说明&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/install/&quot; title=&quot;apktool install&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://ibotpeaches.github.io/Apktool/install/&lt;/a&gt;。根据你的操作系统选择对应的版本，其实最终都是jar包，可以直接下载其&lt;a href=&quot;https://bitbucket.org/iBotPeaches/apktool/downloads/&quot; title=&quot;apktool jar download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jar版本&lt;/a&gt;，然后使用的时候采用命令&lt;code&gt;java -jar apktool_x.x.x.jar [cmd ...]&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Decode apk in debug mode(利用apktool反编译目标apk，命令格式如下，其中out表示输出目录，可以根据需要替换成你自己指定的输出目录): &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;code&gt;apktool d -d -o out app.apk&lt;/code&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;code&gt;java -jar apktool_x.x.x.jar d -d -o out app.apk&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改反编译得到的文件，比如替换图片，增删代码等等操作(根据实际需要进行)，另外就是&lt;strong&gt;设置调试标记(如没有特殊要求，除了设置调试标记外，可以不修改其他任何文件)&lt;/strong&gt;，即在输出的out文件夹中，用文本编辑工具打开AndroidManifest.xml，在application节点中设置属性android:debuggable=”true”。比如：&lt;br&gt;  &lt;code&gt;&amp;lt;application android:debuggable=&amp;quot;true&amp;quot; android:icon=&amp;quot;@drawable/icon&amp;quot; android:label=&amp;quot;@string/app_name&amp;quot; android:name=&amp;quot;com.boyaa.godsdk.core.MutiUnipayApplication&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Build new apk in debug mode(用apktool重新编译打包为debug.apk,注意：回编生成的debug.apk是没有进行签名的，也就无法直接安装在手机上，因此需要进行步骤4): &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;apktool b -d out -o debug.apk&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java -jar apktool_x.x.x.jar b -d out -o debug.apk&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sign, install and run new apk(对debug.apk签名(建议采用&lt;a href=&quot;/Android逆向助手_v2.2.zip&quot;&gt;安卓逆向助手&lt;/a&gt; )，生成debug_sign.apk，然后安装debug_sign.apk至手机并&lt;strong&gt;启动运行&lt;/strong&gt;该apk).&lt;br&gt; 当然也可以直接采用JDK里面的签名工具通过命令行手动进行签名，比如：&lt;br&gt; &lt;code&gt;&amp;quot;jarsigner&amp;quot; -keystore &amp;quot;C:\Users\CoulsonChen\Desktop\kop.keystore&amp;quot; -storepass &amp;quot;kop1122334&amp;quot; -keypass &amp;quot;kop1122334&amp;quot; &amp;quot;D:\t\125.apk&amp;quot; &amp;quot;kop&amp;quot; -sigalg SHA1withRSA -digestalg SHA1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follow sub-instructions below depending on IDE(参见下面Android studio的后续子步骤，同时可参考&lt;a href=&quot;http://cstsinghua.github.io/2016/06/13/Eclipse%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/&quot;&gt;Eclipse 动态调试指南的7-10步&lt;/a&gt;).&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;IntelliJ-Android-Studio-instructions-针对Android-studio的后续操作步骤&quot;&gt;&lt;a href=&quot;#IntelliJ-Android-Studio-instructions-针对Android-studio的后续操作步骤&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ (Android Studio) instructions(针对Android studio的后续操作步骤)&quot;&gt;&lt;/a&gt;IntelliJ (Android Studio) instructions(针对Android studio的后续操作步骤)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;注意：在完成上述的一般性步骤之后，再进行这里的子步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In IntelliJ add new Java Module Project selecting the “out” directory as project location and the “smali” subdirectory as content root dir(在Android studio中，本文Android studio的版本是2.3.3，选择菜单”File”–&amp;gt;”New”–&amp;gt;”import project”，选择apktool反编译时的out目录作为项目位置引入，引入之后，将out下的smali目录设置为内容根目录).具体请参见下面截图示意图：&lt;/p&gt;
&lt;p&gt; a.导入项目，&lt;strong&gt;注意：导入时选择默认设置即可，不断点击next直到导入结束。如果在中途出现错误，注意下Android SDK的选择即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/juKDS7S.png&quot; alt=&quot;import project&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/bz49aqX.png&quot; alt=&quot;select project&quot;&gt;&lt;/p&gt;
&lt;p&gt; b.成功导入之后，以”project”视图展示项目，选中smali目录，鼠标右键点击，在弹出菜单中按照下图勾选(即将smali目录设置为源码根目录)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/SPsN1WM.png&quot; alt=&quot;mark src root&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run Monitor (Android SDK /tools folder), find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”.先启动调试的apk，然后打开Android Device Monitor,如下图所示：&lt;/p&gt;
&lt;p&gt; a.打开Android Device Monitor(从Android SDK安装目录下的tools子目录下的monitor.bat(针对windows系统)打开也可)&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/3Jr4Vrn.png&quot; alt=&quot;DDMS&quot;&gt;&lt;/p&gt;
&lt;p&gt; b.查看目标程序的&lt;strong&gt;调试端口(每次启动目标程序，端口是系统分配，可能会变化，下面的步骤4中的debugger配置的端口必须与这个值一致)&lt;/strong&gt;，如下图所示：&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/b1OfikC.png&quot; alt=&quot;Debug port&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In IntelliJ: Debug -&amp;gt; Edit Configurations. Since this is a new project, you will have to create a Debugger.即在Debug菜单中选择&lt;code&gt;Edit Configurations&lt;/code&gt;，添加一个调试器。如下图所示：&lt;/p&gt;
&lt;p&gt; a.添加调试配置&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/y9PLNZJ.png&quot; alt=&quot;edit config&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a Remote Debugger, with the settings on “Attach” and setting the Port to 8700 (Or whatever Monitor said). The rest of fields should be ok, click “Ok”.&lt;strong&gt;创建Debugger，注意配置的端口必须与上面步骤2中查询到的调试端口一致。&lt;/strong&gt;&lt;br&gt; a.创建debugger&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/iHKGQu5.png&quot; alt=&quot;add debugger&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start the debugging session. You will see some info in a log and debugging buttons will show up in top panel.从Android studio的工具栏中启动调试会话，如下图：&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/ANH5sVi.png&quot; alt=&quot;start debug&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”.这一步主要设置断点，以”.”/“:”/“#”开头的行是无法设置断点的，因为这里是基于smali调试，如不熟悉其语法，可先在google上搜索以了解smali的语法和相关的原理。选择要观察的程序点，在对应的代码行设置断点，示例如下：&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/576Irpi.png&quot; alt=&quot;set breakpoint&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc.在手机端，操作目标程序，如果恰好你执行的操作的逻辑段设置了断点，那么线程将会被挂起，从而可以进入调试，查看变量的值，等等。&lt;br&gt; &lt;img src=&quot;https://i.imgur.com/0QHwwGj.png&quot; alt=&quot;view variables&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Netbeans-instructions-针对Netbeans的后续操作步骤&quot;&gt;&lt;a href=&quot;#Netbeans-instructions-针对Netbeans的后续操作步骤&quot; class=&quot;headerlink&quot; title=&quot;Netbeans instructions(针对Netbeans的后续操作步骤)&quot;&gt;&lt;/a&gt;Netbeans instructions(针对Netbeans的后续操作步骤)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In Netbeans add new Java Project with Existing Sources, select “out” directory as project root and “smali” subdirectory as sources dir.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run DDMS, find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In Netbeans: Debug -&amp;gt; Attach Debugger -&amp;gt; select JPDA and set Port to 8700 (or whatever you saw in previous step). Rest of fields should be ok, click “Ok”.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Debugging session should start: you will see some info in a log and debugging buttons will show up in top panel.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Limitations-Issues-限制和已知问题&quot;&gt;&lt;a href=&quot;#Limitations-Issues-限制和已知问题&quot; class=&quot;headerlink&quot; title=&quot;Limitations/Issues(限制和已知问题)&quot;&gt;&lt;/a&gt;Limitations/Issues(限制和已知问题)&lt;/h2&gt;&lt;p&gt;Because IDE doesn’t have full sources, it doesn’t know about class members and such.&lt;br&gt;Variables watching works because most of data could be read from memory (objects in Java know about their types), but if for example, you watch an object and it has some nulled member, then you won’t see, what type this member is.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;anchor&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;apktool-2-1-0之后版本动态调试-适用于Android-studio&quot;&gt;&lt;a href=&quot;#apktool-2-1-0之后版本动态调试-适用于Android-studio&quot; class=&quot;headerlink&quot; title=&quot;apktool 2.1.0之后版本动态调试(适用于Android studio)&quot;&gt;&lt;/a&gt;apktool 2.1.0之后版本动态调试(适用于Android studio)&lt;/h1&gt;&lt;p&gt;apktool 2.1.0版本之后，smali调试的逻辑独立出来，放置在smalidea项目，请参见官方地址&lt;a href=&quot;https://github.com/JesusFreke/smali/wiki/smalidea&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/JesusFreke/smali/wiki/smalidea&lt;/a&gt;。依照该地址说明的步骤即可实现smali代码动态调试。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-studio动态调试&quot;&gt;&lt;a href=&quot;#Android-studio动态调试&quot; class=&quot;headerlink&quot; title=&quot;Android studio动态调试&quot;&gt;&lt;/a&gt;Android studio动态调试&lt;/h1&gt;&lt;p&gt;Androi
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="apktool" scheme="http://cstsinghua.github.io/tags/apktool/"/>
    
      <category term="动态调试" scheme="http://cstsinghua.github.io/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    
      <category term="smali" scheme="http://cstsinghua.github.io/tags/smali/"/>
    
      <category term="backsmali" scheme="http://cstsinghua.github.io/tags/backsmali/"/>
    
      <category term="smali Debugging" scheme="http://cstsinghua.github.io/tags/smali-Debugging/"/>
    
  </entry>
  
  <entry>
    <title>Android APK瘦身策略</title>
    <link href="http://cstsinghua.github.io/2016/06/13/Android%20APK%E7%98%A6%E8%BA%AB%E5%88%9D%E6%8E%A2/"/>
    <id>http://cstsinghua.github.io/2016/06/13/Android APK瘦身初探/</id>
    <published>2016-06-13T06:34:28.000Z</published>
    <updated>2016-06-13T06:34:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;随着Android技术的发展，以及用户需求的井喷，Android应用的APK大小也随着越来越“胖”，APK在安装和更新之前都需要经过网络将其下载到手机，如果APK越大消耗的流量就会越多，特别是对于使用移动网络的用户来讲，消耗流量越多就代表需要花更多的钱去购买流量。同时一些第三方应用商城也会对上传的APK大小有限制，所以为了能够让产品能够更受商城和用户欢迎，APK瘦身是第一步，更小的APK标示着更多地用户愿意去下载和体验。因此，APK瘦身大有必要！&lt;/p&gt;
&lt;h1 id=&quot;APK文件结构&quot;&gt;&lt;a href=&quot;#APK文件结构&quot; class=&quot;headerlink&quot; title=&quot;APK文件结构&quot;&gt;&lt;/a&gt;APK文件结构&lt;/h1&gt;&lt;p&gt;Android应用的APK文件其实就是一个压缩文件，可以用常规的压缩软件打开，查看其目录结构。为了能够减小APK的大小，首先需要知道APK由哪些部分构成，然后针对每个部分做相应的优化工作，下图是一个APK解压后的文件结构（各APK的结构核心内容是一致的，差异化的文件暂不关注）:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/nfreQFu.png&quot; alt=&quot;APK目录结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;各文件的介绍如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;classes.dex：classes.dex是java源码编译后生成的java字节码文件。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。Android模拟器中提供了一个dex文件的反编译工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，找到要查看的dex文件，执行dexdump xxx.dex（或者从压缩文件取出dex文件，直接在PC上面找到dexdump.exe的路径，然后执行命令）。另外Dedexer是一个反编译dex文件的开源工具，需要自己编译源代码。而当前，还有比如dex2jar甚至封装好的GUI的工具(比如安卓逆向助手等等)可以反编译dex文件为jar文件，再利用jd-gui工具打开jar文件，就可以阅读java源代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;resources.arsc：编译后的二进制资源文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AndroidManifest.xml：清单文件，该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过压缩的，可以通过AXMLPrinter2工具解开，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;proguard.cfg：代码混淆配置文件(上图中暂无包括混淆配置)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;project.properties：标示APK的target sdk和依赖关系，这里的依赖关系指示的是该APK依赖到了哪些工程(上图中暂无包括依赖配置)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;assets：assets目录可以存放一些配置文件（比如webview本地资源、图片资源、音视频等等），这些文件的内容在程序运行过程中可以通过相关的API（android.content.res.AssetManager）获得。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lib：lib目录下的子目录armeabi存放的是一些so文件。这个地方多讲几句，都是在开发过程中摸索出来的。eclipse在打包的时候会根据文件名的命名规则（lib**.so）去打包so文件，开头和结尾必须分别为“lib”和“.so”，否则是不会打包到apk文件中的。其他非eclipse开发环境没有测试过。如果你是用SDK和NDK开发的话，这部分很重要，甚至可以通过把一些不是so文件的文件通过改名打包到apk中，具体能干些什么那就看你想干什么了，呵呵呵！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;META-INF：META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;res：res目录存放资源文件。包括图片、字符串、raw文件夹下面的音频文件、各种xml文件等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;优化探讨&quot;&gt;&lt;a href=&quot;#优化探讨&quot; class=&quot;headerlink&quot; title=&quot;优化探讨&quot;&gt;&lt;/a&gt;优化探讨&lt;/h1&gt;&lt;p&gt;从前面的目录结构图分析可知，&lt;strong&gt;APK中classes.dex、lib、资源文件是大头，APK瘦身主要就是优化这三类&lt;/strong&gt;，关于这三种类型的文件比较成熟的优化方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;classes.dex:&lt;/strong&gt;这是减少apk文件至关重要的第一步。你要对自己的代码了如子掌。你要移除掉所有无用处的dependency libraries，让你的代码一天比一天优秀，持续地优化你的代码。总而言之，保持一个简洁，最新的代码基础是减少apk文件至关重要的一环。当然，从零开始一个项目并为这个项目保持一份简洁的代码基础很容易。项目越老，这个工作就越困难。事实上，拥有一大段历史背景的项目必须要去处理各种死代码和无用代码。还好有许多的开发工具可以帮我们来做这些事情……Proguard 是一个很强悍的工具，它可以帮你在代码编译时对代码进行混淆，优化和压缩。它有一个专门用来减少apk文件大小的功能叫做 tree-shaking。Proguard 会遍历你的所有代码然后找出无用处的代码。所有这些不可达（或者不需要）的代码都会在生成最终的apk文件之前被清除掉。Proguard 也会重命名你的类属性，类和接口，然整个代码尽可能地保持轻量级水平。也许现在你会认为 Proguard 是一个相当有效地工具。但是能力越大，责任也就越大。现在许多开发这认为Proguard有点让人不省心，因为它会重度依赖反射。哪些类或者属性需要被处理或者不能处理都要开发者对Proguard进行配置。但通过代码混淆，删掉不必要的jar包和代码可实现dex文件的优化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;lib:&lt;/strong&gt;一个硬件设备对应一个架构（mips、arm或者x86），只保留与设备架构相关的库文件夹（主流的架构都是arm的，mips属于小众，默认也是支持arm的so的，但x86的不支持），这样可以大大降低lib文件夹的大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;资源文件：&lt;/strong&gt;Proguard 只会对 Java 代码起作用，那么对哪些资源文件呢？比如一张图片 my_image 在 res/drawable 文件夹中，没有被使用，Proguard 只会移除掉 R 类中的引用，但是图片依然还在文件夹中。Lint 一个静态的代码分析器，你只需通过调用 ./gradlew lint这个简单地命令它就能帮你检查所有无用的资源文件。它在检测完之后会提供一份详细的资源文件清单，并将无用的资源列在“UnusedResources: Unused resources” 区域之下。只要你不通过反射来反问这些无用资源，你就可以放心地移除这些文件了。Lint 会分析资源文件(比如 /res 文件夹下面的文件) ，但是会跳过 assets 文件 ( /assets 文件夹下面的文件)。事实上assets 文件是可以通过它们的文件名直接访问的，而不需要通过Java引用或者XML引用。因此，Lint 也不能判定某个 asset 文件在项目中是否有用。这全取决于开发者对这个文件夹的维护了。如果你没有使用某个asset 文件，那么你就可以直接清除这个文件。通过Lint工具扫描代码中没有使用到的静态资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面介绍的三种类型文件的优化方案的确能够在一定程度上减小APK的大小，但在最近做项目的过程中经过研究发现还可以更进一步优化APK的大小，具体方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多分辨率适配：这里的水很深，网上也有很多文章介绍经验（比如一套图、一套布局，多套dimens.xml文件，在使用最小资源的情况下搞定多分辨率适配），Android官网也有专门的篇章介绍，详细研究可以参看；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预置数据：和游戏一样，程序和数据分离，进入模块时下载预置数据（下载的策略需要注重用户体验，在需要使用数据的地方下载）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片资源：压缩优化图片资源（&lt;strong&gt;图片资源的优化原则是：在不降低图片效果、保证APK显示效果的前提下缩小图片文件的大小。&lt;/strong&gt;），或者使用新的图片格式，Aapt（Android Asset Packaging Tool）就内置了 保真图像压缩算法。例如，一个只需 256 色的真彩PNG图片会被aapt 通过一个颜色调色板转化成一个 8-bit PNG 文件。这可以帮助你减少图片文件的大小。当然你还可以通过Google查找相应的优化工具，比如 压缩png图片的常用工具有tinypng（&lt;a href=&quot;https://tinypng.com&quot; title=&quot;tinypng官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tinypng.com&lt;/a&gt;）、pngquant（&lt;a href=&quot;https://pngquant.org/&quot; title=&quot;pngquant官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pngquant.org/&lt;/a&gt;）、ImageAlpha 和 ImageOptim 等。还有一种只在Android平台上存在的图片文件也可以优化，它就是 9-patches。就目前所了解的情况，还没发现针对这类图片文件的高效优化工具。然而你只需要求你的设计师将它的可扩展区域和内容区域尽可能地减少即可。这不但可以减少资源文件的大小，还能使得以后资源文件的维护变得更加简单。你可以从中选择一个适合你的工具。而&lt;strong&gt;Android支持的新式的图片格式webP&lt;/strong&gt;，下面详细介绍图片资源优化(压缩)的方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;图片压缩工具介绍&quot;&gt;&lt;a href=&quot;#图片压缩工具介绍&quot; class=&quot;headerlink&quot; title=&quot;图片压缩工具介绍&quot;&gt;&lt;/a&gt;图片压缩工具介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.tinypng：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tinypng是一个支持压缩png和jpg图片格式的网站（&lt;a href=&quot;https://tinypng.com&quot; title=&quot;tinypng官网&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tinypng.com&lt;/a&gt;），通过其独特的算法（通过一种叫“量化”的技术，把原本png文件的24位真彩色压缩为8位的索引演示，是一种矢量压缩方法，把颜色值用数值123等代替。）可以实现在无损压缩的情况下图片文件大小缩小到原来的30%-50%甚至更多。&lt;/p&gt;
&lt;p&gt;tinypng的缺点是在压缩某些带有过渡效果（带alpha值）的图片时，图片会失真，这种图片可以将png图片转换为下面介绍的webP格式，可以在保证图片质量的前提下大幅缩小图片的大小。需要说明的是：tinypng支持png和jpg图片的压缩，并且也支持9图的压缩。&lt;/p&gt;
&lt;p&gt;tinypng提供了开放接口供开发者开发属于自己的压缩工具，不过这是付费服务，对于普通用户来说，tinypng为每个用户提供的每月图片免费压缩数量（目前是500张/月）已经足够了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.使用webP图片格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebP是谷歌研发出来的一种图片数据格式，它是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。目前很多公司已经将webP技术运用到Android APP中，比如FaceBook、腾讯、淘宝。webP相比于png最明显的问题是加载稍慢，不过现在的智能设备硬件配置越来越高，这都不是事儿。&lt;/p&gt;
&lt;p&gt; 假如你打算在 App 中使用 WebP，除了 Android4.0 以上提供的原生支持外，其他版本以可以使用官方提供的解析库webp-android-backport编译成so使用。&lt;/p&gt;
&lt;p&gt; 通常UI提供的图片都是png或者jpg格式，我们可以通过智图或者isparta将其它格式的图片转换成webP格式，isparta可实现批量转换，墙裂推荐！&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;APK瘦身是一个系统工程，不可能一蹴而就，而且与APK的体验及功能等密切相关，不能顾此失彼，既要保证APK和画面的质量，又要尽量减少APK的体积，因此，需要综合考虑各个因素，做出更优的策略。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;随着Android技术的发展，以及用户需求的井喷，Android应用的APK大小也随着越来越“胖”，APK在安装和更新之前都需要经过网络将其
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="APK瘦身" scheme="http://cstsinghua.github.io/tags/APK%E7%98%A6%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>python安装某些第三方包报错解决办法</title>
    <link href="http://cstsinghua.github.io/2016/06/13/python%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <id>http://cstsinghua.github.io/2016/06/13/python安装第三方包错误解决/</id>
    <published>2016-06-13T01:57:02.000Z</published>
    <updated>2017-10-11T02:01:42.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1-python安装某些第三方包报错vcvarsall-bat&quot;&gt;&lt;a href=&quot;#1-python安装某些第三方包报错vcvarsall-bat&quot; class=&quot;headerlink&quot; title=&quot;1. python安装某些第三方包报错vcvarsall.bat&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;python安装某些第三方包报错vcvarsall.bat&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;原因：python安装某些第三方包(这里主要针对Windows平台)，主要是涉及系统底层和本地代码库时，需要C编译环境，Windows平台下，python本身是通过VC的编译环境编译的，不同的python版本对应不同的VC的动态库，同时，第三方库可能是采用其他编译器（比如GNU C、Cygwin、MinGW等）编译扩展的C代码。&lt;/p&gt;
&lt;p&gt;Mingw官方链接：&lt;a href=&quot;http://sourceforge.net/projects/mingw/&quot; title=&quot;Mingw官网链接&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/mingw/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方说明：python3的安装包的构建主要是通过内置的Distutils工具来完成(&lt;a href=&quot;https://docs.python.org/3.4/install/&quot; title=&quot;Building Extensions: Tips and Tricks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.python.org/3.4/install/&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Whenever possible, the Distutils try to use the configuration information made available by the Python 
interpreter used to run the setup.py script. For example, the same compiler and linker flags used to compile 
Python will also be used for compiling extensions. Usually this will work well, but in complicated situations 
this might be inappropriate. This section discusses how to override the usual Distutils behaviour.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装python对应版本的VC编译器，可以直接安装整个visual studio；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果不想整个安装VC，则可以选择安装MinGW（并将其安装后的bin等目录加入到系统path），然后配置python分发包的默认编译工具，&lt;br&gt;即在python安装目录的Lib\distutils目录下(比如安装的python3.4版本，那么即似C:\Python34\Lib\distutils)，新建distutils.cfg文件(如果已有，则直接编辑之)。打开该文件，在前面添加如下内容(这里是32位的mingw，所以是mingw32,64位则为mingw64)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build]
compiler=mingw32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 上述设置之后python distutils构建带C扩展的库或者安装C扩展的库之时，全部都切换至设置的编译器，如果只是想修改某一次的构建或者安装时使用的编译器，则可以在构建或者安装的时候加上参数，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python setup.py build --compiler=mingw32 install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果也不想自己手动安装mingw，想更简便，有一种便捷的方式可以走。一般情况下，大家都会在自己的windows主机上安装Git(这里安装的是64位的git，如果安装32位的git，那么对应的是mingw32)，下载的官方地址为&lt;a href=&quot;https://git-for-windows.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows git官方下载&lt;/a&gt;，安装之后，会自动安装mingw(windows版本Git依赖mingw，安装在git的安装目录下)，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://i.imgur.com/c6Jmtn4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 此时将mingw的bin目录也就是&lt;code&gt;D:\Program Files\Git\mingw64\bin&lt;/code&gt;添加到系统path环境变量中。然后就和方法2中的后续步骤一致，即配置python分发包的默认编译工具，在python安装目录的Lib\distutils目录下(比如安装的python3.4版本，那么即似C:\Python34\Lib\distutils)，新建distutils.cfg文件(如果已有，则直接编辑之)。打开该文件，在前面添加如下内容(这里是64位的mingw，所以是mingw64,32位则为mingw32)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build]
compiler=mingw64
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;采用上述方法配置好之后，再次安装即可成功。&lt;/p&gt;
&lt;h1 id=&quot;2-安装某些包时报错，类似”collect2-exe-error-ld-returned-1-exit-status”，&quot;&gt;&lt;a href=&quot;#2-安装某些包时报错，类似”collect2-exe-error-ld-returned-1-exit-status”，&quot; class=&quot;headerlink&quot; title=&quot;2.安装某些包时报错，类似”collect2.exe: error: ld returned 1 exit status”，&quot;&gt;&lt;/a&gt;2.&lt;strong&gt;安装某些包时报错，类似”collect2.exe: error: ld returned 1 exit status”，&lt;/strong&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;C:\Python27\libs/libpython27.a(dmmes01026.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos;
C:\Python27\libs/libpython27.a(dmmes00281.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos;
C:\Python27\libs/libpython27.a(dmmes00105.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos;
C:\Python27\libs/libpython27.a(dmmes00253.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos;
C:\Python27\libs/libpython27.a(dmmes00227.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos;
C:\Python27\libs/libpython27.a(dmmes00712.o):(.idata$7+0x0): more undefined references to `_head_C__build27_cpython_PCBuild_libpython27_a&amp;apos; follow
collect2.exe: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因：和问题1本质一样，由于Windows平台下的python编译器本身由VC环境编译，其生成的pythonxx.dll(xx是版本号，比如27、34)和pythonxx.lib等可能与需要安装的第三方库（采用Cygwin、MinGW等编译器(环境)生成并发布）无法兼容.&lt;/p&gt;
&lt;p&gt;解决方案：&lt;br&gt;    To create Python extensions, you need to link against the Python library. Unfortunately, most Python distributions are provided with  Pythonxx.lib, a library in Microsoft Visual C++ format. GCC expects a.a file (libpythonxx.a to be precise.). Here’s how to convert  pythonxx.lib to libpythonxx.a:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt;Download pexport (from here or &lt;a href=&quot;http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt;Get  pythonxx.dll (it should be somewhere on your harddrive).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt;Run : pexports pythonxx.dll &amp;gt; pythonxx.def This will extract all symbols from pythonxx.dll and write them into pythonxx.def.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d.&lt;/strong&gt;Run : dlltool –dllname pythonxx.dll –def pythonxx.def –output-lib libpythonxx.a This will create libpythonxx.a (dlltool is part of MinGW utilities).&lt;br&gt;Copy libpythonxx.a to c:\pythonxx\libs\ (in the same directory as  pythonxx.lib).&lt;br&gt;This trick should work for all Python versions, including future releases of Python. You can also use this trick to convert other libraries.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-python安装某些第三方包报错vcvarsall-bat&quot;&gt;&lt;a href=&quot;#1-python安装某些第三方包报错vcvarsall-bat&quot; class=&quot;headerlink&quot; title=&quot;1. python安装某些第三方包报错vcvarsall.b
    
    </summary>
    
      <category term="Python" scheme="http://cstsinghua.github.io/categories/Python/"/>
    
    
      <category term="安装第三方包" scheme="http://cstsinghua.github.io/tags/%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cstsinghua.github.io/2016/06/13/hello-world/"/>
    <id>http://cstsinghua.github.io/2016/06/13/hello-world/</id>
    <published>2016-06-13T01:57:02.000Z</published>
    <updated>2016-06-13T01:57:02.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For Test:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/okhttp-3.3.1.jar&quot;&gt;文件下载&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="杂项" scheme="http://cstsinghua.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://cstsinghua.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>推送方案</title>
    <link href="http://cstsinghua.github.io/2016/06/08/%E6%8E%A8%E9%80%81%E6%96%B9%E6%A1%88/"/>
    <id>http://cstsinghua.github.io/2016/06/08/推送方案/</id>
    <published>2016-06-08T09:09:16.000Z</published>
    <updated>2016-12-21T01:53:05.000Z</updated>
    
    <content type="html">&lt;p&gt;本文梳理当前主流的推送技术，对里面涉及到的概念和技术进行全面的阐述&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;推送简介&quot;&gt;&lt;a href=&quot;#推送简介&quot; class=&quot;headerlink&quot; title=&quot;推送简介&quot;&gt;&lt;/a&gt;推送简介&lt;/h1&gt;&lt;p&gt;推送技术，又名反向AJAX，指的是一种基于Internet，将由中心或发布者发出消息传输给用户的技术。与之相对的是拉取（参见AJAX），这种情况下请求是由用户或客户端主动向服务端发起，以拉取消息。(摘自维基百科)&lt;/p&gt;
&lt;p&gt;在移动互联网时代以前的手机，如果有事情发生需要通知用户，则会有一个窗口弹出，将告诉用户正在发生什么事情。可能是未接电话的提示，日历的提醒，或是一封新的彩信。推送功能最早是被用于Email中，用来提示我们新的信息。由于时代的发展和移动互联网的热潮，推送功能更加地普及，已经不再仅仅用在推送邮件了，更多地用在我们的APP中了。&lt;/p&gt;
&lt;p&gt;当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震应急通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息，一般来说有两种方法：第一种是客户端使用Pull（拉）的方式，就是隔一段时间就去服务器上获取一下信息，看是否有更新的信息出现。第二种就是 服务器使用Push（推送）的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。这样，客户端就能自动的接收到消息。 &lt;/p&gt;
&lt;p&gt;虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能，但是明显来说Push方式比Pull方式更优越。因为Pull方式更费客户端的网络流量，更主要的是费电量，还需要我们的程序不停地去监测服务端的变化。  &lt;/p&gt;
&lt;p&gt;在开发Android和iPhone应用程序时，我们往往需要从服务器不定的向手机客户端即时推送各种通知消息。我们只需要在Android或IPhone的通知栏处向下一拉，就展开了Notification Panel，可以集中一览各种各样通知消息。目前IOS平台上已经有了比较简单的和完美的推送通知解决方案(参见下文APNs)，可是Android平台上实现则是乱象丛生，当然也可以说是百家争鸣。下文会详细介绍。&lt;/p&gt;
&lt;h1 id=&quot;怎么实现推送及各种方式的比较&quot;&gt;&lt;a href=&quot;#怎么实现推送及各种方式的比较&quot; class=&quot;headerlink&quot; title=&quot;怎么实现推送及各种方式的比较&quot;&gt;&lt;/a&gt;怎么实现推送及各种方式的比较&lt;/h1&gt;&lt;p&gt;从上面推送的介绍可知，要实现消息推送，肯定存在多种思路和方案。&lt;/p&gt;
&lt;p&gt;一些分析文章或链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tokudu.com/post/50024574938/how-to-implement-push-notifications-for-android&quot; title=&quot;tokudu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tokudu写的较全面分析推送机制的原创文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hanyonglu/archive/2012/03/04/2378971.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/hanyonglu/archive/2012/03/04/2378971.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/shagoo/article/details/7899466&quot; title=&quot;csdn博客&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/shagoo/article/details/7899466&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/nicsun/blog/98184?fromerr=P9V1ZUai&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://my.oschina.net/nicsun/blog/98184?fromerr=P9V1ZUai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里罗列出目前收集到的推送实现机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Poll(轮询)：&lt;/strong&gt;从名字很明显就告诉你，它甚至不是一种真正的推送。该方式基于从后台的本地或远程服务周期性地从服务器轮询获取消息。轮询越频繁，那么就获取更加实时的推送。实现轮询的方式很多种，比如可以采用HTTP协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 实现简单，成本低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 实时性差，更严重地是, 轮询较15-30次/分钟更频繁的话，将会很快耗尽电池电量。参见一些实验数据: &lt;a href=&quot;https://labs.ericsson.com/apis/mobile-java-push/blog/save-device-battery-mobile-java-push&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://labs.ericsson.com/apis/mobile-java-push/blog/save-device-battery-mobile-java-push&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. SMS(短信) ：&lt;/strong&gt;Android系统运行应用拦截SMS短信息。当有新的事件时，服务器发送一掉经过特别加密处理的SMS到手机端。此时，APP可以拦截所有的短信，并从中找到来自自己服务器发出的消息，然后弹出一个通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 实现简单，实时性非常好. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 对应应用开发者和用户来说代价高昂. 发送SMS需要成本，不同的运营商的策略都有差异，如果想实现基于SMS的全球性的推送，那么开发者很可能需要为此支付大笔金钱。站在用户的角度，保护隐私，以及不愿意因为使用APP而付出额外的SMS费用，都是必须考虑的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Persistent TCP/IP(TCP长连接)：&lt;/strong&gt;手机端与服务器之间建立一条TCP长连接(大部分时间处于idle空闲状态)，并且通过偶尔发送心跳包来使长连接保持存活。一旦服务端有新的事件，则可以通过这条长连接来发送消息到客户端。&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;术语解释：&lt;/strong&gt;&lt;br&gt;&lt;br&gt;Client/Server通信方式建立后，下一步就需要考虑通信连接的方式，主要有两种方式的连接，即长连接通信与短连接通信。关于TCP/IP的相关知识和原理可以参见《TCP/IP详解》(W.Richard Stevens著)&lt;br&gt;&lt;br&gt;&lt;strong&gt;短连接：&lt;/strong&gt;短连接通信是指 Client 方与 Server 方每进行一次通信报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于多个 Client 连接一个 Server 情况，常用于机构与用户之间通信，比如 OLTP（联机事务处理）类应用。在短连接情况下，Client 端完成任务后，就关闭连接并退出。在 Server 端，可以通过循环 accept()，使 Server 不会退出，并连续处理 Client 的请求。&lt;br&gt;&lt;br&gt;&lt;strong&gt;长连接：&lt;/strong&gt;长连接通信是指 Client 方与 Server 方先建立通讯连接，连接建立后不会断开，然后再进行报文发送和接收，报文发送与接收完毕后，原来连接不会断开而继续存在，因此可以连续进行交易报文的发送与接收。这种方式下由于通讯连接一直存在，其 TCP/IP 状态是 Established，可以用操作系统的命令 netstat 查看连接是否建立。由于在长连接情况下，Client 端和 Server 端一样可以固定使用一个端口，所以长连接下的 Client 也需要使用 bind() 来绑定 Client 的端口。在长连接方式下，需要循环读写通信数据。为了区分每一次交易的通信数据，每一次交易数据常常需要在数据头部指定该次交易的长度，接收 API 需要首先读出该长度，然后再按该长度读出指定长度的字节。长连接方式常用于一个 Client 端对一个 Server 端的通讯，一般常用于机构与机构之间的商业应用通信，以处理机构之间连续的大量的信息数据交换。或者说可用于两个系统之间持续的信息交流情况。通常为了加快两个系统之间的信息交流，通常还需要建立几条长连接的并行通信线路。&lt;br&gt;&lt;/font&gt;

&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 实时性好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 很难在客户端和服务端之间实现可靠的长连接(服务)。IOS系统不允许APP驻留在后台，而Android系统也会在系统可用内存很少的时候杀掉某些服务，所以推送通知服务很可能就被杀掉。另外，一旦手机进入睡眠状态，这个时候正常情况下也是无法接收和处理服务器发送的消息。而且在耗电方面，也需要谨慎对待。&lt;/p&gt;
&lt;p&gt;前面两种方式都有比较明显的缺点，而且对此我们无能为力。但是，第三种方式，即TCP长连接的缺点并非那么严重。只要我们进行良好的设计和付出努力，长连接方式可以较好地工作。毕竟，GMail, GTalk以及Google Voice都可以实现实时更新。事实上，非常多的开发者都认同TCP长连接可能是实现推送的最佳方式。而市场上主流的推送方案，包括IOS和Android官方的推送方案在本质上都是采用了TCP长连接的机制来实现。本质上，APNs 与GCM是类似的技术实现原理：即系统层有一个常驻的 TCP 长连接，一直保持的长连接，即使手机休眠的时候也在保持的长连接。&lt;/p&gt;
&lt;h1 id=&quot;当前主流的推送方案&quot;&gt;&lt;a href=&quot;#当前主流的推送方案&quot; class=&quot;headerlink&quot; title=&quot;当前主流的推送方案&quot;&gt;&lt;/a&gt;当前主流的推送方案&lt;/h1&gt;&lt;p&gt;先看看主流平台官方的方案吧。当前移动端的两大平台IOS和Android均有自己官方的推送解决方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IOS平台：&lt;/p&gt;
&lt;p&gt; APNs （Apple Push Notification service），官方链接：&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html&quot; title=&quot;苹果推送APNs地址&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果推送APNs官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android平台：&lt;/p&gt;
&lt;p&gt; GCM (Google Cloud Messaging），官方链接：&lt;a href=&quot;https://developers.google.com/cloud-messaging/&quot; title=&quot;Google官方推送GCM&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google官方推送GCM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 值得一提的是，Google官方最初退出的推送方案是Android Cloud to Device Messaging (C2DM) ，已被废弃，于2015.10.20完全关闭。关于C2DM和GCM的差异，以及从C2DM迁移到GCM，可以参见&lt;a href=&quot;https://developers.google.com/cloud-messaging/c2dm&quot; title=&quot;C2DM迁移到GCM&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;C2DM迁移到GCM&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了官方的方案，也存在很多第三方解决方案，这里只提国内的，原因你懂的。目前主要有：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;较早的：JPush、个推&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后来的：腾讯的信鸽、小米推送、百度推送、华为推送、友盟推送等&lt;/p&gt;
&lt;p&gt;  关于第三方推送方案的使用统计，可以参见GitHub上面的一个调查：&lt;a href=&quot;https://github.com/android-cn/topics/issues/4&quot; title=&quot;第三推送方案调查&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android 第三方 Push 推送方案使用调查&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如前文提到，目前上述方案基本都是基于长连接的方式来实现。而平台自身提供的方案将实现长连接的服务内置在系统内部，这样就即使APP进程被kill了，那么仍然可以接受消息。而第三方的方案，一旦APP进程被kill(准确来说是实现长连接的service所在的进程)，那么就无法接受推送的消息了。&lt;/p&gt;
&lt;p&gt;大家在本质上都是采用长连接，但是基于长连接来实现推送，在上层实现方面存在很多的协议和具体方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用MQTT协议&lt;/p&gt;
&lt;p&gt; MQTT(MQ Telemetry Transport)是IBM开发的基于轻量级的、基于”发布/订阅”模式的消息传输协议,用于有限制的设备(比如嵌入式设备)和低带宽、高延迟或不可靠的网络。&lt;/p&gt;
&lt;p&gt; MQTT官网：&lt;a href=&quot;http://mqtt.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mqtt.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 当前已有多个基于MQTT协议的推送开源项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tokudu达人的开源项目：&lt;a href=&quot;https://github.com/tokudu/AndroidPushNotificationsDemo&quot; title=&quot;MQTT客户端&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTT客户端项目&lt;/a&gt;、&lt;a href=&quot;https://github.com/tokudu/PhpMQTTClient&quot; title=&quot;MQTT服务端PHP实现&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTT服务端PHP实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IBM官方的开源实现：&lt;a href=&quot;http://www.eclipse.org/paho/&quot; title=&quot;paho项目&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;paho项目&lt;/a&gt;、&lt;a href=&quot;http://mosquitto.org/&quot; title=&quot;MQTT broker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTT broker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其他：&lt;a href=&quot;https://code.google.com/archive/p/mosquitto-mqtt-client-android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MQTT客户端实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：协议简洁、小巧、可扩展性强、省流量、省电，应用到企业领域，已有多个开源项目提供参考。&lt;/p&gt;
&lt;p&gt;缺点：不够成熟、实现较复杂，部署硬件成本较高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用XMPP协议（Openfire + Spark + Smack）&lt;/p&gt;
&lt;p&gt; XMPP（Extensible Messageing and Presence Protocol：可扩展消息与存在协议）是目前主流的四种IM（IM：instant messaging,即时消息）协议之一，其他三种分别为：即时信息和空间协议(IMPP)、空间和即时信息协议(PRIM)、针对即时通讯和空间平衡扩充的进程开始协议SIP(SIMPLE)。其是基于XML协议的通讯协议，前身是Jabber，已由IETF国际标准化组织完成了标准化工作。&lt;/p&gt;
&lt;p&gt; Spark,smack和Openfire，这三个合起来就是一个完整的XMPP IM实现。包括服务器端——Openfire，客户端——Spark，XMPP 传输协议的实现——Smack（记住，XMPP是一个协议，协议是需要实现的，Smack起到的就是这样的一个作用）。三者都是基于Java 语言的实现。&lt;/p&gt;
&lt;p&gt; 当前已有基于XMPP开发Android推送的开源项目：&lt;a href=&quot;https://github.com/dannytiehui/androidpn&quot; title=&quot;androidpn实现Android推送&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;androidpn项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 优点：协议成熟、强大、可扩展性强、主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。&lt;/p&gt;
&lt;p&gt; 缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自主开发协议&lt;br&gt; 自主开发相关协议，实现可靠长连接和服务端。比如各大互联网公司推出的推送方案(当然，这里面很多其实是在一些开源项目上进行二次开发而成)&lt;/p&gt;
&lt;p&gt; 优点：完全自主设计，可控，不用担心数据外泄。&lt;/p&gt;
&lt;p&gt; 缺点：实现难度大，开发成本很高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;我们的推送方案&quot;&gt;&lt;a href=&quot;#我们的推送方案&quot; class=&quot;headerlink&quot; title=&quot;我们的推送方案&quot;&gt;&lt;/a&gt;我们的推送方案&lt;/h1&gt;&lt;p&gt;基于上面的信息，对于一个普通公司，如果想在自己的APP里面实现推送，可以有如下一些方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;集成官方推送，比较靠谱，但是Android平台下，由于众所周知的原因，你懂的，GCM基本无法满足要求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集成第三方推送，简单，也比较可靠，比如集成个推推送，但是存在一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要向第三方支付费用，可能费用不菲&lt;/li&gt;
&lt;li&gt;数据存在泄露的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自主开发&lt;/p&gt;
&lt;p&gt;   如果完全另起炉灶，那难度比较大，成本也很高。因此基于现有的MQTT或XMPP协议，及其相关的开源项目，是比较可行的方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么到底选择哪一个协议呢？待续！个人倾向于MQTT协议，因为其更轻量级，对于流量和电量的消耗相对更少，而且现有的服务端实现Mosquitto的单机性能也非常不错，且可以实现集群部署。&lt;/p&gt;
&lt;p&gt;当然，自主设计存在以下一些问题需要解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;稳定保持长连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端的设计，怎么考虑跨多个平台(另外，富媒体消息等，不仅仅是服务端推送，业务端上行upstream，支持多种协议，以及后续其他扩展)，怎么支持2000K甚至更高并发量的长连接及其服务器集群设计；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推送ID策略的设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;再论长连接&quot;&gt;&lt;a href=&quot;#再论长连接&quot; class=&quot;headerlink&quot; title=&quot;再论长连接&quot;&gt;&lt;/a&gt;再论长连接&lt;/h2&gt;&lt;p&gt;长连接方案乍一听怪怪的, 对网络通信或TCP/IP协议族不是很了解人难免会问：什么是长连接? 定时发送心跳, 这和轮询有什么区别? 心跳是干什么的? 同样是定期和服务器沟通, 为什么长连接就比轮询更加优秀? 手机休眠了TCP连接不会断掉吗?&lt;/p&gt;
&lt;h3 id=&quot;什么是长连接&quot;&gt;&lt;a href=&quot;#什么是长连接&quot; class=&quot;headerlink&quot; title=&quot;什么是长连接&quot;&gt;&lt;/a&gt;什么是长连接&lt;/h3&gt;&lt;p&gt;与长连接相对的就是短连接。先说短连接, 短连接是通讯双方有数据交互时就建立一个连接, 数据发送完成后，则断开此连接.&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/GJJJdm9.png&quot; alt=&quot;短连接和长连接示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;长连接就是大家建立连接之后, 不主动断开。 双方互相发送数据, 发完了也不主动断开连接, 之后有需要发送的数据就继续通过这个连接发送。&lt;/p&gt;
&lt;p&gt;TCP连接在默认的情况下就是所谓的长连接(前提是应用层没有设置keepalive，下文会做摘要介绍，详细内容关于keepalive请参见《TCP/IP详解 卷1 协议》第二版第17章), 也就是说连接双方都不主动关闭连接, 这个连接就应该一直存在。以下英文段落摘自《TCP/IP详解 卷1 协议》第二版第17章(p793)的引言部分。&lt;/p&gt;
&lt;p&gt;Many newcomers to TCP/IP are surprised to learn that no data whatsoever flows across an idle TCP/IP connection.This is，if neither process at the ends of a TCP connection is sending data to the other,nothing is exchanged between the two TCP endpoints.There is no polling,for example,as you might find with other networking protocols.&lt;strong&gt;This means that we can start a client process that establishes a TCP connection with a sever and walk away for hours,days,weeks,or months,and the connection should remain up.&lt;/strong&gt;In theory, intermediate routers can crash and reboot,data lines may go down and back up,but as long as neither host at the ends of the connection reboots(or changes its IP address),the connection remainsestablished.&lt;strong&gt;This is how TCP/IP was designed.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note: &lt;/p&gt;
&lt;p&gt;The previous statement assumes that neither application——neither the client nor the server——has &lt;strong&gt;application-level timers&lt;/strong&gt; to detect inactivity,causing either application to terminate.It also assumes that no intermediate router is keeping state about the connection(such as a NAT box)that is required for proper operation that it might delete because of inactivity or lose because of system failure.In today’s Internet，these are big assumptions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于TCP keepalive：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP keepalive is a controversial feature.Either end of a TCP connection may request keepalives,which are turned off by default，for their respective direction of the connection.A keepalive can be set for one side,both sides,or neither side.There are several configurable parameters that control ths operation of keepalives.If there is no activity on the connection for some period of time(called the &lt;em&gt;keepalive&lt;/em&gt; time),the side(s) with keepalive enabled sends a keepalive probe to its peer(s).If no response is received,the probe is repeated periodically with a period set by the&lt;em&gt; keepalive interval&lt;/em&gt; until a number of probes equal to the number &lt;em&gt;keepalive probes&lt;/em&gt; is reached.If this happens,the peer’s system is determined to be unreachable and the connection is terminated.&lt;/p&gt;
&lt;p&gt;The value &lt;strong&gt;KeepaliveTime&lt;/strong&gt; defaults to 7,200,000ms(2 hours);&lt;strong&gt;KeepaliveInterval&lt;/strong&gt; defaults to 1000ms(1s).If there is no response to ten keepalive probes,Windows terminates the connection.&lt;/p&gt;
&lt;p&gt;Note that [RFC1122] places certain restrictions on the use of keepalives.In particular,the &lt;em&gt;keepalive time&lt;/em&gt; must be&lt;br&gt;configurable and must not default to less than 2 hours.In addition,keepalives must not be enabled unless an application requests one(although this behavior is violated if the net.inet.tcp.alwayskeepalive variable is set).Linux does not provide a native facility for adding keepalives to applications that do not request it,but a special library can be preloaded(i.e., loaded prior to ordinary shared libraries)to get this effect [LKA].&lt;/p&gt;
&lt;p&gt;但是网络中的情况是复杂的, 这个连接可能会被切断。比如客户端到服务器的链路因为故障断了, 或者服务器宕机了, 或者是你家网线被人剪了, 这些都是一些莫名其妙的导致连接被切断的因素, &lt;strong&gt;还有几种比较特殊的&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NAT条目老化或超时&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为IPv4地址不足， 或者我们想通过无线路由器上网， 我们的设备可能会处在一个NAT设备的后面,用户终端或PC实际分配到的IP是私有IP。而NAT设备的出口则是公有IP，当然也存在多级NAT级联的情况。生活中最常见的NAT设备是家用路由器。关于NAT技术和原理请参见经典文章&lt;a href=&quot;http://www.bford.info/pub/net/p2pnat/&quot; title=&quot;NAT参考文献&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.bford.info/pub/net/p2pnat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NAT设备会在IP封包通过设备时修改源/目的IP地址。对于家用路由器来说， 使用的是网络地址端口转换(NAPT，Network Address/Port Translation)， 它不仅改IP，还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP。 举个例子， NAPT维护一个类似下表的NAT表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内网地址&lt;/th&gt;
&lt;th&gt;外网地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;192.168.0.2:5566&lt;/td&gt;
&lt;td&gt;120.132.92.21:9200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;192.168.0.3:7788&lt;/td&gt;
&lt;td&gt;120.132.92.21:9201&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;192.168.0.3:8888&lt;/td&gt;
&lt;td&gt;120.132.92.21:9202&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;  NAT设备会根据NAT表对出去和进来的数据做修改， 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202， 外部就认为他们是在和120.132.92.21:9202通信。 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888， 再发给内网的主机， 这样内部和外部就能双向通信了， 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了， 那么外部设备就无法直接与192.168.0.3:8888通信了。&lt;/p&gt;
&lt;p&gt;  我们的设备经常是处在NAT设备的后面， 比如在公司的内部网络内， 查一下自己分配到的IP，其实是内网IP，表明我们在NAT设备后面。&lt;/p&gt;
&lt;p&gt;  一般情况下，在网络设备比如路由器上面，NAT条目(表)存在老化时间(参见《TCP/IP详解 卷1 协议》第二版第7章)，超过老化时间(一般SOHO级路由器如TP-LINK路由器UDP对应的NAT条目老化时间在5min左右，而TCP也相差不大)，则会清空对应的NAT条目。此外，大部分移动无线网络运营商在链路上一段时间内没有数据通讯后，会淘汰NAT表中的对应项， 造成链路中断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;网络状态切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  手机网络和WIFI网络切换， 网络断开和连上等情况， 也会使长连接断开。 这里原因可能比较多， 但结果无非就是IP变了， 或者被系统通知连接断了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DHCP的租期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  一般而言，PC端或手机终端获取IP地址的方式大多是动态获取，即通过DHCP协议从DHCP服务器(一般由路由器同时兼任)获取。目前测试发现安卓系统对DHCP的处理有Bug， DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;心跳包的作用&quot;&gt;&lt;a href=&quot;#心跳包的作用&quot; class=&quot;headerlink&quot; title=&quot;心跳包的作用&quot;&gt;&lt;/a&gt;心跳包的作用&lt;/h3&gt;&lt;p&gt;从《TCP/IP详解 卷1 协议》可知，TCP长连接本质上不需要心跳包来维持。那为什么要有心跳包呢? 其实主要是为了防止上面提到的NAT超时，既然一些NAT设备判断是否淘汰NAT映射条目的依据是一定时间内没有数据，那么客户端就主动发一个数据。&lt;/p&gt;
&lt;p&gt;当然，如果仅仅是为了防止NAT超时，可以让服务器来发送心跳包给客户端，不过这样做有个弊病就是，万一连接断了，服务器就再也联系不上客户端了，所以心跳包必须由客户端发送，客户端发现连接断了，还可以尝试重连服务器。&lt;/p&gt;
&lt;p&gt;所以心跳包的主要作用是防止NAT超时，其次是探测连接是否断开。最终目的也就是判断长连接是否存活有效。&lt;/p&gt;
&lt;p&gt;链路断开，没有写操作的TCP连接是感知不到的，除非这个时候发送数据给服务器，造成写超时，否则TCP连接不会知道断开了。主动kill掉一方的进程。 另一方会关闭TCP连接。是系统代进程给服务器发的FIN。TCP连接就是这样。只有明确的收到对方发来的关闭连接的消息(收到RST也会关闭, 大家都懂)。或者自己意识到发生了写超时， 否则它认为连接还存在。&lt;/p&gt;
&lt;h3 id=&quot;心跳包的时间间隔&quot;&gt;&lt;a href=&quot;#心跳包的时间间隔&quot; class=&quot;headerlink&quot; title=&quot;心跳包的时间间隔&quot;&gt;&lt;/a&gt;心跳包的时间间隔&lt;/h3&gt;&lt;p&gt;既然心跳包的主要作用是防止NAT超时， 那么这个间隔就大有文章了。&lt;/p&gt;
&lt;p&gt;发送心跳包势必要先唤醒设备， 然后才能发送， 如果唤醒设备过于频繁， 或者直接导致设备无法休眠， 会大量消耗电量， 而且移动网络下进行网络通信， 比在wifi下耗电得多。所以这个心跳包的时间间隔应该尽量的长， 最理想的情况就是根本没有NAT超时。&lt;/p&gt;
&lt;p&gt;现实是残酷的，根据网上的一些说法，中移动2/3G下，NAT超时时间为5分钟，中国电信3G则大于28分钟，理想的情况下，客户端应当以略小于NAT超时时间的间隔来发送心跳包。&lt;/p&gt;
&lt;p&gt;wifi下， NAT超时时间都会比较长， 据说宽带的网关一般没有空闲释放机制， GCM有些时候在wifi下的心跳比在移动网络下的心跳要快， 可能是因为wifi下联网通信耗费的电量比移动网络下小。&lt;/p&gt;
&lt;p&gt;关于如何让心跳间隔逼近NAT超时的间隔， 同时自动适应NAT超时间隔的变化， 可以参看&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;amp;mid=207243549&amp;amp;idx=1&amp;amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;amp;scene=4#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android微信智能心跳方案&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;怎样发送心跳包&quot;&gt;&lt;a href=&quot;#怎样发送心跳包&quot; class=&quot;headerlink&quot; title=&quot;怎样发送心跳包&quot;&gt;&lt;/a&gt;怎样发送心跳包&lt;/h3&gt;&lt;p&gt;Android手机可以进入休眠状态，为了不让NAT映射条目失效，我们需要定时的发心跳，以刷新NAT表项，避免被淘汰。&lt;/p&gt;
&lt;p&gt;Android 上定时运行任务常用的方法有2种，一种方法用Timer，另一种是AlarmManager。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Timer&lt;/p&gt;
&lt;p&gt;  Android的Timer类可以用来计划需要循环执行的任务，Timer的问题是它需要用WakeLock让CPU保持唤醒状态(即Timer的时钟是依赖于CPU的)，这样会大量消耗手机电量，大大减短手机待机时间。这种方式不能满足我们的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AlarmManager&lt;/p&gt;
&lt;p&gt;  AlarmManager是Android系统封装的用于管理RTC的模块，RTC(Real Time Clock)是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。&lt;/p&gt;
&lt;p&gt;  这意味着，如果我们用AlarmManager来定时执行任务，CPU可以正常的休眠，只有在需要运行任务时醒来一段很短的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于Android的休眠和AlarmManager定期执行发送心跳包，可以参见下文的详细阐述。&lt;/p&gt;
&lt;h3 id=&quot;服务器如何处理心跳包&quot;&gt;&lt;a href=&quot;#服务器如何处理心跳包&quot; class=&quot;headerlink&quot; title=&quot;服务器如何处理心跳包&quot;&gt;&lt;/a&gt;服务器如何处理心跳包&lt;/h3&gt;&lt;p&gt;如果客户端心跳间隔是固定的， 那么服务器在连接闲置超过这个时间还没收到心跳时， 可以认为对方掉线， 关闭连接。 如果客户端心跳会动态改变，如上节提到的微信心跳方案， 应当设置一个最大值， 超过这个最大值才认为对方掉线。还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时。 可以直接认为对方掉线。这个就需要具体业务具体分析了，也许还有更优的策略， 这里就不写了。&lt;/p&gt;
&lt;h3 id=&quot;心跳包和轮询的区别&quot;&gt;&lt;a href=&quot;#心跳包和轮询的区别&quot; class=&quot;headerlink&quot; title=&quot;心跳包和轮询的区别&quot;&gt;&lt;/a&gt;心跳包和轮询的区别&lt;/h3&gt;&lt;p&gt;心跳包和轮询看起来类似， 都是客户端主动联系服务器， 但是区别很大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询是为了获取数据， 而心跳是为了保活TCP连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;轮询得越频繁， 获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;轮询比心跳能耗更高， 因为一次轮询需要经过TCP三次握手， 四次挥手， 单次心跳不需要建立和拆除TCP连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TCP唤醒Android&quot;&gt;&lt;a href=&quot;#TCP唤醒Android&quot; class=&quot;headerlink&quot; title=&quot;TCP唤醒Android&quot;&gt;&lt;/a&gt;TCP唤醒Android&lt;/h2&gt;&lt;p&gt;至此，我们可以维护稳定的长连接了，但是要长连接只是推送的基础，要想服务端的推送消息实时达到客户端(通过长连接)，还有更多事情要做。&lt;/p&gt;
&lt;p&gt;首先，也是最棘手的问题，如果Android手机休眠了，这个时候服务端通过长连接发送的数据能被手机接收到吗？其次，即使手机能接收到数据，那么又是怎么唤醒手机CPU来显示通知消息以及执行相关APP逻辑呢？&lt;/p&gt;
&lt;p&gt;要回答以上的问题，我们必须了解Android系统的休眠原理，以及Android手机的硬件架构。&lt;/p&gt;
&lt;h3 id=&quot;Android手机的硬件架构&quot;&gt;&lt;a href=&quot;#Android手机的硬件架构&quot; class=&quot;headerlink&quot; title=&quot;Android手机的硬件架构&quot;&gt;&lt;/a&gt;Android手机的硬件架构&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;引用1&lt;/strong&gt;：以下英文部分摘自书籍《Developing Software for Symbian OS 2nd Edition: A Beginner’s Guide to Creating Symbian OS v9 Smartphone Applications in C++ 》，作者：Steve Babin。Google图书上的链接&lt;a href=&quot;https://books.google.com.hk/books?id=thd5DSWn_F4C&amp;amp;pg=PA80&amp;amp;redir_esc=y&amp;amp;hl=zh-CN#v=onepage&amp;amp;q&amp;amp;f=false&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Developing Software for Symbian OS 2nd Edition&lt;/a&gt;。注：京东和亚马逊均有售。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Two-processor smartphone model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Typically,a smartphone contains two processors:a &lt;em&gt;baseband processor&lt;/em&gt; and an &lt;em&gt;application processor&lt;/em&gt;(sometimes known as the radio and PDA processors).Figure 3.5 shows a typical high-level view of a two-processor system.&lt;/p&gt;
&lt;p&gt;The baseband processor runs on the low-level radio telephony protocols,like the GSM signaling stack mentioned before.Baseband software is time-critical and requires a real-time operating system(RTOS).The RTOS can be proprietary,or a commercial one such as Nucleus,OSE,or VRTX.The application processor runs Symbian OS and its applications.An IPC(inter-processor communication)mechanism is supplied to communicate between the two processors when needed.&lt;/p&gt;
&lt;p&gt;Why the need for two processors?The main reason is because Symbian OS(EKA1) does not provide the real-time response needed for the baseband software,thus requiring a dedicated processor running an RTOS.With EKA2,however,this is no longer a restriction,as shown in the next section.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/YVY49RN.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/4qcYhiL.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用2：&lt;/strong&gt;另外，维基百科上面的描述如下(链接为&lt;a href=&quot;https://en.wikipedia.org/wiki/Baseband_processor&quot; title=&quot;维基百科对于Baseband processor的说明&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/Baseband_processor&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;baseband processor&lt;/strong&gt; (also known as &lt;strong&gt;baseband radio processor&lt;/strong&gt;, &lt;strong&gt;BP&lt;/strong&gt;, or &lt;strong&gt;BBP&lt;/strong&gt;) is a device (a chip or part of a chip) in a network interface that manages all the radio functions (all functions that require an antenna); however, this term is generally not used in reference to Wi-Fi and Bluetooth radios.  A baseband processor typically uses its own RAM and firmware.&lt;/p&gt;
&lt;p&gt;== Overview ==&lt;/p&gt;
&lt;p&gt;Baseband processors typically run a real-time operating system (RTOS) as their firmware, such as ENEA AB|ENEA’s Operating System Embedded|OSE, Nucleus RTOS (iPhone 3G/3GS/iPad), ThreadX (iPhone 4), and Versatile Real-Time Executive|VRTX.  There are more than a few significant manufacturers of baseband processors, including Broadcom, Icera, Intel Mobile Communications (former Infineon wireless division), MediaTek, Qualcomm,  Spreadtrum, and ST-Ericsson.&lt;/p&gt;
&lt;p&gt;The rationale of separating the baseband processor from the main processor (known as the AP or Application Processor) is threefold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Radio performance&lt;/p&gt;
&lt;p&gt;  Radio control functions (signal modulation, encoding, radio frequency shifting, etc.) are highly timing-dependent, and require a real-time operating system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Legal&lt;/p&gt;
&lt;p&gt;  Some authorities (e.g. the U.S. [[Federal Communications Commission]] (FCC)) require that the entire software stack running on a device which communicates with the cellular network must be certified. Separating the BP into a different component allows reusing them without having to certify the full AP. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Radio reliability&lt;/p&gt;
&lt;p&gt;  Separating the BP into a different component ensures proper radio operation while allowing application and OS changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;引用3：&lt;/strong&gt;此外，虽然在Android开发官网上面没有搜索到BP的介绍，但是在其中一个页面，出现了这个术语。&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/app/ActivityManager.MemoryInfo.html&quot; title=&quot;Android开发官网上面对BP术语的引用&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/intl/zh-cn/reference/android/app/ActivityManager.MemoryInfo.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/5pg4KkF.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用4：&lt;/strong&gt;在链接&lt;a href=&quot;http://www.wisegeek.com/what-is-a-baseband-processor.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.wisegeek.com/what-is-a-baseband-processor.htm&lt;/a&gt;上也有一段关于智能手机BP和CPU独立开来的背景方面比较详细的阐述。&lt;/p&gt;
&lt;p&gt;Mobile phones and other devices typically require considerable processing power to control their computational and communications functions. The Central Processing Unit (CPU) of such a device allows for many functions, and often includes several software applications and drivers. Most mobile communications devices also include a Baseband Processor (BP), separate from the CPU.&lt;strong&gt; Generally, it manages the radio control functions, such as signal generation, modulation, encoding, as well as frequency shifting. It can also manage the transmission of signals.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The baseband processor is typically located on the same circuit board as the CPU, but consists of a separate radio electronics component. It can therefore have a different programming interface and control software. The hardware function is often independent of the operations of other phone components as well. A benefit to this is usually that changes to software applications and operating systems do not affect the operation of the BP. Software bugs can affect other capabilities, but the baseband processor will usually function without a problem in such a case.&lt;/p&gt;
&lt;p&gt;An applications processor is often used to manage all of the software programs on a device. A separate baseband processor can also enable phone designers to create applications and user interfaces without having to worry about changes to the BP or the way radio signals are processed. Wireless communication capabilities have continued to increase through the early 21st century. Some baseband radio processor models can handle many channels at once, usually while processing all receive and transmit demands.&lt;/p&gt;
&lt;p&gt;This type of device sometimes includes multiple processing components. One kind has four, so it can combine parameter estimation, signal searching, transmission, and receiving functions and other capabilities. The BP can also search for mobile signals and track them, as well as select antennas automatically. In many cases, a baseband processor is contained in a common integrated circuit package, such as a ball grid array. Low power models are often available as well.&lt;/p&gt;
&lt;p&gt;As of 2011, baseband processor capabilities are often supportive of the fourth generation protocols for wireless communication. The processor is often part of the device’s modem, and can include other features such as Flash memory. A low power memory baseband processor often has connections to common interfaces, such as Universal Serial Bus (USB) found in most computers and mobile devices. &lt;strong&gt;The design of separate processors in a phone is not only efficient, but able to prevent malfunctions due to software bugs, which could cause widespread phone problems as well as network issues.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的信息可知，我们可以认为Android手机有两个处理器(即使从物理形态上是一个CPU，但BP和CPU即AP在逻辑上应该是独立的)，一个叫Application Processor(AP)，一个叫Baseband Processor(BP)。AP是ARM(或x86等)架构的处理器，用于运行Android系统和应用程序；BP用于运行实时操作系统(RTOS)，通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP，LCD，WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。&lt;/p&gt;
&lt;h3 id=&quot;Android的休眠-睡眠-机制和唤醒机制&quot;&gt;&lt;a href=&quot;#Android的休眠-睡眠-机制和唤醒机制&quot; class=&quot;headerlink&quot; title=&quot;Android的休眠(睡眠)机制和唤醒机制&quot;&gt;&lt;/a&gt;Android的休眠(睡眠)机制和唤醒机制&lt;/h3&gt;&lt;h4 id=&quot;Android的休眠-睡眠-机制&quot;&gt;&lt;a href=&quot;#Android的休眠-睡眠-机制&quot; class=&quot;headerlink&quot; title=&quot;Android的休眠(睡眠)机制&quot;&gt;&lt;/a&gt;Android的休眠(睡眠)机制&lt;/h4&gt;&lt;p&gt;要准确定义Android设备的电源状态，其实比较难，因为目前没有找到官方对此的规范定义。而网上的资料则众说纷纭，莫衷一是。不过综合各家意见来看，本人比较倾向于如下的状态划分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sleep stages/levels&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;awake&lt;/li&gt;
&lt;li&gt;dim&lt;/li&gt;
&lt;li&gt;screen off&lt;/li&gt;
&lt;li&gt;CPU off (true “sleep” or “deep sleep”)&lt;/li&gt;
&lt;li&gt;power off&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中2、3、4属于广义的sleep范畴。当然，如果将键盘等设备也纳入考虑的话，上面的划分还需要更细一些，这里未作考虑。&lt;/p&gt;
&lt;p&gt;When an Android device is left idle, it will first dim, then turn off the screen, and ultimately turn off the CPU. This prevents the device’s battery from quickly getting drained(参见&lt;a href=&quot;http://developer.android.com/intl/zh-cn/training/scheduling/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/intl/zh-cn/training/scheduling/index.html&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;Android的WakeLock机制&quot;&gt;&lt;a href=&quot;#Android的WakeLock机制&quot; class=&quot;headerlink&quot; title=&quot;Android的WakeLock机制&quot;&gt;&lt;/a&gt;Android的WakeLock机制&lt;/h4&gt;&lt;p&gt;Android系统是通过WakeLock来实现唤醒CPU、屏幕、键盘及其他相关硬件组件的。以下英文内容摘录自&lt;a href=&quot;https://software.intel.com/en-us/android/articles/wakelocks-for-android&quot; title=&quot;wakelocks-for-android&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wakelocks-for-android&lt;/a&gt;和&lt;a href=&quot;https://software.intel.com/en-us/android/articles/wakelocks-detect-no-sleep-issues-in-android-applications&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wakelocks: Detect No-Sleep Issues in Android* Applications&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;Wakelock：&quot;&gt;&lt;a href=&quot;#Wakelock：&quot; class=&quot;headerlink&quot; title=&quot;Wakelock：&quot;&gt;&lt;/a&gt;&lt;strong&gt;Wakelock：&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;A wakelock is a software mechanism to control the power state of the host device&lt;/strong&gt;. The OS exports explicit power management handles and APIs to specify when a particular component needs to stay on, or awake, until it is explicitly released from duty.&lt;/p&gt;
&lt;p&gt;The wakelock mechanism is implemented in two levels: user and kernel. The figure shows the internal design of Android wakelock implementation. The user wakelock can be utilized by either high-level OS services or applications and is provided by the power management service. It allows an application to control the power state of the device. A kernel wakelock is held by the OS kernel or a driver. A user wakelock is mapped to a kernel wakelock. Any active kernel-level wakelock prevents the system from being suspended to ACPI S3 (suspended to RAM) state, which is the highest power saving state for mobile devices.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/kOGdghH.jpg&quot; alt=&quot;Android WakeLock原理&quot;&gt;&lt;/p&gt;
&lt;h6 id=&quot;Android-User-Wakelocks&quot;&gt;&lt;a href=&quot;#Android-User-Wakelocks&quot; class=&quot;headerlink&quot; title=&quot;Android User Wakelocks&quot;&gt;&lt;/a&gt;Android User Wakelocks&lt;/h6&gt;&lt;p&gt;Android设备的电源状态可以通过android.os.PowerManager类来控制(参见&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/os/PowerManager.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android开发官网的API介绍&lt;/a&gt;)。这是比较细粒度控制电源状态的方式，如果是更便捷地控制，可以参见&lt;a href=&quot;http://developer.android.com/intl/zh-cn/training/scheduling/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Managing Device Awake State&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, &amp;quot;My Tag&amp;quot;);
wl.acquire();
  ..screen will stay on during this section..
wl.release();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Android设备的休眠分为以下几个等级(最高等级的休眠是屏幕、键盘、CPU全部休眠)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag Value&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Screen&lt;/th&gt;
&lt;th&gt;Keyboard&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;睡眠状态&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PARTIAL_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;On*&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCREEN_DIM_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;Dim&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCREEN_BRIGHT_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;Bright&lt;/td&gt;
&lt;td&gt;Off&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FULL_WAKE_LOCK&lt;/td&gt;
&lt;td&gt;On&lt;/td&gt;
&lt;td&gt;Bright&lt;/td&gt;
&lt;td&gt;Bright&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that since API level 17, FULL_WAKE_LOCK has been deprecated. Applications should use FLAG_KEEP_SCREEN_ON.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面表格中的*表示：如果你持有一个partial wake lock， 无论任何的显示超时或屏幕状态甚至即使用户按下电源键，CPU都将会保持运行。在其他的wake locks机制下，CPU将会保持运行，但是用户可以通过按下电源键使得设备进入睡眠。 &lt;/p&gt;
&lt;p&gt;此外， 我们可以添加两个额外的flag，flag仅仅会影响屏幕的行为。不过这两个flag与PARTIAL_WAKE_LOCK组合使用时将无任何效果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag Value&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ACQUIRE_CAUSES_WAKEUP&lt;/td&gt;
&lt;td&gt;Normal wake locks don’t actually turn on the illumination. Instead, they cause the illumination to remain on once it turns on (e.g. from user activity). This flag will force the screen and/or keyboard to turn on immediately, when the WakeLock is acquired. &lt;strong&gt;A typical use would be for notifications which are important for the user to see immediately&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ON_AFTER_RELEASE&lt;/td&gt;
&lt;td&gt;If this flag is set, the user activity timer will be reset when the WakeLock is released, causing the illumination to remain on a bit longer. This can be used to reduce flicker if you are cycling between wake lock conditions.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;任何使用WakeLock的应用程序必须在清单文件manifest.xml中&lt;uses-permission&gt;标签下添加android.permission.WAKE_LOCK权限。&lt;/uses-permission&gt;&lt;/p&gt;
&lt;h6 id=&quot;Android-Kernel-Wakelocks&quot;&gt;&lt;a href=&quot;#Android-Kernel-Wakelocks&quot; class=&quot;headerlink&quot; title=&quot;Android Kernel Wakelocks&quot;&gt;&lt;/a&gt;Android Kernel Wakelocks&lt;/h6&gt;&lt;p&gt;Kernel wakelocks are low-level wakelocks held by the kernel. They can be acquired/ released internally from the kernel. As such, application developers have less direct control on them, but an application’s behaviour can indirectly trigger these wakelocks and increase battery consumption inadvertently.&lt;/p&gt;
&lt;p&gt;Here are examples of &lt;strong&gt;kernel wakelocks&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Wlan_rx&lt;/strong&gt;: Held by the kernel when data is sent or received over Wi-Fi*.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PowerManagerService&lt;/strong&gt;: Is the container for all partial wakelocks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sync&lt;/strong&gt;: Held while the sync process is running.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Alarm_rtc&lt;/strong&gt;: Handles the alarm (when an application or process checks periodically on something).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Main&lt;/strong&gt;: Keeps the kernel awake. This is the last one to be released when the system goes to suspend mode.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以注意到，Wlan_rx内核wakelock，因此可以确认WIFI连接下数据接收可以唤醒CPU。&lt;/p&gt;
&lt;h3 id=&quot;Android的网络数据怎样唤醒CPU？&quot;&gt;&lt;a href=&quot;#Android的网络数据怎样唤醒CPU？&quot; class=&quot;headerlink&quot; title=&quot;Android的网络数据怎样唤醒CPU？&quot;&gt;&lt;/a&gt;Android的网络数据怎样唤醒CPU？&lt;/h3&gt;&lt;p&gt;如上面所述，Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。&lt;/p&gt;
&lt;p&gt;完全没必要担心AP休眠会导致收不到消息推送。通讯协议栈运行于BP，一旦收到数据包。BP会将AP唤醒。唤醒的时间足够AP执行代码完成对收到的数据包的处理过程。其它的如Connectivity事件触发时AP同样会被唤醒。那么唯一的问题就是程序如何执行向服务器发送心跳包的逻辑。你显然不能靠AP来做心跳计时。Android提供的Alarm Manager就是来解决这个问题的。RTC (Real Time Clock) 是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒CPU。那么Wake Lock API有啥用呢？ 比如心跳包从请求到应答，比如断线重连重新登陆这些关键逻辑的执行过程，就需要Wake Lock来保护。而一旦一个关键逻辑执行成功，就应该立即释放掉Wake Lock了。两次心跳请求间隔5到10分钟，基本不会怎么耗电。除非网络不稳定，频繁断线重连，那种情况办法不多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动网络下， 网络数据通过BP来完成，BP接收到网络数据，将唤醒CPU，然后CPU执行后续逻辑。&lt;/li&gt;
&lt;li&gt;Wifi连接下，目前了解到的情况是，WIFI可以休眠，即设备进入sleep状态时，WIFI也可以进入sleep，一旦WIFI进入sleep，则WIFI连接断开，无法接收到服务端下发的数据了。而且一旦WIFI断开，那么手机将会切换到蜂窝移动网络链接，此时也会造成IP地址更换，进而导致长连接断开。另外，据不可考证的信息，WIFI连接下数据传输消耗的电量较蜂窝移动网络少。当然有说法是WIFI待机状态的电量消耗反过来比蜂窝移动网络standby时消耗电量多。所以，一般是建议让WIFI一直不会进入休眠状态(Never)。而WIFI连接收到网络数据时，通过&lt;strong&gt;Wlan_rx内核WakeLock&lt;/strong&gt;唤醒CPU，继而执行后续的APP逻辑(不过该部分的官方资料暂未找到)。那么，怎样设置WIFI的休眠策略呢，Android官方有相关的配置供参考&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/provider/Settings.System.html#WIFI_SLEEP_POLICY&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WIFI_SLEEP_POLICY&lt;/a&gt;，API Level17以后则是&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/provider/Settings.Global.html#WIFI_SLEEP_POLICY&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/intl/zh-cn/reference/android/provider/Settings.Global.html#WIFI_SLEEP_POLICY&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  那么我们在开启应用时，首先取出这个值，代码：
   private void setWifiDormancy()
   {
      int value = Settings.System.getInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY,  Settings.System.WIFI_SLEEP_POLICY_DEFAULT);
      final SharedPreferences prefs = getSharedPreferences(getString(R.string.wifi_sleep_policy), Context.MODE_PRIVATE);
      Editor editor = prefs.edit();
      editor.putInt(getString(R.string.wifi_sleep_policy_default), value); 
      editor.commit();
      if(Settings.System.WIFI_SLEEP_POLICY_NEVER != value)
      {
     Settings.System.putInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY, WIFI_SLEEP_POLICY_NEVER);
      }
   }

  在应用退出我们需将这个设置的值还原：
   private void restoreWifiDormancy()
   {
      final SharedPreferences prefs = getSharedPreferences(getString(R.string.wifi_sleep_policy), Context.MODE_PRIVATE);
      int defaultPolicy = prefs.getInt(getString(R.string.wifi_sleep_policy_default), Settings.System.WIFI_SLEEP_POLICY_DEFAULT);
      Settings.System.putInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY, defaultPolicy);
   }

这样初始设置，退出还原我们可以让应用一直处于wifi模式下（不过前提是有wifi网络哦）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;推送中最重要的部分就是让手机尽量休眠，只有在服务器需要它处理数据时才唤醒它，这正好符合我们的要求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      梳理当前主流的推送技术，对里面涉及到的概念和技术进行全面的阐述
    
    </summary>
    
      <category term="Android" scheme="http://cstsinghua.github.io/categories/Android/"/>
    
    
      <category term="Push" scheme="http://cstsinghua.github.io/tags/Push/"/>
    
      <category term="推送" scheme="http://cstsinghua.github.io/tags/%E6%8E%A8%E9%80%81/"/>
    
      <category term="长连接" scheme="http://cstsinghua.github.io/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="进程保活" scheme="http://cstsinghua.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
    
      <category term="定时器" scheme="http://cstsinghua.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
      <category term="Timer" scheme="http://cstsinghua.github.io/tags/Timer/"/>
    
  </entry>
  
</feed>
