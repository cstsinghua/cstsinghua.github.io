[{"title":"RxJava&RxAndroid学习之路--理论篇","date":"2017-03-10T08:30:28.000Z","path":"2017/03/10/RxJava&RxAndroid学习之路——理论篇/","text":"RxJava&amp;RxAndroid学习之路–理论篇 最近一段时间以来，在面试的Android开发人员简历中，基本都会提及熟悉RxJava或RxAndroid，貌似不会RxJava或RxAndroid就落伍，就只是初级的Android开发人员。于是，带着好奇心和疑问准备一探究竟，于是乎接下来就是一通google balabala…但是，网上关于RxJava或RxAndroid的学习资料非常多，各种文章和blog让人眼花缭乱，不知道如何入手，可以说，大部分文章要么艰涩难懂，要么过于浅显，让人看了不明觉厉。是的，RxJava或RxAndroid的学习相对来说有一定的门槛，但是一旦入门，那么相信你就会爱上它。本文根据个人学习RxJava或RxAndroid的历程，总结出相关经验，以便他人学习之时少走弯路。 引言学习一个新知识的时候，一般地，我们都会带着如下几个问题： 为什么要学习(Why to learn)？ 要学的新知识是什么(What is it)？ 怎么学习这个知识点(How to learn)？ 学习之后怎么用(Where to use)？ 第一个问题，这里就不用回答了，既然你打开了这篇文章，说明你肯定有着充分的理由。本文重点介绍一下2和3，也即本人学习RxJava或RxAndroid的经验总结，希望能对你有所帮助。 ReactiveX是什么？要了解RxJava&amp;RxAndroid是什么，首先得了解什么是ReactiveX？ReactiveX是Reactive Extensions的缩写，一般简写为Rx，RxJava&amp;RxAndroid是Rx在JVM和Android平台上的具体实现，除了Java语言，ReactiveX几乎已经被其他主流编程语言所支持。其官方网址为http://reactivex.io，其实这个网站的手册和介绍已经非常详细，但是，对于初学者而言，还是有一定难度。不过，引用该网站对Rx的介绍作为一个概念性的认识，还是有必要的。 正如reactivex.io所述： ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming 也就是说ReactiveX结合了观察者模式、迭代器模式和函数式编程的最佳思想。 因此，首先就需要熟悉观察者模式(Observer pattern)，相信熟悉java和Android的朋友应该对此比较熟悉了，其在GUI编程中经常使用。要了解观察者，建议阅读维基百科上面的阐述：https://en.wikipedia.org/wiki/Observer_pattern；或者阅读”The Gang of Four”(所谓”四人帮”)所著的著名著作”Design Patterns:Elements of Reusable Object-Oriented Software”一书；亦可参考Github开源库https://github.com/iluwatar/java-design-patterns。 同理，也需要了解迭代器模式(Iterator pattern)，其在Java集合的遍历实现中经常使用。建议阅读维基百科上面的阐述：https://en.wikipedia.org/wiki/Iterator_pattern；或者阅读”The Gang of Four”(所谓”四人帮”)所著的著名著作”Design Patterns:Elements of Reusable Object-Oriented Software”一书；亦可参考Github开源库https://github.com/iluwatar/java-design-patterns。 而关于函数式编程(functional programming,一种编程范式–programming paradigm)，这个话题很大，也很深，水平有限，这里不做阐述，想了解的读者可以在维基百科https://en.wikipedia.org/wiki/Functional_programming查询或者通过其他资料学习。其实在我看来，在这个特定场景下，仅仅理解成用流式(链式)方式编写代码即可。 有背景有了大致的了解之后，笔者认为，那么接下来应该需要先弄清里面的术语，Rx里面术语比较多，要厘清每个术语对应的角色，才能真正入门(笔者在刚接触Rx的时候，被里面各种术语和角色弄得头晕)。真正弄透了各个角色，也就真正了解了Rx。 Rx里面的术语和角色Rx里面包括很多术语，每个术语对应不同的角色，而这些角色组合在一起便是Rx的体系，也是我们在实际使用Rx进行编码的时候操作的对象。 Observable: 可观察对象，从对比角度看，相当于观察者模式中是被观察的对象(即观察者模式中的Subject，注意，请区分Rx里面的Subject，见下文)，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者。Observable的强大之处，在Rx中定义为更强大的Iterable，即可以emit(发射)item和item序列(流)，特别是数据流的概念，因为几乎所有的对象都可以理解或者转换成数据流，详细内容可参见http://reactivex.io/documentation/observable.html； items: 直译为项目，条目，在Rx里是指Observable发射的数据项； emit: 直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法； Observer: 观察者对象，可以对比理解成观察者模式里面的Observer，监听(也叫订阅，Subscribe)Observable发射的数据(流)并做出响应，Subscriber是它的一个特殊实现。Observable和Observer之间通过Subscribe方法联系在一起； Operators: 操作或运算，可以对Observable进行转换、过滤等操作，也可以生成Observable，大多数Operator对Observable操作返回的仍然是Observable，这样便可以形成链式操作(Chaining Operators)，类似于构建者模式(Builder Pattern)。Rx真正强大之处，最关键之一就是Operators提供的能力。详细内容可参见http://reactivex.io/documentation/operators.html Single: Observable的一个变种(variant)，区别在于，它仅仅发出一个值(Value)或错误通知(error notification)。详细可参见http://reactivex.io/documentation/single.html Subject: 在Rx的某些语言实现中出现，既是observer又是observable，详细信息可参见http://reactivex.io/documentation/subject.html Scheduler: 调度者，Rx引入多线程的机制。默认情况下，Observable及Operators都是在同一个线程完成所有工作，Observable的SubscribeOn方法(其实也是一个Operator)改变了默认的行为，通过指定一个不同的Scheduler，Observable则在该Scheduler上执行操作。而ObserveOn方法(其实也是一个Operator)则指定一个不同的Scheduler，Observable用来发送通知给Observer。详细信息请参见http://reactivex.io/documentation/scheduler.html RxJava&amp;RxAndroid入门对Rx有了初步的认识，特别是了解了里面的常用术语和角色，那么作为Java或Android开发者，要入门，应该怎么学习呢？首先，RxJava在Github上的仓库地址为https://github.com/ReactiveX/RxJava，RxAndroid的则对应https://github.com/ReactiveX/RxAndroid。在仓库的Wiki页面，有相关的介绍。不过不建议直接就读取里面内容，可以在有一定了解的基础上进行系统学习。 这里推荐一篇blog，http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/,里面分成4个部分，分别从基础、Operator、Rx的益处、RxAndroid四个方面进行了阐述，浅显易懂。 特别提醒：学习RxJava之时，可以用示意图的方式将流程的marble diagram图画出来，理解了marble diagram，也就很清晰地知道了整个机制 Eg. 除此之外，以下两篇文章或链接也值得一读：https://gist.github.com/staltz/868e7e9bc2a7b8c1f754 http://www.introtorx.com/ 进一步学习通过上面几篇文章的介绍，就可以对RxJava有一个基本的了解，也可以简单运用了。要想全面深入学习RxJava，那么建议仔细阅读reactivex.io的全部内容，以及RxJava&amp;RxAndroid在Github上仓库中的Wiki内容。这里面又包含了其他推荐文章的链接。同时也可以研究RxJava&amp;RxAndroid的源码。 特别要提及的是，对于Android开发者而言，还需要了解Retrofit等支持Rx的开源库，结合起来使用，就更能彰显威力。那就是当下比较流行的Retrofit+RxAndroid开发。","tags":[{"name":"入门","slug":"入门","permalink":"http://cstsinghua.github.io/tags/入门/"},{"name":"RxJava","slug":"RxJava","permalink":"http://cstsinghua.github.io/tags/RxJava/"},{"name":"RxAndroid","slug":"RxAndroid","permalink":"http://cstsinghua.github.io/tags/RxAndroid/"},{"name":"学习之路","slug":"学习之路","permalink":"http://cstsinghua.github.io/tags/学习之路/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://cstsinghua.github.io/tags/观察者模式/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"http://cstsinghua.github.io/tags/迭代器模式/"},{"name":"Observer pattern","slug":"Observer-pattern","permalink":"http://cstsinghua.github.io/tags/Observer-pattern/"},{"name":"Iterator pattern","slug":"Iterator-pattern","permalink":"http://cstsinghua.github.io/tags/Iterator-pattern/"},{"name":"functional programming","slug":"functional-programming","permalink":"http://cstsinghua.github.io/tags/functional-programming/"},{"name":"ReactiveX","slug":"ReactiveX","permalink":"http://cstsinghua.github.io/tags/ReactiveX/"}]},{"title":"Android APK逆向解析","date":"2017-02-21T06:34:42.000Z","path":"2017/02/21/Android APK逆向解析/","text":"Android APK逆向解析 众所周知，Android系统是开源的，运行其上的Android应用APK即Android Package也是可以通过各种工具进行反编译或者逆向工程，从而可以对其他APP进行研究或者借鉴学习，亦或从APK中获取相关信息(比如清单文件AndroidManifest.xml里面的package、versionName和versionCode等等)。 Android的构建流程要真正进行Android反编译和逆向，首先需要对Android的编译和构建过程有一个大致的了解。因为反编译和编译的过程是相逆的。本文从Android开发者官网摘取了关于Android构建的描述，详细信息请参见Android构建流程。 构建流程涉及许多将您的项目转换成 Android 应用软件包 (APK) 的工具和流程。构建流程非常灵活，因此了解它的一些底层工作原理会很有帮助。典型Android应用模块的构建流程如下图所示： build-process 如上图所示，典型 Android 应用模块的构建流程通常依循下列步骤： 编译器(这里涉及到JDK、aapt等工具)将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源。 APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。 APK 打包器使用调试或发布密钥库签署您的 APK： a.如果您构建的是调试版本的应用（即专用于测试和分析的应用），打包器会使用调试密钥库签署您的应用。Android Studio 自动使用调试密钥库配置新项目。 b.如果您构建的是打算向外发布的发布版本应用，打包器会使用发布密钥库签署您的应用。要创建发布密钥库，请阅读在 Android Studio 中签署您的应用。 在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。 Android APK逆向解析首先，要对APK文件进行分析，需要了解APK文件的结构。其实APK文件就是一个zip文件，所以采用解压缩软件可以查看里面的子项。典型的APK文件的解压缩视图如下： Android classes.dex：classes.dex是java源码编译后生成的java字节码文件(非传统JVM解释执行的class字节码)。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。Android模拟器中提供了一个dex文件的反编译工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，找到要查看的dex文件，执行dexdump xxx.dex（或者从压缩文件取出dex文件，直接在PC上面找到dexdump.exe的路径，然后执行命令）。另外Dedexer是一个反编译dex文件的开源工具，需要自己编译源代码。而当前，还有比如dex2jar(https://github.com/pxb1988/dex2jar)甚至封装好的GUI的工具(比如安卓逆向助手等等，可网上搜索下载)可以反编译dex文件为jar文件，再利用jd-gui(http://jd.benow.ca/)工具打开jar文件，就可以阅读java源代码了。 resources.arsc：编译Android资源文件后的生成的二进制文件，resources.arsc有固定的格式，包括了资源索引和字符串资源池等，详细可参见resources.arsc解析 AndroidManifest.xml：清单文件，该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过编译的，即是二进制格式，如果直接用编辑器打开，显示会是乱码。因此需要先进行反编译处理，得到原始的AndroidManifest.xml文件。可以通过AXMLPrinter2工具解开，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml assets：assets目录可以存放一些配置文件（比如webview本地资源、图片资源、音视频等等），不会经过编译，和原始工程里面的文件是一致的，这些文件的内容在程序运行过程中可以通过相关的API（android.content.res.AssetManager）获得。 lib：lib目录下的子目录存放的是一些与手机CPU架构对应的C/C++代码编译生成的so文件，一般用于JNI开发。 META-INF：META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。 res：res目录存放经过编译后的资源文件，虽与原始工程目录下的res目录层次结构类似，但是实际上是经过编译处理的，只有图片资源和原始工程是一致，其他类型的资源则是编译处理过，无法直接查看。 从上面对APK内部文件的分析来看，要想反编译或者逆向工程获取信息，其实主要涉及两个方面，一是对classes.dex反编译，转换成jar或者smali等，可以利用dex2jar(https://github.com/pxb1988/dex2jar)等工具生成jar，二是结合resources.arsc和res对资源进行反编译，从而得到原始的资源文件。本文罗列平时工作和搜集到的一些常见的Android APK反编译和逆向分析工具，对工具的使用不做过多阐述，关于各个工具的详细使用和技巧，可以参见下文中提及的工具的官方链接。 全能型选手-apktoolapktool可以对Android APK直接进行反编译(也可以在反编译得到的目录基础上进行回编，生成apk)。其是Android领域反编译最常用的开源工具，虽然有商业级的反编译工具Jeb(https://www.pnfsoftware.com/)，但鉴于收费且不开源，更多的程序开发者则选择apktool，其官方链接:https://ibotpeaches.github.io/Apktool/。Note：apktool反编译之后，得到是目录和文件，因此适用于需要对原始文件和代码进行分析的场景。dex通过apktool依赖的backsmali工具反编译之后得到的是smali文件，关于smali/backsmali可以参见https://github.com/JesusFreke/smali jadx可以将dex文件和apk文件反编译成可阅读的格式，主要涉及java代码和AndroidManifest.xml查看。jadx的github链接地址为https://github.com/skylot/jadx。适用场景：可以用于快速查看APK内的java代码和清单文件内容。 ClassySharkgoogle官方为Android开发者推出的独立的二进制文件检查工具，因此其权威性和强大毋庸赘言，且得到较好的维护和更新。其github地址为：[https://github.com/google/android-classyshark] ，其支持多种文件格式的解析，包括：库文件 (.dex, .aar, .so), 可执行文件 (.apk, .jar, .class) 和所有的Android二进制XML格式文件如AndroidManifest, resources, layouts等等。另外，很重要的一点，其能分析得出dex文件里面包含的方法数，这对于Android一个著名的问题(方法数超限65535，见https://developer.android.com/studio/build/multidex.html)的解决很有帮助。 AXMLParserAXMLParser仅仅是用于解析APK里面的二进制AndroidManifest.xml，从而得到与原始工程里的AndroidManifest.xml内容一致的可读xml。较轻量级，适用于只想查看和AndroidManifest.xml里面包含的信息，比如包名package，versionCode和versionName，启动Activity等。其原始链接和下载地址为：https://code.google.com/archive/p/xml-apk-parser/ Note:该工具很久没有更新了 新版Android studioAndroid studio 2.x版本提供了一个新功能，可以分析APK文件，得到dex的方法数，查看清单文件等。如下图所示：","tags":[{"name":"Android","slug":"Android","permalink":"http://cstsinghua.github.io/tags/Android/"},{"name":"apktool","slug":"apktool","permalink":"http://cstsinghua.github.io/tags/apktool/"},{"name":"逆向","slug":"逆向","permalink":"http://cstsinghua.github.io/tags/逆向/"},{"name":"AndroidManifest.xml","slug":"AndroidManifest-xml","permalink":"http://cstsinghua.github.io/tags/AndroidManifest-xml/"},{"name":"ClassyShark","slug":"ClassyShark","permalink":"http://cstsinghua.github.io/tags/ClassyShark/"},{"name":"jadx","slug":"jadx","permalink":"http://cstsinghua.github.io/tags/jadx/"},{"name":"AXMLPrinter","slug":"AXMLPrinter","permalink":"http://cstsinghua.github.io/tags/AXMLPrinter/"},{"name":"reverse engineering","slug":"reverse-engineering","permalink":"http://cstsinghua.github.io/tags/reverse-engineering/"},{"name":"build","slug":"build","permalink":"http://cstsinghua.github.io/tags/build/"}]},{"title":"Android 操作系统的内存回收机制","date":"2017-02-09T01:58:42.000Z","path":"2017/02/09/Android 操作系统的内存回收机制/","text":"Android 操作系统的内存回收机制 Android系统是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使应用程序关闭但不退出，并由操作系统进行进程的回收管理。本文在Application Framework与Linux内核两个层次上，以进程为粒度，对Android 操作系统的进程资源回收机制进行了剖析。读者可以从本文获得对Android应用程序的生存周期的进一步理解，从而更加合理、高效地构建应用程序。Note：本文转载自https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/ ，适当添加批注和修正一些有争议的地方 Android APP 的运行环境Android 是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使得其进程调度与资源管理与其他平台的Linux有明显的区别。主要包含下面几个层次： Application FrameworkApplication Framework 将整个操作系统分隔成两个部分。对应用开发者而言，所有APP都是运行在Application Framework之上，而并不需要关心系统底层的情况。Application Framework层为应用开发者提供了丰富的应用编程接口，如Activity Manager，Content Provider，Notification Manager，以及各种窗口Widget资源等。在Application Framework层，Activity是一个APP最基本的组成部分。一般每个 Activity对应于屏幕上的一个视图（或者说一屏），一个APP可以有一个或者多个Activity。应用程序被打包成.apk格式的文件，由Dalvik VM解释执行。 Dalvik VM(或ART)Dalvik虚拟机采用寄存器架构，而不是JVM的栈结构。Java程序编译后的.class文件并不能在Dalvik中解释执行。因此Google提供了一个 dx 工具，用于将.class文件转换成Dalivk能够识别的.dex格式。具体Dalvik VM的细节不是本文重点，以下不再讨论。 Linux kernel由上所述，所有的APP都是由Java代码编写并在Dalvik VM中得到解释执行。在Android操作系统中，每个Dalvik VM的每个Instance都对应于 Linux内核中的一个进程。可以使用adb shell工具查看系统中的当前进程。如下图所示，Android2.3.3启动后内核中的进程列表。图 1. Android 2.3 中的进程列表（部分） 图 1 中，UID 标识为 app_xx 的每一项都是一个 app 所占用的进程，可见 Android 设计使得每个应用程序由一个独立的 Dalvik 实例解释执行，而每个 Linux 内核进程加载一个 Dalvik 实例，通过这种方式提供 app 的运行环境。如此，每个 APP 的资源被完全屏蔽，互不干扰。虽然同时引入了进程间通信的困难，但也带来了更强的安全性。 Android 内存回收原则下面将从 Application Framework 和 Linux kernel 两个层次分析 Android 操作系统的资源管理机制。Android 之所以采用特殊的资源管理机制，原因在于其设计之初就是面向移动终端，所有可用的内存仅限于系统 RAM，必须针对这种限制设计相应的优化方案。当 Android 应用程序退出时，并不清理其所占用的内存，Linux 内核进程也相应的继续存在，所谓“退出但不关闭”。从而使得用户调用程序时能够在第一时间得到响应。当系统内存不足时，系统将激活内存回收过程。为了不因内存回收影响用户体验（如杀死当前的活动进程），Android 基于进程中运行的组件及其状态规定了默认的五个回收优先级： IMPORTANCE_FOREGROUND: IMPORTANCE_VISIBLE: IMPORTANCE_SERVICE: IMPORTANCE_BACKGROUND: IMPORTANCE_EMPTY: 这几种优先级的回收顺序是 Empty process、Background process、Service process、Visible process、Foreground process。关于划分原则参见 https://developer.android.com/guide/components/processes-and-threads.html 文件中。 ActivityManagerService集中管理所有进程的内存资源分配。所有进程需要申请或释放内存之前必须调用ActivityManagerService对象，获得其“许可”之后才能进行下一步操作，或者ActivityManagerService将直接“代劳”。类ActivityManagerService中涉及到内存回收的几个重要的成员方法如下：trimApplications()，updateOomAdjLocked()，activityIdleInternal()。这几个成员方法主要负责 Android 默认的内存回收机制，若Linux内核中的内存回收机制没有被禁用，则跳过默认回收（这里其实应该不准确，可以参考updateOomAdjLocked源码进行比对）。 默认回收过程Android 操作系统中的内存回收可分为两个层次，即默认内存回收与内核级内存回收，本章重点对默认内存回收机制进行研究，Linux 内核层次的内存回收机制将在下一张介绍。 本章所有代码可参见ActivityManagerService.java。 回收动作入口：activityIdleInternal()Android系统中内存回收的触发点大致可分为三种情况。第一，用户程序调用StartActivity(), 使当前活动的Activity被覆盖；第二，用户按 back 键，退出当前应用程序；第三，启动一个新的应用程序。这些能够触发内存回收的事件最终调用的函数接口就是activityIdleInternal()。当ActivityManagerService接收到异步消息IDLE_TIMEOUT_MSG或者IDLE_NOW_MSG时，activityIdleInternal()将会被调用。代码如下：清单 1. IDLE_NOW_MSG 的处理方式12345case IDLE_NOW_MSG:&#123; IBinder token = (Ibinder)msg.obj; activityIdle(token, null); &#125; break; 清单 2. IDLE_TIMEOUT_MSG 的处理方式12345678910111213case IDLE_TIMEOUT_MSG: &#123; if (mDidDexOpt) &#123; mDidDexOpt = false; Message nmsg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG); nmsg.obj = msg.obj; mHandler.sendMessageDelayed(nmsg, IDLE_TIMEOUT); return; &#125; IBinder token = (IBinder)msg.obj; Slog.w(TAG, &quot;Activity idle timeout for &quot; + token); activityIdleInternal(token, true, null); &#125; break; IDLE_NOW_MSG由Activity的切换以及Activiy焦点的改变等事件引发，IDLE_TIMEOUT_MSG在Activity启动超时的情况下引发，一般这个超时时间设为10s，如果10s之内一个Activity依然没有成功启动，那么将发送异步消息IDLE_TIMEOUT_MSG进行资源回收。activityIdleInternal()的主要任务是改变系统中Activity的状态信息，并将其添加到不同状态列表中。其主要工作如下： 首先，调用scheduleAppGcsLocked()方法通知所有进行中的任务进行垃圾回收。scheduleAppGcsLocked()将进行调度JVM的garbage collect，回收一部分内存空间，这里仅仅是通知每个进程自行进程垃圾检查并调度回收时间，而非同步回收。然后，取出mStoppingActivities 和mFinishigActivities列表中的所有内容，暂存在临时变量中。这两个列表分别存储了当前状态为stop和finishi的activity 对象。对于 stop 列表，如果其中的activity的finish状态为true，判断是不是要立即停止，如果要立即停止则调用destroyActivityLocked()通知目标进程调用onDestroy()方法，否则，先调用resumeTopActivity()运行下一个Activity。如果finish状态为false，则调用 stopActivityLocked()通知客户进程停止该Activity，这种情况一般发生在调用startActivity()后。对于finish列表，直接调用 destroyActivityLocked()通知客户进程销毁目标 Activity。 这里的destroyActivityLocked等函数并没有真正意义上改变内存的使用，只是将其状态改变为“允许回收”，真正的回收在下面即将调用的 trimApplications()函数中。 回收过程函数 trimApplications()trimApplications() 函数的结构如下 :清单 3. trimApplications 函数123456789101112131415private final void trimApplications() &#123; synchronized (this) &#123; // First remove any unused application processes whose package // has been removed. for (i=mRemovedProcesses.size()-1; i&gt;=0; i--) &#123; (1)//kill process; &#125; if (!updateOomAdjLocked()) &#123; (2)//do something default &#125; // Finally, if there are too many activities now running, try to // finish as many as we can to get back down to the limit. (3)do something &#125; &#125; 清单3中的三个标序号的位置分别负责如下工作： 当程序执行到trimApplications()之后，首先检查mRemovedProcesses列表中的进程。mRemovedProcesses列表中主要包含了crash的进程、5 秒内没有响应并被用户选在强制关闭的进程、以及应用开发这调用killBackgroundProcess想要杀死的进程。调用Process.killProcess 将所有此类进程全部杀死。 调用updateOomAdjLocked()函数，若成功返回，说明Linux内核支持setOomAdj()接口，updateOomAdjLocked将修改adj(adjustments)的值并通知 linux内核，内核根据adj值以及内存使用情况动态管理进程资源（lowmemorykiller和oom_killer）。若updateOomAdjLocked()返回为假，则表示当前系统不支持setOomAdj()接口，将在本地进行默认的资源回收。 最后，如果当前依然运行了过多的Activity，对多余的Activity进行回收。trimApplications()的大多数的代码都在处理Oom_killer不存在情况下的默认资源回收，下面对其默认回收过程（即代码清单3中标记(2)的位置）进行进一步分析。其回收过程可大致描述如下: 步骤一，获取当前所有运行的进程mLruProcesses，mLruProcesses中的排序规则是按最近使用时间。对mLruProcesses中不能被关闭的进程进行计数，这些不能被关闭的进程包括运行service的进程，运行broadcast receiver的进程等，见如下代码。清单 4. 计数不能被关闭的进程1234567if (app.persistent || app.services.size() != 0 || app.curReceiver != null || app.persistentActivities &gt; 0) &#123; // Don&apos;t count processes holding services against our // maximum process count. numServiceProcs++; &#125; 步骤二， 设当前最大运行进程数curMaxProcs = curMaxProcs + numServiceProcs（即默认最大进程数与运行Service的进程数之和），如果当前进程的数量mRemovedProcesses.size()大于这个值，则遍历所有当前运行的进程，杀死符合条件的那些进程并释放内存。清理过程见清单 5（部分代码省略）。从清单5的代码中可以看出，进程被杀死的条件是： 必须是非 persistent 进程，即非系统进程； 必须是空进程，即进程中没有任何activity存在。如果杀死存在Activity的进程，有可能关闭用户正在使用的程序，或者使应用程序恢复的时延变大，从而影响用户体验； 必须无broadcast receiver。运行broadcast receiver一般都在等待一个事件的发生，用户并不希望此类程序被系统强制关闭； 进程中service的数量必须为0。存在service的进程很有可能在为一个或者多个程序提供某种服务，如GPS定位服务。杀死此类进程将使其他进程无法正常服务。 以上条件缺一不可。清单 5. 清理过程123456789101112131415161718if (!app.persistent &amp;&amp; app.activities.size() == 0 &amp;&amp; app.curReceiver == null &amp;&amp; app.services.size() == 0) &#123; if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; Process.killProcess(app.pid); &#125; else &#123; try &#123; app.thread.scheduleExit(); &#125; catch (Exception e) &#123; // Ignore exceptions. &#125; &#125; // todo: For now we assume the application is not buggy // or evil, and will quit as a result of our request. // Eventually we need to drive this off of the death // notification, and kill the process if it takes too long. cleanUpApplicationRecordLocked(app, false, i); i--; &#125; 步骤三，再次检查当前运行的进程，如果mRemovedProcesses.size()仍然大于curMaxProcs则放宽条件再次进行回收。判断条件见代码清单6（部分代码省略）。下面代码中，布尔变量canQuit的值为真时，那么这个进程可以被回收。canQuit的取值分两个步骤，首先是根据进程的属性赋值。 1. 必须是非persistent进程，即非系统进程；2. 必须无broadcast receiver；3. 进程中service的数量必须为 0；4.persistent类型的activity数量为0。与步骤二唯一的不同在第 4 条，这里不要求进程是空进程，只要进程中没有persistent类型的Activity就可以（Activity 是否是persistent类型在开发阶段指定）。这些条件都满足时，再检查进程中每个Activity的属性，当该进程中所有的Activity都还必须满足三个条件：Activity的状态已经保存，当前处在不可见状态并且Activity已经Stop。这时杀掉进程只会降低下次调用程序时的加载速度，下次启动时将恢复到关闭之前的状态，并不会在用户体验上造成致命的影响，所以，canQuit置位为真。这种情况与步骤二的回收方式也有所不同，由于进程中 Activity的数量不是0，下一步需要对每个activity执行destroyActivityLocked()销毁，最后才杀死进程。清单 6. 执行 destroyActivityLocked() 销毁12345678910111213141516171819202122232425boolean canQuit = !app.persistent &amp;&amp; app.curReceiver == null &amp;&amp; app.services.size() == 0 &amp;&amp; app.persistentActivities == 0; int NUMA = app.activities.size(); for (j=0; j&lt;NUMA &amp;&amp; canQuit; j++) &#123; HistoryRecord r = (HistoryRecord)app.activities.get(j); canQuit = (r.haveState || !r.stateNotNeeded) &amp;&amp; !r.visible &amp;&amp; r.stopped; &#125; if (canQuit) &#123; // Finish all of the activities, and then the app itself. for (j=0; j&lt;NUMA; j++) &#123; HistoryRecord r = (HistoryRecord)app.activities.get(j); if (!r.finishing) &#123; destroyActivityLocked(r, false); &#125; r.resultTo = null; &#125; if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; Process.killProcess(app.pid); &#125; cleanUpApplicationRecordLocked(app, false, i); i--; //dump(); &#125; 步骤四，上面3个过程都是针对整个 process 进行的资源回收。在以上过程执行完毕之后，将在更小的粒度上对Activity的资源进行回收。与上面所述类似，列表mLRUActivities存储了当前所有运行中的Activity，排序规则同样为最少访问原则。mLRUActivities.size()返回系统中运行的Activity的数量，当其大于MAX_ACTIVITIES（MAX_ACTIVITIES是一个常量，一般值为20，代表系统中最大允许同时存在的Activity时。将回收部分满足条件的Activity以减少内存的使用。回收条件代码清单7所示：清单 7. 回收条件代码1234567891011121314151617181920//Finally, if there are too many activities now running, try to // finish as many as we can to get back down to the limit. for ( i=0; i&lt;mLRUActivities.size() &amp;&amp; mLRUActivities.size() &gt; curMaxActivities; i++) &#123; final HistoryRecord r = (HistoryRecord)mLRUActivities.get(i); // We can finish this one if we have its icicle saved and // it is not persistent. if ((r.haveState || !r.stateNotNeeded) &amp;&amp; !r.visible &amp;&amp; r.stopped &amp;&amp; !r.persistent &amp;&amp; !r.finishing) &#123; final int origSize = mLRUActivities.size(); destroyActivityLocked(r, true); if (origSize &gt; mLRUActivities.size()) &#123; i--; &#125; &#125; &#125; 这里回收的只是Activity的内存资源，并不会杀死进程，也不会影响进程的运行。当进程需要调用被杀掉的Activity时，可以从保存的状态中回复，当然可能需要相对长一点的时延。 Linux 内核中的内存回收lowmemorykiller上面提到，trimApplications()函数中会执行一个叫做updateOomAdjLocked()的函数，如果返回false，则执行默认回收，若返回true则不执行默认内存回收。updateOomAdjLocked将针对每一个进程更新一个名为adj的变量，并将其告知Linux内核，内核维护一个包含adj的数据结构（即进程表），并通过lowmemorykiller检查系统内存的使用情况，在内存不足的情况下杀死一些进程并释放内存。下面将对这种Android Framework与Linux内核相配合的内存回收机制进行研究。 由于Android操作系统中的所有应用程序都运行在独立的Dalvik虚拟机环境中，Linux内核无法获知每个进程的运行状态，也就无法为每个进程维护一个合适的adj值，因此，Android Application Framework中必须提供一套机制以动态的更新每个进程的adj。这就是updateOomAdjLocked()。 updateOomAdjLocked()位于ActivityManagerService中，其主要作用是为进程选择一个合适的adj值，并通知 Linux 内核更新这个值。updateOomAdjLocked 首先调用computeOomAdjLocked()初步计算adj的值，然后回到updateOomAdjLocked()对其值进行进一步修正。估算流程可参见代码。 关于adj，其定义在task_struct-&gt;signal_struct-&gt;adj, 文件 /kernel/include/linux/sched.h中（其实在Android源码com.android.server.am.ProcessList.java中有定义，但在Android 7.0及之后，adj的映射值不再是-17~16，具体可以参见源代码）。实质为进程数据结构中的一个变量，用来表示发生Out of Memory时杀死进程的优先级顺序。lowmemorykiller利用这个变量对进程的重要程度进行判断，并在内存不足时释放部分空间，其实现在文件/kernel/drivers/staging/android/lowmemorykiller.c中。lowmemorykiller定义了两个数组：lowmem_adj和 lowmem_minfree。其中lowmen_adj定义了一系列adj键值，而lowmem_minfree 的每个元素代表一个内存阈值。如下代码中四个阈值分别是 6MB，8MB，16MB 和 64MB，分别代表当内存小于64MB时，adj大于或等于12的那些进程将被杀死并回收，内存小于16MB时，adj大于等于6的那些进程将被杀死并回收，内存小于8MB时，adj大于等于1的那些进程将被杀死并回收，内存小于6MB时，adj大于等于0的所有进程将被杀死并回收。内核中的每个进程都持有一个adj，取值范围-17到15(准确说还是-17~16，只是16这个值用于缓存等特殊情况)，值越小代表进程的重要性越高，回收优先级越低，其中-17代表禁用自动回收。Android 系统中，只有 0-15 被使用。清单 8. 每个进程都持有一个 adj1234567891011121314static int lowmem_adj[6] = &#123; 0, 1, 6, 12, &#125;; static int lowmem_adj_size = 4; static size_t lowmem_minfree[6] = &#123; 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */ &#125;; static int lowmem_minfree_size = 4; lowmemorykiller注册一个lowmem_shrinker，lowmem_shrinker利用了标准Linux内核中的Cache Shrinker来实现，当空闲内存页面不足时，内核线程kswapd将用已注册的lowmem_shrinker来回收内存页面。清单 9. 用已注册的 lowmem_shrinker 来回收内存页面1234567891011static struct shrinker lowmem_shrinker = &#123; .shrink = lowmem_shrink, .seeks = DEFAULT_SEEKS * 16 &#125;; static int __init lowmem_init(void) &#123; task_free_register(&amp;task_nb); register_shrinker(&amp;lowmem_shrinker); return 0; &#125; lowmem_shrink的代码在函数lowmem_shrink中，下面给出该函数的主要结构。lowmem_shrink根据上述规则遍历所有进程，选出需要结束的进程，通过发送一个无法忽略的信号SIGKILL强制结束这些进程清单 10. 强制结束进程123456789101112static int lowmem_shrink(struct shrinker *s, int nr_to_scan, gfp_t gfp_mask) &#123; for_each_process(p) &#123; //Select processes to be forced &#125; if (selected) &#123; force_sig(SIGKILL, selected); rem -= selected_tasksize; &#125; else rem = -1; return rem; &#125; Oom_killer如果上述各种方法都无法释放出足够的内存空间，那么当为新的进程分配应用程序时将发生Out of Memory异常，OOM_killer将尽最后的努力杀掉一些进程来释放空间。Android中的OOM_killer继承自标准Linux 2.6内核，用于分配内存时Out of Memory的处理。Android并没有对其实现方式进行修改。其位置在linux/mm/oom_kill.c。oom_killer遍历进程，并计算所有进程的badness值，选择badness最大的那个进程将其杀掉。函数badness的声明如下： unsigned long badness(struct task_struct *p, unsigned long uptime) 函数select_bad_process返回将要杀掉的那个进程。 清单 11. 返回将要杀掉的进程123456789101112static struct task_struct *select_bad_process(unsigned long *ppoints, struct mem_cgroup *mem) &#123; for_each_process(p) &#123; points = badness(p, uptime.tv_sec); if (points &gt; *ppoints || !chosen) &#123; chosen = p; *ppoints = points; &#125; &#125; return chosen; &#125; 最后，和lowmemorykiller一样，通过发送SIGKILL结束选中的进程。由于oom_killer与标准Linux内核并无不同，这里不再详细研究。 总结本文研究了Android操作系统上的内存回收机制。主要包括Application Framework层的默认回收以及Linux内核中的lowmemorykiller、OOM_killer。一般来说应用开发者并不需要控制或者修改系统的内存管理以及回收，但是深入理解这些系统级的管理机制还是必要的，尤其有助于更加合理地设计应用程序，使应用程序的进程在其生命周期内高效地运行。而系统级开发者如果想要对内存管理机制进行优化，对原有机制的理解则是必不可少的重要前提。 参考资料 参考 Android 专题： Android 开发从入门到精通。 更多有关移动开发方面的内容，请参考移动开发专题。","tags":[{"name":"Android","slug":"Android","permalink":"http://cstsinghua.github.io/tags/Android/"},{"name":"内存管理","slug":"内存管理","permalink":"http://cstsinghua.github.io/tags/内存管理/"},{"name":"内存回收","slug":"内存回收","permalink":"http://cstsinghua.github.io/tags/内存回收/"},{"name":"机制","slug":"机制","permalink":"http://cstsinghua.github.io/tags/机制/"},{"name":"OS","slug":"OS","permalink":"http://cstsinghua.github.io/tags/OS/"}]},{"title":"Android热修复技术选型——三大流派解析","date":"2016-12-02T09:15:32.000Z","path":"2016/12/02/Android热修复技术选型——三大流派解析/","text":"本文是引用引用自淘宝无线开发专家 所为 的文章；原文地址https://baichuan.bbs.taobao.com/detail.html?spm=a3c0d.7998981.0.0.hHNK0p&amp;postId=6571722 技术背景一、正常开发流程 从流程来看，传统的开发流程存在很多弊端：重新发布版本代价太大用户下载安装成本太高BUG修复不及时，用户体验太差 二、热修复开发流程 而热修复的开发流程显得更加灵活，优势很多：无需重新发版，实时高效热修复用户无感知修复，无需下载新的应用，代价小修复成功率高，把损失降到最低 业界热门的热修复技术热修复作为当下热门的技术，在业界内比较著名的有阿里巴巴的AndFix、Dexposed，腾讯QQ空间的超级补丁技术和微信的Tinker。最近阿里百川推出的HotFix热修复服务就基于AndFix技术，定位于线上紧急BUG的即时修复，所以AndFix技术这块我们重点分析阿里百川HotFix。下面，我们就分别介绍QQ空间超级热补丁技术和微信的Tinker以及阿里百川HotFix技术。 一、QQ空间超级补丁技术超级补丁技术基于DEX分包方案，使用了多DEX加载的原理，大致的过程就是：把BUG方法修复以后，放到一个单独的DEX里，插入到dexElements数组的最前面，让虚拟机去加载修复完后的方法。 当patch.dex中包含Test.class时就会优先加载，在后续的DEX中遇到Test.class的话就会直接返回而不去加载，这样就达到了修复的目的。 但是有一个问题是，当两个调用关系的类不在同一个DEX时，就会产生异常报错。我们知道，在APK安装时，虚拟机需要将classes.dex优化成odex文件，然后才会执行。在这个过程中，会进行类的verify操作，如果调用关系的类都在同一个DEX中的话就会被打上CLASS_ISPREVERIFIED的标志，然后才会写入odex文件。 所以，为了可以正常的进行打补丁修复，必须避免类被打上CLASS_ISPREVERIFIED标志，具体的做法就是单独放一个类在另外DEX中，让其他类调用。 我们来逆向手机QQ空间APK看一下具体的实现：先进入程序入口QZoneRealApplication，在attachBaseContext中进行了两步操作：修复CLASS_ISPREVERIFIED标志导致的unexpected DEX problem异常、加载修复的DEX。 1.修复unexpectedDEX problem异常 先看代码： 可以看到，这里是要加载一个libs目录下的dalvikhack.jar。在项目的assets/libs找到该文件，解压得到classes.dex文件，逆向打开该DEX文件， 通过不同的DEX加载进来，然后在每一个类的构造方法中引用其他DEX中的唯一类AnitLazyLoad，避免类被打上CLASS_ISPREVERIFIED标志。 在无修复的情况下，将DO_VERIFY_CLASSES设置为false，提高性能。只有在需要修复的时候，才设置为true。 至于如何加载进来，与接下来第二个步骤基本相同。 2.加载修复的DEX 从loadPatchDex()方法进入，经过几次跳转，到达核心的代码段，SystemClassLoaderInjector.c()。由于进行了混淆和多次方法的跳转，于是将核心代码段做了如下整理： 修复的步骤为： 可以看出是通过获取到当前应用的Classloader，即为BaseDexClassloader 通过反射获取到他的DexPathList属性对象pathList 通过反射调用pathList的dexElements方法把patch.dex转化为Element[] 两个Element[]进行合并，把patch.dex放到最前面去 加载Element[]，达到修复目的 整体的流程图如下： 从流程图来看，可以很明显的找到这种方式的特点： 优势： 没有合成整包（和微信Tinker比起来），产物比较小，比较灵活 可以实现类替换，兼容性高。（某些三星手机不起作用） 不足： 不支持即时生效，必须通过重启才能生效。 为了实现修复这个过程，必须在应用中加入两个DEX！dalvikhack.dex中只有一个类，对性能影响不大，但是对于patch.dex来说，修复的类到了一定数量，就需要花不少的时间加载。对手淘这种航母级应用来说，启动耗时增加2s以上是不能够接受的事。 在ART模式下，如果类修改了结构，就会出现内存错乱的问题。为了解决这个问题，就必须把所有相关的调用类、父类子类等等全部加载到patch.dex中，导致补丁包异常的大，进一步增加应用启动加载的时候，耗时更加严重。 二、微信Tinker微信针对QQ空间超级补丁技术的不足提出了一个提供DEX差量包，整体替换DEX的方案。主要的原理是与QQ空间超级补丁技术基本相同，区别在于不再将patch.dex增加到elements数组中，而是差量的方式给出patch.dex，然后将patch.dex与应用的classes.dex合并，然后整体替换掉旧的DEX，达到修复的目的。 我们来逆向微信APK看一下具体的实现：先找到应用入口TinkerApplication，在onBaseContextAttached()调用了loadTinker(), 进入TinkerLoader的tryLoad()方法中， 从方法名可以预见，在tryLoadPatchFilesInternal()中尝试加载本地的补丁，再经过跳转进入核心修复功能类SystemClassLoaderAdder.class中。 代码中可以看出，根据Android版本的不同，分别采取具体的修复操作，不过原理都是一样的。我们以V19为例： 从代码中可以看到，通过反射操作得到PathClassLoader的DexPatchList,反射调用patchlist的makeDexElements()方法吧本地的DEX文件直接替换到Element[]数组中去，达到修复的目的。对于如何进行patch.dex与classes.dex的合并操作，这里微信开启了一个新的进程，开启新进程的服务TinkerPatchService进行合并。 整体的流程如下： 从流程图来看，同样可以很明显的找到这种方式的特点： 优势：合成整包，不用在构造函数插入代码，防止verify，verify和opt在编译期间就已经完成，不会在运行期间进行性能提高。兼容性和稳定性比较高。开发者透明，不需要对包进行额外处理。 不足：与超级补丁技术一样，不支持即时生效，必须通过重启应用的方式才能生效。需要给应用开启新的进程才能进行合并，并且很容易因为内存消耗等原因合并失败。合并时占用额外磁盘空间，对于多DEX的应用来说，如果修改了多个DEX文件，就需要下发多个patch.dex与对应的classes.dex进行合并操作时这种情况会更严重，因此合并过程的失败率也会更高。 三、阿里百川HotFix阿里百川推出的热修复HotFix服务，相对于QQ空间超级补丁技术和微信Tinker来说，定位于紧急bug修复的场景下，能够最及时的修复bug，下拉补丁立即生效无需等待。 1、AndFix实现原理AndFix不同于QQ空间超级补丁技术和微信Tinker通过增加或替换整个DEX的方案，提供了一种运行时在Native修改Filed指针的方式，实现方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。原理图如下： 2、AndFix实现过程 对于实现方法的替换，需要在Native层操作，经过三个步骤： 接下来以Dalvik设备为例，来分析具体的实现过程： 2.1 setup() 对于Dalvik来说，遵循JIT即时编译机制，需要在运行时装载libdvm.so动态库，获取以下内部函数：1） dvmThreadSelf( )：查询当前的线程；2）dvmDecodeIndirectRef()：根据当前线程获得ClassObject对象。 2.2 setFieldFlag 该操作的目的：让private、protected的方法和字段可被动态库看见并识别。原因在于动态库会忽略非public属性的字段和方法。 2.3 replaceMethod 该步骤是方法替换的核心，替换的流程如下： AndFix对ART设备同样支持，具体的过程与Dalvik相似，这里不再赘述。从技术原理，不难看出阿里百川HotFix的几个特点： 最大的优势在于BUG修复的即时性补丁包同样采用差量技术，生成的PATCH体积小对应用无侵入，几乎无性能损耗 不足：不支持新增字段，以及修改方法，也不支持对资源的替换。由于厂商的自定义ROM，对少数机型暂不支持。 综合分析如下： 热修复的坑和解我们可以看到，QQ空间超级补丁技术和微信Tinker的修复原理都基于类加载，在功能上已经支持类、资源的替换和新增，功能非常强大。既然已经有了这么强大的热修复技术，为什么阿里百川还要推出自己的热修复方案HotFix呢？ 一、多DEX带来的性能问题和影响我们知道，多DEX方案用来解决应用方法数65k的问题，现在Google也官方支持了MultiDex的实现方案。但是，这实在是应用因方法数超出而作出的不得已的下策，但是超级补丁技术和Tinker作为一种热修复的方案，平生给应用增加了多个DEX，而多DEX技术最大的问题在于性能上的坑，因此基于这种方案的补丁技术影响应用的性能是无疑的。 1.启动加载时间过长 我们可以看到，超级补丁技术和Tinker都选择在Application的attachBaseContext()进行补丁DEX的加载，即使这是加载dex的最佳时机，但是依然会带来很大的性能问题，首当其冲的就是启动时间太长。 对于补丁DEX来说，应用启动时虚拟机会进行dexopt操作，将patch.dex文件转换成odex文件，这个过程非常耗时。而这个过程，又要求需要在主线程中，以同步的方式执行，否则无法成功进行修复。就DEX的加载时间，大概做了以下的时间测试。 随着patch.dex的增加，在不做任何优化的情况下，启动时间也直线增长。对于一个应用来说，这简直是灾难性的。 2.易造成应用的ANR和Crash 正是尤其多DEX加载导致了启动时间过长，很容易就会引发应用的ANR。我们知道当应用在主线程等待超过5s以后，就会直接导致长时间无响应而退出。超级补丁技术为保证ART不出现地址错乱问题，需要将所有关联的类全部加入到补丁中，而微信Tinker采取一种差量包合并加载的方式，都会使要加载的DEX体积变得很大。这也很大程度上容易导致ANR情况的出现。 除了应用ANR以外，多DEX模式也同样很容易导致Crash情况的出现。我们知道，超级补丁技术为了保证ART设备下不出现地址错乱问题，需要把修改类的所有相关类全部加入到补丁中，这里会出现一个问题，为了保证补丁包的体积最小，能否保证引入全部的关联类而不引入无关的类呢？一旦没有引入关联的类，就会出现以下的异常： NoClassDefFoundError Could not find class Could not find method 出现这些异常，就会直接导致应用的Crash退出。 所以，不难看出如果我们需要修复一个不是Crash的BUG，但是因为未加入相关类而导致了更严重的Crash，就更加的得不偿失。 总的来说，热修复本质的目的是为了保证应用更加稳定，而不是为了更强大的功能引入更大的风险和不稳定性。 二、热修复 or 插件化？我们经常提到热修复和插件化，这都是当下热门的新兴技术。在讲述之前，需要对这两个概念进行一下解释。插件化：一个程序划分为不同的部分，以插件的形式加载到应用中去，本质上它使用的技术还是热修复技术，只是加入了更多工程实践，让它支持大规模的代码更新以及资源和SO包的更新。热修复：当线上应用出现紧急BUG，为了避免重新发版，并且保证修复的及时性而进行的一项在线推送补丁的修复方案。 显然，从概念上我们可以看到，插件化使用场景更多是功能，热修复使用常见在于修复。从这个层面来说，插件化必然功能更加强大，能做的事情也更多。QQ空间超级补丁技术和微信Tinker从类、资源的替换和更新上来看，与其说是热修复，不如说是插件化。 当然，强大的功能也就增加了不稳定的因素。比如上文提到的增加启动时间，导致ANR、Crash的问题。 QQ空间超级补丁技术和微信Tinker提供了更加强大的功能，但是对应用的性能和稳定有较大的影响，就BUG修复的这个使用场景上还不够明确，并且显得过重。 针对应用的性能损耗，我们可以举例做一个对比。某APP的启动载入时间为3s左右，本身就是基于多DEX模式的实现。分别接入三种热修复服务，根据腾讯提供超级补丁技术和Tinker的数据，那么会变成以下的场景：阿里百川HotFix:启动时间几乎无增加，不增加运行期额外的磁盘消耗。QQ空间超级补丁技术：如果应用有700个类，启动耗时增加超过2.5s，达到5.5s以上。微信Tinker：假设应用有5个DEX文件，分别修改了这5个DEX，产生5个patch.dex文件，就要进行5次的patch合并动作，假设每个补丁1M，那么就要多占用7.5M的磁盘空间。 显然对于修复紧急BUG这个场景，阿里百川HotFix的更为合适，它更加轻量，可以在不重启的情况下生效，且对性能几乎没有影响。微信Tinker、QQ空间超级补丁技术更多地把场景定位在发布小的新功能上，采用ClassLoader的模式，牺牲较高的性能代价去实现类、资源新增或替换的功能。阿里百川HotFix对应用本身做到无侵入，无性能损耗。 总结QQ空间超级补丁技术和微信Tinker 支持新增类和资源的替换，在一些功能化的更新上更为强大，但对应用的性能和稳定会有的一定的影响；阿里百川HotFix虽然暂时不支持新增类和资源的替换，对新功能的发布也有所限制，但是作为一项定位为线上紧急BUG的热修复的服务来说，能够真正做到BUG即时修复用户无感知，同时保证对应用性能不产生不必要的损耗，在热修复方面不失为一个好的选择。 目前阿里百川HotFix已经开始公测，点击立即使用，即可开始你的热修复之旅。","tags":[{"name":"Android","slug":"Android","permalink":"http://cstsinghua.github.io/tags/Android/"},{"name":"热修复","slug":"热修复","permalink":"http://cstsinghua.github.io/tags/热修复/"},{"name":"插件化","slug":"插件化","permalink":"http://cstsinghua.github.io/tags/插件化/"},{"name":"HotFix","slug":"HotFix","permalink":"http://cstsinghua.github.io/tags/HotFix/"},{"name":"Tinker","slug":"Tinker","permalink":"http://cstsinghua.github.io/tags/Tinker/"},{"name":"手Qzone","slug":"手Qzone","permalink":"http://cstsinghua.github.io/tags/手Qzone/"},{"name":"Andfix","slug":"Andfix","permalink":"http://cstsinghua.github.io/tags/Andfix/"},{"name":"阿里百川","slug":"阿里百川","permalink":"http://cstsinghua.github.io/tags/阿里百川/"}]},{"title":"Git命令使用遇到的那些坑","date":"2016-11-17T03:40:58.000Z","path":"2016/11/17/Git命令使用遇到的那些坑/","text":"Git命令使用遇到的那些坑收集 Git命令使用遇到的那些坑Git是一款强大的版本管理工具，网上有很多Git教程，但是很多资料让人一知半解，不得要领。所以，还是阅读Git官方使用教程https://git-scm.com/book/zh/v2，或者通过终端git help命令来仔细研究各个命令，然后积累经验,熟能生巧。记住，踩坑是成长的必由之路！ 配置GitGit使用一系列配置文件来保存你自定义的行为。 它首先会查找/etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递–system选项给git config，它就会读写该文件。 接下来Git会查找每个用户的~/.gitconfig文件（或者~/.config/git/config文件）。 你可以传递–global选项让Git读写该文件。 最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该版本库有效。 以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以.git/config 中的值会覆盖掉/etc/gitconfig中所对应的值。 Note: Git的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行git config命令会更简单些。 客户端配置Git 能够识别的配置项分为两大类：客户端和服务器端。 其中大部分属于客户端配置——可以依你个人的工作偏好进行配置。尽管Git支持的选项 繁多，但其中大部分仅仅在某些罕见的情况下有意义。 我们只讲述最平常和最有用的选项。 如果想得到你当前版本的 Git 支持的选项列表，请运行 $ man git-config 这个命令列出了所有可用的选项，以及与之相关的介绍。 你也可以在 http://git-scm.com/docs/git-config.html 找到同样的内容。 core.editor默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器，如果没有设置，会调用vi来创建和编辑你的提交以及标签信息。 你可以使用core.editor选项来修改默认的编辑器： $ git config –global core.editor emacs 现在，无论你定义了什么终端编辑器，Git都会调用Emacs编辑信息。 Note: 如果是在windows系统下，比如设置编辑器为VS code，可能会遇到各种坑。 坑1： git config --global core.editor D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe，此时会报错bash: syntax error near unexpected token `(‘，表明git bash里面不支持(符号，因此得想办法回避这个问题； 坑2：在踩过坑1，可能会git config --global core.editor &quot;D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe&quot;，即用英文的引号将VS code的路径包裹起来，这样不会确实不会报错了。但是当git commit或其他编辑的时候，报错如下： $ git config --global --edit D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe: -c: line 0: syntax error near unexpected token `(&apos; D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe: -c: line 0: `D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe &quot;$@&quot;&apos; error: There was a problem with the editor &apos;D:\\Program Files (x86)\\Microsoft VS Code\\Code.exe&apos;. 表明，其实真正在执行的时候还是无法绕过(符号。因此不能直接使用这样的路径。得想其他办法，比如设置上面提到的$VISUAL 或 $EDITOR，将VS Code的路径赋值进去；或者将VS Code的路径添加到PATH环境变量里面。 坑3：在坑2的基础上，改用git config --global core.editor code,然后git commit或其他编辑的时候，VS Code编辑器确实被自动打开了，但是commit的时候却提示： $ git commit Aborting commit due to empty commit message. 这是因为git commit的工作原理如下： 1.创建新的编辑器进程；2.将COMMIT_EDITMSG文件传递给这个进程(可阻塞等待进程结束，也可直接返回，这里取决于配置时的参数)；3.读取COMMIT_EDITMSG文件。 关键在第二步，这种情况下，默认是没有等待VS Code进程结束就直接返回，而此时COMMIT_EDITMSG还并没有编辑，所以才是empty commit message，从而导致退出commit操作。此时，我们可以使用git config --global core.editor &quot;code -w&quot;，-w参数表示阻塞commit并等待VS Code进程结束。这样就成功解决了问题。 Note:最后发现，其实也可以直接在全局的.gitconfig文件(可以搜索找到它，一般情况下路径是%HOME%.gitconfig)里面直接编辑如下格式来解决上述问题。请注意必须在路径前后加上转义的引号，即&quot;D:/Program Files (x86)/Microsoft VS Code/Code.exe&quot;是不行的。 [core] editor = “\\”D:/Program Files (x86)/Microsoft VS Code/Code.exe\\””","tags":[{"name":"Git","slug":"Git","permalink":"http://cstsinghua.github.io/tags/Git/"},{"name":"命令","slug":"命令","permalink":"http://cstsinghua.github.io/tags/命令/"},{"name":"坑","slug":"坑","permalink":"http://cstsinghua.github.io/tags/坑/"}]},{"title":"npm常用命令","date":"2016-11-04T03:53:47.000Z","path":"2016/11/04/npm常用命令/","text":"npm常用命令介绍 npm常用命令 查看已安装的包查看当前目录下安装的所有的包： npm list 查看全局安装的所有的包（-g参数代表全局的意思）： npm list -g 查看已经安装的某个包的信息： npm list package_name [-g] 安装包 npm install [-g] [package_name[@next] [–save] 1.后面没有所有参数，即只输入npm install，表示在当前目录下安装当前目录工程)下的package.json的dependencies中指定的包； 1.加上-g代表全局安装，不加则表示在当前目录下安装 2.加上@next表示安装最新版本 3.加上--save表示安装的同时也将包加入到当前路径(工程)下的package.json的dependencies中去，这样以后迁移的时候就可以采用1来安装，比较便捷，可以记录依赖关系。 npm install [-g] [package_name[@version] [–save] 1.其他如上，只是这里如果是@version，则表示安装指定版本的包。比如安装TypeScript 2.0,可以使用npm install typescript@2.0.0.","tags":[{"name":"常用","slug":"常用","permalink":"http://cstsinghua.github.io/tags/常用/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://cstsinghua.github.io/tags/NodeJS/"},{"name":"npm","slug":"npm","permalink":"http://cstsinghua.github.io/tags/npm/"}]},{"title":"Android知识体系及新手如何快速入门","date":"2016-09-12T06:25:13.000Z","path":"2016/09/12/Android知识体系及新手如何快速入门/","text":"Android知识体系及新手如何快速入门Note：本文摘录自网易梁建 | 网易云音乐安卓主程的一篇文章，稍做修改，仅供参考，其实很多还是比较粗略，后续会在此基础上进一步完善 Android知识体系框架 Android知识体系框架 接下来，我们具体讲一讲各个部分的内容。 四大组件 Android四大组件 UI设计 UI设计 常见View的使用 常见View的使用 网络 网络 线程和进程 线程和进程 数据存储 数据存储 进阶学习 进阶学习 编程基础 编程基础 网络协议 网络协议 数据库 数据库 开源框架 开源框架 测试基础任何一个开发都不能把产品的质量完全依赖于专业的测试人员，相反，应该直接把上行质量作为自测目标。所以，开发人员需要学习必要的测试方法，常见的测试方法包括： 测试基础 其他补充学习 其他补充学习 总结讲完知识体系，下面讲讲作为一个新人如何快速入门和进阶的一些经验。想要快速入门，可以尝试以下的方式： 买一本通俗易懂的书籍，快速看完； 查看并模仿官方samples，这可以让你了解安卓的样子； 实践一个感兴趣功能 入门之后，进阶可以分为三步： 第一步进阶：系统学习官方training和guide部分，仔细看完获益匪浅 第二步进阶：引入开源项目简化开发，并查看源码了解实现； 第三步进阶：当你慢慢熟悉开发之后，这个时候你就需要对view的内部世界更加了解，查看常见组件view等内部实现，查看Activity ManagerService, Android进程启动，低内存杀进程等运行机制，学习安卓运行环境，学习各种调优工具进行优化。 推荐资料 历年Google I/O大会视频微信公众号：Google开发者国人整理的学习列表 https://github.com/Trinea/android-open-project https://github.com/Freelander/Android_Data","tags":[{"name":"路线图","slug":"路线图","permalink":"http://cstsinghua.github.io/tags/路线图/"},{"name":"入门","slug":"入门","permalink":"http://cstsinghua.github.io/tags/入门/"},{"name":"新手","slug":"新手","permalink":"http://cstsinghua.github.io/tags/新手/"}]},{"title":"Eclipse常用快捷键","date":"2016-07-14T09:30:18.000Z","path":"2016/07/14/Eclipse常用快捷键/","text":"Eclipse常用的快捷键总结 Eclipse常用快捷键纸上得来终觉浅，绝知此事要躬行！！！ Ctrl+D 删除本行； Alt+/ 代码提示； shift+enter在当前行下面添加空行； ctrl+shift+enter在当前行上面添加空行； alt+up（down）上移或下移选定行； Ctrl+/ 注释或取消注释； Ctrl+1 提示和建议； Ctrl+alt+up(down) 向上或向下复制选定行； End 来到行尾；Home来到行首； Ctrl+m 最大化窗口或还原窗口； Ctrl+o 方法大纲和搜索方法； Ctrl+l 来到指定行号 Ctrl+e 在多个编辑窗口切换 Ctrl+shift+o 导入包 Ctrl+shift+/ 添加块注释 Ctrl+shift+\\ 去除块注释 Ctrl+Q 定位到最后编辑的地方 Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) Ctrl+Shift+X 把当前选中的文本全部变为小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 当光标在一行的两端时，按住shift+home/end可以选择当前行 ctrl+左右箭头 跳过一个单词 ctrl+shift+左右是选择一个单词，可以连点左右以选择多个 shift+上下键！选中光标到上下行！ 列编辑模式 Alt+Shift+A，一般情况下可能与系统其他快捷键冲突，可以修改为其他组合方式；","tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://cstsinghua.github.io/tags/快捷键/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://cstsinghua.github.io/tags/Eclipse/"},{"name":"常用","slug":"常用","permalink":"http://cstsinghua.github.io/tags/常用/"}]},{"title":"Android studio常用快捷键","date":"2016-07-13T10:07:19.000Z","path":"2016/07/13/Android-studio常用快捷键/","text":"Android studio常用的快捷键 Android studio常用快捷键总结书读百遍，其义自现。同理，快捷键的使用需要孰能生巧。其实Android studio的的settings里面Keymap可以查看所有的快捷键，另外在Android studio的菜单栏，菜单项里面也注明了每项操作的快捷键(如果有)，经常查看和练习，根本也用不着在网上找说明。当然，对于新人或者英文不是太好的初学者，借鉴别人的经验是最快的学习方式。本文暂只适用于Windows平台，Mac环境后续补充。 搜索快捷键 快捷键 含义 Eclipse对应的快捷键 说明 Ctrl+F 局部查找 Ctrl+F 在当前打开的文件中查找 Ctrl+R 局部查找替换 Ctrl+F 在当前打开的文件中查找替换 Ctrl+shift+F 全局查找 Ctrl+H 在整个工作空间查找 Ctrl+shift+R 全局查找替换 Ctrl+H 在整个工作空间查找替换 Alt+F7 全局搜索被引用的地方 Ctrl+Alt+H 将光标放在任何地方按下alt+f7即可在全局搜索被引用的地方，强大之处不管是文件、字符串、字段、方法、类皆可，AS会智能识别到底是什么东西 Ctrl+H 查看所选择类的继承层级关系 F4或Ctrl+T 选择某个类或者类名时按下则会显示出该类的继承层级，从Object到最终子类 Ctrl+F3 在当前文件查找所选择的字符出现的地方 Ctrl+K 结合F3键使用，先选择某个字符串，然后按下不断Ctrl+F3，则会在文档中该字符串出现的地方来回切换，当到达最后一个出现的地方时，按F3键从头开始搜索，F3键是在已选择字符串后，在出现的地方循环来回切换 Ctrl+Shift+A 可以进到任何你要去的地方(包括配置) 暂无 可以进到任何你要去的地方(包括配置) 2次点击Shift 跳转到相关的文件 暂无 跳转到相关的文件 Ctrl+E 打开最近操作的文件列表 未知 打开最近操作的文件列表，从中可以选择想打开的文件 Ctrl+Q 跳转至最近一次编辑位置 Ctrl+Q 连续多次按下，可以在最近编辑的历史轨迹中往后回滚 Alt+Shift+O 快速高亮显示所选中变量在当前文件中出现的地方 Alt+Shift+O 可配合Ctrl+K一起使用，英文释义：Use Alt+Shift+O (Edit、 Find、Highlight Usages in File) to quickly highlight usages of some variable in the current file.Use Ctrl+K and Ctrl+Shift+K keys to navigate through highlighted usages.Press Esc to remove highlighting. 编辑代码的快捷键 快捷键 含义 Eclipse对应的快捷键 说明 Ctrl+Y 删除当前行 Ctrl+D 删除当前行 Ctrl+D 复制当前行或语句块 Ctrl+Alt+down 复制当前选择行或语句块 Ctrl+J 调出IDEA的神器live template 暂无 调出IDEA的神器live template Ctrl+/ 注释/取消注释 Ctrl+/ 适用于生成//单行注释 Alt+Enter 调出IDEA对出错点的提示处理方法 Ctrl+1 快速找出解决问题的提示或者建议办法 Alt+Insert 生成构造器方法、setter/getter等模板方法 暂无 generate setter/getter等等模板方法 Ctrl+Alt+L 格式化代码 Ctrl+Shift+F 格式化代码，用于美化代码排版 Ctrl+Alt+O 优化导入包 Ctrl+Shift+O 优化导入包，即没有导入的包可以自动补上，没有使用到的导入包则会删除 Ctrl+Shift+Up/Down 向上或向下移动当前行 Alt+Up/Down 向上或向下移动当前行 Alt+Shift+Up 扩展所选区域(extend selection) Alt+Shift+Up 从当前光标位置扩展当前所选区域，一直按住Alt、Shift键，多次点击up键，可以不断扩大所选的区域，此时点击down键则是相反的操作 查看代码快捷键 快捷键 含义 Eclipse对应的快捷键 说明 Ctrl+Alt+H 查看方法的调用层级结构 Ctrl+Alt+H 查看方法的调用层级结构","tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://cstsinghua.github.io/tags/快捷键/"},{"name":"Android studio","slug":"Android-studio","permalink":"http://cstsinghua.github.io/tags/Android-studio/"}]},{"title":"删除Windows下的超长路径目录","date":"2016-07-08T02:28:12.000Z","path":"2016/07/08/删除Windows下的超长路径目录/","text":"删除超长路径文件或者目录在Windows操作系统，由于使用目录工具不当或者在使用某些编程工具时生成目录时(比如反复在同一目录下导入同一个工程)常常会产生多层递归模式，导致产生多级超长目录结构，而无法用Windows可视化右键模式进行删除，市面上的很多文件删除工具，如360强力删除、unlocker删除都无济于事，真是一件恼人的事情。 其实，windows系统自身便带有相关的命令行工具可以用来删除，操作过程如下： 比如D盘下面如存在D:\\blog\\node_modules\\a\\b\\c......多层嵌套的目录； 通过cmd命令行输入cd命令进入上述目录； mkdir tempDir这个为空目录结构； robocopy /mir tempDir a；//tempDir是步骤3创建的空目录名称，而a则是D:\\blog\\node_modules\\目录下的直接子目录即a 上面执行完毕之后，便可以删除目录了 但是在某些情况下，执行robocopy命令在中途就可能停止，又不得不重新执行该命令，直到目录完全被删除为止。因此可以写批处理文件来循环操作，当然也可以采用简单的python脚本来执行。 采用python脚本循环删除超长目录示例代码如下：123456789101112131415#-*- coding:utf-8 -*-import os'''1.比如无法删除的超长目录为D:\\blog\\node_modules\\a\\b\\c\\...\\...；2.执行完毕之后，目录变成D:\\blog\\node_modules，后面的a\\b\\c\\...\\...则会被删除；'''os.chdir(r\"D:\\blog\\node_modules\")os.mkdir(r\"D:\\blog\\node_modules\\tempDir\")#创建临时的空目录while 1: result = os.system(\"Robocopy.exe tempDir a /MIR\") if(result != 0): continue else: breakos.rmdir(r\"D:\\blog\\node_modules\\tempDir\")#删除之前创建的临时目录 note：os.system(“Robocopy.exe tempDir a /MIR”)中tempDir是步骤创建的空目录名称，而a则是D:\\blog\\node_modules\\目录下的直接子目录即a，实际使用时需要修改成你自己的目录","tags":[{"name":"Windows","slug":"Windows","permalink":"http://cstsinghua.github.io/tags/Windows/"},{"name":"超长目录","slug":"超长目录","permalink":"http://cstsinghua.github.io/tags/超长目录/"},{"name":"删除","slug":"删除","permalink":"http://cstsinghua.github.io/tags/删除/"}]},{"title":"Protocol Buffers使用说明","date":"2016-07-01T02:09:43.000Z","path":"2016/07/01/Protocol Buffers使用说明/","text":"Protocol Buffers简介Protocol Buffers是一种数据交换格式，用于结构化数据的读写，类似于序列化机制。在线客服系统里面Message的body部分其实就是具有结构化的数据，因此可以采用Protocol Buffers来实现各平台和语言之间的消息传输。Protocol Buffers特点以及与XML、各语言的序列化机制等的比较，可以后续展开，这里不赘述！此处重点说明其如何使用，特别是针对java(Android)平台。 Github地址：https://github.com/google/protobuf 官方地址： https://developers.google.com/protocol-buffers/ Protocol Buffers的使用Protocol Buffers分为如下几个步骤 1. Defining Your Protocol Format(定义数据交换的协议格式)简单来说，就是类似于定义面向对象语言中的类，其相当于一个数据结构，对应用程序中要交换的数据做一个定义，包括各种字段的声明等等。其文件扩展名为.proto。对于.proto文件如何定义和其语法规范，请详细阅读Protocol Buffer Language Guide。这里是proto3版本(最新版本，建议采用)，proto2的也可以参阅proto2 Language Guide .proto示例(addressbook.proto)： // // Note: START and END tags are used in comments to define sections used in // tutorials. They are not part of the syntax for Protocol Buffers. // // To get an in-depth walkthrough of this file and the related examples, see: // https://developers.google.com/protocol-buffers/docs/tutorials // [START declaration] syntax = &quot;proto3&quot;; package tutorial; // [END declaration] // [START java_declaration] option java_package = &quot;com.example.tutorial&quot;; option java_outer_classname = &quot;AddressBookProtos&quot;; // [END java_declaration] // [START csharp_declaration] option csharp_namespace = &quot;Google.Protobuf.Examples.AddressBook&quot;; // [END csharp_declaration] // [START messages] message Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } // [END messages] 2. Protocol Compiler Installation(获取protoc可执行二进制文件)可以在Github和其官方地址上看到相关的说明，但是个人觉得其让人不觉明历，通俗来说，这一步就是要生成一个可执行的protoc二进制文件(在windows平台下即protoc.exe)。这里以Windows平台为例说明(后续如无特殊说明，均默认是Windows平台)。建议直接使用Google提供的已经编译好的二进制可执行文件(http://repo1.maven.org/maven2/com/google/protobuf/protoc/)，建议选择最新版本下载(根据自己操作系统的平台选择对应版本)。想要自己编译生成也可以，不过会遇到各种坑，感兴趣的童鞋可以尝试之protocol buffer源码包。 protoc.exe是干什么的呢？其用来编译用户定义的数据结构即步骤1中编写的.proto文件，详细参见步骤3. 3. Compiling Your Protocol Buffers(编译Protocol Buffers，即编译.proto文件)即用步骤2得到的protoc可执行二进制文件编译步骤1所得的.proto文件，最终生成语言相关的类(代码)。这里以java语言为例：其命令格式如下： protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto eg: D:\\protobuf-3.0.0-beta-2\\src&gt;protoc.exe -I=D:\\protobuf-3.0.0-beta-2\\src --java_out=D:\\kefu D:\\protob uf-3.0.0-beta-2\\src\\boyim.proto 如上，进入命令行，protoc即protoc可执行二进制文件，指定$SRC_DIR：源目录 (一般情况下即你的应用程序所在目录 – 如果不提供的话，则默认为当前工作目录即当前命令行的目录)；$DST_DIR：目标目录(你所期望生成的代码存放的目录; 通常情况下与源目录一致)；$SRC_DIR/addressbook.proto：即.proto文件的路径. 因为这里是生成java类, 因此使用 –java_out 选项 ， 类似的选项可以用于其它支持的语言.对于addressbook.proto示例，这会在目标目录下生成 com/example/tutorial/AddressBookProtos.java文件.可以查看该文件，与普通的javaBean相似，包含了很多setters/getters方法，另外有一个builder方法，用于方便构造类对象。 4. Protobuf Runtime Installation(生成Protocol Buffer API接口，用于支持操作步骤三生成的类，即核心的数据序列化和反序列化机制等包含在此API中)对于java语言而言，就是生成一个Protocol Buffer API的jar包，应用里面导入该jar包即可，其他语言类似。那么如何生成这个API库呢？ 官方说明可以参见Protobuf Runtime Installation 这里简化说明(建议使用maven来完成安装)： 4.1 安装maven(注意需要安装JDK1.7及其以上版本)maven下载地址(目前最新版本3.3.9)，http://maven.apache.org/。下载之后解压，然后将解压后得到的目录路径添加到系统path中，这样使得可以直接在命令行使用mvn命令。 4.2 下载protocol buffer源码包protocol buffer源码包。注意：这里下载的版本必须与步骤2中protoc可执行二进制文件的版本一致，要查看protoc可执行二进制文件的版本，可以在命令行输入protoc –version。下载之后，解压，找到对应语言目录(java)，如下图： 从命令行进入java目录。 注意1：步骤2下载二进制可执行文件之后需要将二进制可执行文件改名为protoc.exe(Windows平台)，并且放置在如下目录(下载的protocol buffer源码包解压目录下的src子目录下)： 注意2：需要将java目录下的pom.xml(即maven执行所依据的文件，类似于ant构建时候的build.xml)中添加编码格式，否则构建会采用操作系统默认的编码，Windows平台中文的话是GBK，而我们在Android平台采用的是UTF_8。添加部分代码如下： &lt;!-- pom.xml --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; 4.3 Run the tests(先测试运行，看看是否配置ok)在命令输入： mvn test 确保成功再进行下一步。 4.4 生成jar包在命令输入： mvn package 生成的jar包放置在java目录的子目录target下面。 5. Parsing and Serialization(解析和序列化)这一步也就是最终我们在应用程序里面对数据进行解析读写等直观的操作，也是我们最关心的部分。 将步骤3生成的java类复制进工程中(注意必须在其定义的包名结构下)，同时将步骤4生成的jar导入到工程中。 对于步骤3生成的类，利用 protocol buffer的二进制格式，每个类均具有所选择类型的写和读消息功能。即可以进行解析和序列化操作。这里列举几个： byte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes. static Type(定义的类，比如步骤1中的Person) parseFrom(byte[] data);: parses a message from the given byte array. void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream. static Type(定义的类，比如步骤1中的Person) parseFrom(InputStream input);: reads and parses a message from an InputStream. 事实上，每个类包含有大量的解析和序列化的方法。 请参照 Message API reference进行详细查阅。","tags":[{"name":"Protocol Buffers","slug":"Protocol-Buffers","permalink":"http://cstsinghua.github.io/tags/Protocol-Buffers/"}]},{"title":"Github pages+Hexo+Nodejs搭建个人blog","date":"2016-06-16T10:35:07.000Z","path":"2016/06/16/Github pages+Hexo+Nodejs搭建个人blog/","text":"前言作为一个IT技术人员，自然离不开技术的积累，而技术的积累则通过文档或代码的形式呈现出来。好记性不如烂笔头，程序员应该乐于并擅于记录总结工作中遇到的各种问题、工作成果、奇思异想和感悟等。 程序员的世界是孤独的，但也是充满激情和阳光的。正是开源精神点亮了这一切。生命中最美丽的报偿之一便是帮助他人的同时，也帮助了自己 ─ 罗夫‧瓦尔多‧爱默生 因此，将个人的经验和感悟与他人分享，成就的不仅仅是个人，更可以帮助其他人少走弯路。那么就开始分享的旅程吧！ 传统的笔记或者blog平台在本地可以用各种文档格式保存自己的技术积累，也可以采用一些市面上的blog平台作为载体来存储自己的技术文章，但这类方式存在一些弊端，这点你可以打开你的脑洞，想想有哪些，本人不是来挑起舌战的。 Github pages+Hexo+Nodejs搭建个人blog好处和缺点这里就暂不提了，请自行google。(本文仅仅是提供一种搭建Blog的方式，不牵涉任何利益方！！！) 步骤如下： 安装git：git下载，注意：Windows平台需要下载对应的安装exe,安装之后后续的命令行操作需要在GitShell中打开而非Windows默认的命令行。不过，建议直接下载Github windows客户端，安装的时候会创建GitShell(正是下文提及的GitShell)和GitHub GUI工具。 安装nodejs：node.js官网，注意：请根据自己主机的平台下载对应版本。 安装hexo及部署：hexo官网，注意：安装 Hexo 相当简单。然而在安装前，您必须确保先完成步骤1和2。Hexo网站可以选择语言为简体中文，方便使用。查看其中的文档可以看到hexo的详细使用说明，so easy！ 重点阐述下步骤3的过程(hexo的详细信息可参加hexo说明文档)： 安装hexo在Gitshell(已经安装了git并且将git加入到path环境变量中)输入： $ npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹(自行选定的文件夹folder)中新建所需要的文件。 $ hexo init folder$ cd folder$ npm install 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 本地启动server该步骤可以检验安装是否ok。如果能成功，那么恭喜你离成功更近一步了。 在Gitshell中进入前面指定的folder(建立的站点的根目录)，输入： $ hexo server 可以观察命令行的输出，然后通过浏览器打开http://localhost:4000/，成功的情况下则会看到默认的欢迎页面。 部署到github pages(点击了解Github Pages) Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 $ hexo deploy 在开始之前，您必须先在站点的配置文件_config.yml(前面建立的folder目录下)中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy: type: git repo: type: heroku repo: 这里重点提及部署到Github pages的方法(步骤)。 a.首先在Github上面创建一个新的Repository，仓库命名格式为yourname.github.io，注意：yourname是你自己定义的一个名称，后面的github.io是统一的，格式一定需要符合这个样式。b.然后，配置文件_config.yml 12345deploy: type: git repository: git@github.com:your_github_account/yourname.github.io.git branch: master message: [message] 说明： 参数 描述 repo 库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息 eg(我的Github账号是cstsinghua，而我新建的仓库名称是cstsinghua.github.io):1234deploy: type: git repository: git@github.com:cstsinghua/cstsinghua.github.io.git branch: master 注意：如果是建立项目网站，则branch需要修改为gh-pages，详细情况请参见Github pages中User, Organization, and Project Pages的差异 c.安装hexo的git插件hexo-deployer-git $ npm install hexo-deployer-git –save d.部署前面建立的站点(folder下面的内容)： 执行完，开始部署，即先hexo generate，然后hexo deploy。也可以一步到位：hexo d -g $ hexo clean $ hexo generate $ hexo deploy 或者： $ hexo d -g 注意：在这一步可能报错，已知的一些错误可以参见hexo git部署常见问题 另外，可能遇到SSH publickey接入问题，可以参见创建github SSH key和github SSH key管理 (optional)重绑定域名Custom domain redirects for GitHub Pages sites(将独立(个性)域名与GitHub Pages的空间域名绑定) yourname.github.io的域名格式比较固定，那么是否可以设置一个个性化的域名呢，另外需要注意的是Github pages的容量受限于github的要求，目前是1GB(请参见https://help.github.com/articles/what-are-github-pages/)。因此，建立一个独立的个性化(blog)网站(域名是个性化独立的，容量也可以调整)，在某些情况下还是有必要的(请参见github pages域名重定向)。 Github pages 设置：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如cstsinghua.me。 DNS设置：注册DNSpod，添加域名，不是必要的步骤，但是据说可以提高解析效率。本人没有测试。 在域名服务商，如net.cn中修改增加两条A记录，指向github pages 提供的 ip 192.30.252.153 192.30.252.154 推广一旦成功创建属于自己的blog，当然是想与他人分享，让小伙伴们都可以搜索到或者浏览自己的成果。很不幸的是，采用本文方式创建的blog默认情况下只会静静躺在互联网的一个角落，google或者百度等搜索引擎是无法知晓它的存在。因此，我们必须采用一些方式来推广自己的blog，让其他人能够通过Google或者百度等搜索引擎搜索到我们blog。 先验证博客是否被搜索引擎收录 在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的cstsinghua.github.io site:cstsinghua.github.io 如下图： 如果已被搜索引擎收录，那恭喜你，可以不用看后面的内容了。你的blog已经在互联网上飘香四溢。 在google和百度的站长管理平台验证并添加blog地址 Google站长管理平台地址 百度站长管理平台地址 这里以Google为例(百度的类似)： 1.登录google站长管理平台，在首页中点击”添加属性”按钮，然后将你的blog地址填写并添加，如下图所示： 2.blog网址添加完成之后，会跳转到验证所有权页面，验证方式有很多种，可以根据自己的情况选择，这里选择推荐的方法，即上传HTML文件的方式，其步骤在跳转的页面写得很清楚，按部就班地操作就行了(注意：先点击下载页面提示的HTML文件，报错)。如下图所示： 3.生成并提交站点地图(sitemap.xml) 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 怎么生成blog网站的站点地图呢？方式有很多种，hexo本身也自带了生成站点地图的插件。我们要先安装插件，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件： npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 在blog根目录的配置文件_config.yml中添加如下代码 1234sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 然后，修改blog根目录的配置文件_config.yml中url参数为你blog的地址，比如我的是这样： 123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://cstsinghua.github.io/ 此时，可以重新生成你的blog hexo g 如果你在你的blog根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了。当然可以采用其他很多方式来生成sitemap.xml，网上也有很多在线工具或者提供下载的本地GUI工具来生成，可以参见https://code.google.com/archive/p/sitemap-generators/wikis/SitemapGenerators.wiki，里面提供了非常多的链接地址，本人使用过https://xmlsitemapgenerator.org在线生成过。 最后，将生成的sitemap.xml提交到google站长管理平台，如下图所示： 蓝色表示sitem.xml里面上传的网页数，橙色表示已经被google加入索引(收录)的网页数，一旦被收录，这个时候就可以在google上面搜索到blog了！关于细节可以点击google站长页面上的帮助进行了解。","tags":[{"name":"搭建个人Blog","slug":"搭建个人Blog","permalink":"http://cstsinghua.github.io/tags/搭建个人Blog/"}]},{"title":"Zxing二维码开源库实战","date":"2016-06-13T07:42:25.000Z","path":"2016/06/13/ZXing开源项目实战/","text":"Zxing二维码开源库学习和优化 本文对Google官方开源的二维码扫描库ZXing做一个总体概述，然后进行Android开发环境下的实战(二次)开发和优化，并用于生产项目。 ZXing开源项目官方地址:https://github.com/zxing/zxing 前期学习和准备 各种百度和google，先了解二维码的技术概念和原理，他人经验和文章等等。以下摘自百度百科： 国外对二维码技术的研究始于20世纪80年代末，在二维码符号表示技术研究方面已研制出多种码制，常见的有PDF417、QR Code、Code 49、Code 16K、Code One等。这些二维码的信息密度都比传统的一维码有了较大提高，如PDF417的信息密度是一维码CodeC39的20多倍。在二维码标准化研究方面，国际自动识别制造商协会（AIM）、美国标准化协会（ANSI）已完成了PDF417、QR Code、Code 49、Code 16K、Code One等码制的符号标准。国际标准技术委员会和国际电工委员会还成立了条码自动识别技术委员会（ISO/IEC/JTC1/SC31），已制定了QR Code的国际标准（ISO/IEC 18004：2000《自动识别与数据采集技术—条码符号技术规范—QR码》），起草了PDF417、Code 16K、Data Matrix、Maxi Code等二维码的ISO/IEC标准草案。在二维码设备开发研制、生产方面，美国、日本等国的设备制造商生产的识读设备、符号生成设备，已广泛应用于各类二维码应用系统。二维码作为一种全新的信息存储、传递和识别技术，自诞生之日起就得到了世界上许多国家的关注。美国、德国、日本等国家，不仅已将二维码技术应用于公安、外交、军事等部门对各类证件的管理，而且也将二维码应用于海关、税务等部门对各类报表和票据的管理，商业、交通运输等部门对商品及货物运输的管理、邮政部门对邮政包裹的管理、工业生产领域对工业生产线的自动化管理。 我国对二维码技术的研究开始于1993年。中国物品编码中心对几种常用的二维码PDF417、QRCCode、Data Matrix、Maxi Code、Code 49、Code 16K、Code One的技术规范进行了翻译和跟踪研究。随着我国市场经济的不断完善和信息技术的迅速发展，国内对二维码这一新技术的需求与日俱增。中国物品编码中心在原国家质量技术监督局和国家有关部门的大力支持下，对二维码技术的研究不断深入。在消化国外相关技术资料的基础上，制定了两个二维码的国家标准：二维码网格矩阵码（SJ/T 11349-2006）和二维码紧密矩阵码（SJ/T 11350-2006），从而大大促进了我国具有自主知识产权技术的二维码的研发。 实战1. 下载ZXing并选择包 截止本文攥写之时，ZXing的最新版本为3.2.1，在Github网站上下载ZXing的主分支（zxing-master.zip），解压完成之后，目录树如下： ZXing项目解压的目录层次 以下对解压的目录结构(包含模块)的主要部分做一个概述(此处以3.2.1版本基准，不同的版本包含的模块可能稍有差异，请留意)： android Android client Barcode Scanner,中文意为“条形扫码器”，下文简称BS。可作为独立的扫码APP使用。 android-core Android-related code shared among android, androidtest, glass，即android、androidtest和glass三个模块共享的android相关库，当前其实就是一个相机配置工具类(CameraConfigurationUtils.java). android-integration Supports integration with Barcode Scanner via Intent，即通过Intent的方式提供一种便捷的途径将BS整合到用户的APP中。 androidtest Android test app, ZXing Test，即模拟调用方app(相当于用户APP的角色)，通过android-integration整合Barcode Scanner core The core image decoding library, and test code.即核心的图片编解码库，整个条形码的核心处理库，另外还包括测试代码。 glass Simple Google Glass application zxingorg The source behind zxing.org zxing.appspot.com The source behind web-based barcode generator at zxing.appspot.com javase JavaSE-specific client code 其中，与开发Android二维码扫码相关的模块有android、android-core、android-integration、androidtest和core模块。 androidtest、android-integration、android三个模块的关系图如下： 2.试用并厘清ZXing项目的源码 试用： 用Eclipse导入(按照导入现有Android工程的方式)上面所述的androidtest模块，导入之后，源代码部分会报错。主要有以下两种错误： 由于ZXing项目编写者采用的java编译版本不低于1.7.0，因此如果你的Eclipse的java编译版本设置为1.6.0或者更低版本时，将会报错，比如new ArrayList&lt;&gt;(),在1.6.0版本则不能省略具体的泛型类型，应该为new ArrayList()； 引用了大量core模块、android-integration和android-core的类，因此需要将core模块的jar包(当然也可以直接copy源码)添加到工程的构建路径(core包的下载地址:http://repo1.maven.org/maven2/com/google/zxing/core/)，另外需要将android-integration和android-core的源码复制到工程中(新建对应的package，copy类)； 按照上面步骤处理完之后，则可以运行的测试APP诞生了。工程目录图如下： 运行并安装APK至手机或模拟器，测试APP界面如下图： 可以体验扫码和生成二维码的功能。 源码分析 其实这里要关注的源码主要有四部分：core、android、android-integration和android-core，其中android-integration和android-core较为简单，这里不再赘述。而core涉及图片处理和二维码的理论技术，暂不做深入研究。 android模块即BS，可以作为单独APP使用，是一个功能强大的条码扫描器，不仅支持多种类型的条码，还支持多国语言，分享二维码，查看扫描历史，反向扫描等功能。 因此，这里主要就android模块进行分析阐述。导入Eclipse之后，android模块的包结构图如下： 如上图所示，BS主要包括下列组件： android：与CaptureActivity直接相关的核心组件。包含了发生震动管理器，闪光灯等等。 book：如果查询的结果是图书信息，用户可以选择查询该书的更进一步的详细信息，该包即包含了搜索与展示书籍的相关类。 camera/camera.open：摄像头相关组件，核心类是CameraManager clipboard：剪贴板 encode：编码功能的各个组件集合。核心类为QRCodeEncoder，最终实施编码的是MultiFormatWriter类 history：扫描历史管理，核心类是HistoryManager result：条码扫描的结果被分为不同的类型，所有的类型都定义在com.google.zxing.client.result.ParsedResultType中，对于不同的类型都有对应的处理方法：xxxResultHandler，所有的ResultHandler都包含在此包中。不同的xxxResultHandler还提供了扫描结果页面要展示几个button，每个button的文本以及需要绑定的事件等等。 result.supplement：对已经扫描并解码的结果做额外处理的工具集。比如扫描出来的是isbn号，如果在设置中选择了“检索更多信息”则会在扫描出isbn号之后自动去网上查询该书的信息，最后将书的信息展示出来，而如果没选中，则只会将isbn号码展示。 share：分享二维码功能，亦是编码功能的入口所在。 wifi：是WifiResultHandler的辅助类集合。如果扫描到的二维码是对wifi信息的编码，那么最终扫描结果页会展示一个“连接到网络”的按钮，点击此按钮就会自动尝试连接。该包中所包含的类则是链接网络所需的工具类。 打开BS，即进入扫描界面时，BS大致做了如下的事情：配置Camera并启动Camera、构建preview与扫描窗口、捕捉画面并解码、将解码结果交给不同ResultHandler去处理。下面逐一进行分析。 配置Camera并启动Camera 启动Camera是在CaptureActivity.initCamera中进行的，最重要的几句代码是： cameraManager.openDriver(surfaceHolder); // Creating the handler starts the preview, which can also throw a // RuntimeException. if (handler == null) { handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager); } CameraManager是相机管理类，是BS中唯一与Camera打交道的类，CameraManager.openDriver主要做了三件事： /** * Opens the camera driver and initializes the hardware parameters. * * @param holder * The surface object which the camera will draw preview frames * into. * @throws IOException * Indicates the camera driver failed to open. */ public synchronized void openDriver(SurfaceHolder holder) throws IOException { Camera theCamera = camera; if (theCamera == null) { // 1. 获取手机背面的摄像头 theCamera = OpenCameraInterface.open(requestedCameraId); if (theCamera == null) { throw new IOException(); } camera = theCamera; } // 2. 设置摄像头预览view theCamera.setPreviewDisplay(holder); if (!initialized) { initialized = true; configManager.initFromCameraParameters(theCamera); if (requestedFramingRectWidth &gt; 0 &amp;&amp; requestedFramingRectHeight &gt; 0) { setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight); requestedFramingRectWidth = 0; requestedFramingRectHeight = 0; } } Camera.Parameters parameters = theCamera.getParameters(); String parametersFlattened = parameters == null ? null : parameters .flatten(); // Save these, temporarily try { // 3. 读取配置并设置相机参数 configManager.setDesiredCameraParameters(theCamera, false); } catch (RuntimeException re) { // Driver failed Log.w(TAG, &quot;Camera rejected parameters. Setting only minimal safe-mode parameters&quot;); Log.i(TAG, &quot;Resetting to saved camera params: &quot; + parametersFlattened); // Reset: if (parametersFlattened != null) { parameters = theCamera.getParameters(); parameters.unflatten(parametersFlattened); try { theCamera.setParameters(parameters); configManager.setDesiredCameraParameters(theCamera, true); } catch (RuntimeException re2) { // Well, darn. Give up Log.w(TAG, &quot;Camera rejected even safe-mode parameters! No configuration&quot;); } } } } CameraConfigurationManager是相机辅助类，主要用于设置相机的各类参数。核心方法有两个： initFromCameraParameters：计算了屏幕分辨率和当前最适合的相机像素 setDesiredCameraParameters：读取配置设置相机的对焦模式、闪光灯模式等等 CaptureActivityHandler类是一个针对扫描任务的Handler，可接收的message有启动扫描（restart_preview）、扫描成功（decode_succeeded）、扫描失败（decode_failed）等等。 在创建一个CaptureActivityHandler对象的时候也做了三件事： CaptureActivityHandler(CaptureActivity activity, Collection&lt;BarcodeFormat&gt; decodeFormats, Map&lt;DecodeHintType,?&gt; baseHints, String characterSet, CameraManager cameraManager) { this.activity = activity; // 1. 启动扫描线程 decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet, new ViewfinderResultPointCallback(activity.getViewfinderView())); decodeThread.start(); state = State.SUCCESS; // Start ourselves capturing previews and decoding. this.cameraManager = cameraManager; // 2. 开启相机预览界面 cameraManager.startPreview(); // 3. 将preview回调函数与decodeHandler绑定、调用viewfinderView restartPreviewAndDecode(); } restartPreviewAndDecode方法又调用了CameraManager.requestPreviewFrame： /** A single preview frame will be returned to the handler supplied. The data will arrive as byte[] in the message.obj field, with width and height encoded as message.arg1 and message.arg2, respectively. 1：将handler与preview回调函数绑定； 2：注册preview回调函数 综上，该函数的作用是当相机的预览界面准备就绪后就会调用hander向其发送传入的message @param handler The handler to send the message to. @param message The what field of the message to be sent.*/public synchronized void requestPreviewFrame(Handler handler, int message) {Camera theCamera = camera;if (theCamera != null &amp;&amp; previewing) {previewCallback.setHandler(handler, message);/ 绑定相机回调函数，当预览界面准备就绪后会回调Camera.PreviewCallback.onPreviewFrametheCamera.setOneShotPreviewCallback(previewCallback);}} 2. 构建preview与扫描窗口 首先相机有自己的preview界面，然后我们需要构造一个扫描窗口，引导用户将条码置于窗口中完成扫描。 构造扫描窗口是在CaptureActivityHandler.restartPreviewAndDecode中，通过调用activity.drawViewfinder()来实现的。这里有个画扫描窗口的类叫ViewfinderView，该类也是想要改变扫描窗口风格所必须重构的一个类。 重构ViewfinderView涉及Android的高级话题：自定义View及其属性，这里暂不赘述。 相机的preview界面显示出来后即可开始扫描，所以需要监听preview是否已经显示这个事件，这就是Camera.PreviewCallback的作用。PreviewCallback.onPreviewFrame做的事便是当preview界面展示出来的时候向DecodeHandler发送一个decode消息，DecodeHandler收到该消息后会执行decode方法来解码。 注意，检测并触发捕获画面动作的，是Camera.setOneShotPreviewCallback()这个方法。该函数被调用后，如果预览界面已经打开，就会将包含当前preview frame的byte数组传给回调函数，此时再向DecodeHandler发送decode消息。 3. 捕捉画面并解码 具体参考DecodeHandler.decode方法。（本文只从宏观上对zxing进行分析，对于解码的原理暂不做介绍） 4. 将解码结果交给不同ResultHandler去处理 当DecodeHandler.decode完成解码后会向CaptureActivityHandler发消息。如果编码成功则调用CaptureActivity.handleDecode方法对扫描到的结果进行分类处理。 该方法中首先获取ResultHandler： ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler( this, rawResult); 然后调用handleDecodeInternally和handleDecodeExternally对ResultHandler进行处理。谈到这两个方法，就不得不再分析一下 IntentSource。 enum IntentSource { /** * 本地app向BS(Barcode Scanner)发起的启动指令 * 比如在androidtest项目中，利用整合的android-integration对BS发起调用指令：com.google.zxing.client.android.SCAN * BS中该启动命令对应的Source类型便是NATIVE_APP_INTENT */ NATIVE_APP_INTENT, /** * 打开BS的时候传入查询商品的url，与最终扫描到的product id结合进行查询 * 两种url的形式不同 */ PRODUCT_SEARCH_LINK, ZXING_LINK, /** * 直接打开BS */ NONE } 结合CaptureActivity.onResume中的部分代码来理解： else if (dataString != null &amp;&amp; dataString.contains(&quot;http://www.google&quot;) &amp;&amp; dataString.contains(&quot;/m/products/scan&quot;)) { // Scan only products and send the result to mobile Product // Search. source = IntentSource.PRODUCT_SEARCH_LINK; sourceUrl = dataString; decodeFormats = DecodeFormatManager.PRODUCT_FORMATS; } else if (isZXingURL(dataString)) { // Scan formats requested in query string (all formats if none // specified). // If a return URL is specified, send the results there. // Otherwise, handle it ourselves. source = IntentSource.ZXING_LINK; sourceUrl = dataString; Uri inputUri = Uri.parse(dataString); scanFromWebPageManager = new ScanFromWebPageManager(inputUri); decodeFormats = DecodeFormatManager .parseDecodeFormats(inputUri); // Allow a sub-set of the hints to be specified by the caller. decodeHints = DecodeHintManager.parseDecodeHints(inputUri); } NATIVE_APP_INTENT和NONE很好理解，而PRODUCT_SEARCH_LINK和ZXING_LINK是指定查询商品的url（而不是交给zxing分析后再决定去哪里查询），将扫描出来的内容拼凑到url中，然后在浏览器中展示结果。 理解了IntentSource，就容易看懂handleDecodeInternally其实就是将结果展示到界面上。handleDecodeExternally稍复杂些，当source == IntentSource.NATIVE_APP_INTENT时，BS会将扫描分析的结果存到Intent中返回给调用方app，因此调用方app在启动BS的时候一定要使用startActivityForResult。这一点可以在androidtest的IntentIntegrator.initiateScan方法的最后看到。 3.BS优化BS可直接作为独立APP运行，但是项目中的很多功能我们并不需要，而且扫描的界面为横向，因此进行相关优化。接下来，我们在BS项目工程基础上，直接修改其中代码或者xml文件，达到修改扫码界面为竖屏且美化扫码界面的目的。 修改BS默认的横屏为竖屏 针对ZXing3.2.1版本，这里一共需要6步，需要提醒的是：不同的ZXing版本需要的步骤可能有差异，因为里面的源代码逻辑有修改。因此，有的时候尽信书不如无书，本文的步骤可能仅适合ZXing3.2.1，如果在ZXing其他版本上完成以下六步无法实现竖屏，或者修改之后会出错，请仔细排查(可以断点调试跟踪)。其实，要实现竖屏，从原理上应该是共通的，主要包括Activity本身的方向(属性)设置，同时关联到相机的参数(如预览窗口)调整等方面。 第一步：调整CaptureActivity的方向为竖屏显示 修改工程的AndroidManifest.xml,CaptureActivity的android:screenOrientation属性，设置为portrait 第二步：调整相机预览界面方向 在 CameraConfigurationManager.setDesiredCameraParameters 的最后(或第一行也可)增加如下代码： //调整扫描activity为竖屏,step2.调整相机预览界面方向 camera.setDisplayOrientation(90); 注意：调整相机preview的时钟方向与手机竖屏的自然方向一致。该方法必须在相机的startPreview之前被调用， 在预览界面展示出来后设置是无效的。 第三步：调整扫描窗口尺寸 修改 CameraManager.getFramingRectInPreview()方法中的部分代码： 原代码段为： rect.left = rect.left * cameraResolution.x / screenResolution.x; rect.right = rect.right * cameraResolution.x / screenResolution.x; rect.top = rect.top * cameraResolution.y / screenResolution.y; rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y; framingRectInPreview = rect; 修改后代码段为： /* * 调整扫描activity为竖屏,step3.调整扫描窗口尺寸 * 由于修改了屏幕的初始方向，手机分辨率由原来的 width\\*height 变为 height\\*width * 形式，但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。 */ rect.left = rect.left * cameraResolution.y / screenResolution.x; rect.right = rect.right * cameraResolution.y / screenResolution.x; rect.top = rect.top * cameraResolution.x / screenResolution.y; rect.bottom = rect.bottom * cameraResolution.x / screenResolution.y; framingRectInPreview = rect; 原因：由于修改了屏幕的初始方向，手机分辨率由原来的 width*height 变为 height*width 形式， 但是相机的分辨率则是固定的，因此这里需做些调整以计算出正确的缩放比率。 第四步：将扫描框设置为正方形 修改 CameraManager.getFramingRect()方法中的部分代码： 原代码段为： int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH); int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT); Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y); int leftOffset = (screenResolution.x - width) / 2; int topOffset = (screenResolution.y - height) / 2; framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height); Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect); 修改后代码段为： /* * 调整扫描activity为竖屏,step4.将扫描框设置为正方形 */ //后面设置height = width的前提下，如x&gt;y时可能会导致topOffset为负值，因此需要对此进行修正，加入下面这行代码 int resolutionMin = Math.min(screenResolution.x, screenResolution.y); int width = findDesiredDimensionInRange(resolutionMin, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH); int height = width;//宽度等于高度，即为正方形 Log.d(TAG,&quot;screenResolution.x:&quot;+screenResolution.x+&quot;,screenResolution.y:&quot;+screenResolution.y); int leftOffset = (screenResolution.x - width) / 2; int topOffset = (screenResolution.y - height) / 2; framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height); Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect); 第五步：反转扫描到的图形 修改 DecodeHandler.decode 方法，增加以下代码： private void decode(byte[] data, int width, int height) { long start = System.currentTimeMillis(); Result rawResult = null; /* * 调整扫描activity为竖屏,step5.反转扫描到的图形 */ // 新增反转数据代码开始 byte[] rotatedData = new byte[data.length]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) rotatedData[x * height + height - y - 1] = data[x + y * width]; } int tmp = width; width = height; height = tmp; // 新增代码结束 PlanarYUVLuminanceSource source = activity.getCameraManager() .buildLuminanceSource(rotatedData, width, height); //...后续代码 } 第六步：(关键)修改CaptureActivity的onresume方法 完成以上五步后，在ZXing的某些版本上应该是可以实现竖屏了，但是在3.2.1版本上，由于在CaptureActivity 的onresume方法里面涉及到了修改activity的方向，因此需要针对性修改这部分代码。 原代码段为： if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION, true)) { setRequestedOrientation(getCurrentOrientation()); } else { setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE); } 修改后代码段为： if (prefs.getBoolean(PreferencesActivity.KEY_DISABLE_AUTO_ORIENTATION, true)) { setRequestedOrientation(getCurrentOrientation()); } else { // setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT); } 同时，需要修改getCurrentOrientation方法： 原方法为： private int getCurrentOrientation() { int rotation = getWindowManager().getDefaultDisplay().getRotation(); switch (rotation) { case Surface.ROTATION_0: case Surface.ROTATION_90: return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; default: return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE; } } 修改后为： private int getCurrentOrientation() { int rotation = getWindowManager().getDefaultDisplay().getRotation(); switch (rotation) { case Surface.ROTATION_0: case Surface.ROTATION_90: // return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; default: // return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE; return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT; } } 美化扫描界面 原生的扫描界面比较朴素，如果需要做出更漂亮些的扫描界面，就必须重写ViewfinderView类(res/layout/capture.xml布局中使用该类作为扫描窗口界面)。这里，我们为了实现类微信或支付宝的扫描界面效果，在将扫码界面修改为竖屏的基础上，可以做如下修改： 在ViewfinderView类添加变量： /** * 四个边角对应的宽度 */ private static final int CORNER_WIDTH = 8; /** * 四个边角对应的长度 */ private int ScreenRate; /** * 手机的屏幕密度 */ private static float density; /** * 四个边角的颜色 */ private final int cornerColor; /** * 扫描框中的中间线的宽度 */ private static final int MIDDLE_LINE_WIDTH = 2; /** * 扫描框中的中间线的与扫描框左右的间隙 */ private static final int MIDDLE_LINE_PADDING = 10; /** * 中间那条线每次刷新移动的距离 */ private static final int SPEEN_DISTANCE = 5; /** * 中间滑动线的最顶端位置 */ private int slideTop; /** * 中间滑动线的最底端位置 */ private int slideBottom; boolean isFirst; 修改ViewfinderView类的构造方法和onDraw方法。注：对于Android自定义View，绘制的核心就是onDraw方法。 a.在构造方法中添加初始化或设置变量的值： // This constructor is used when the class is built from an XML resource. public ViewfinderView(Context context, AttributeSet attrs) { super(context, attrs); // Initialize these once for performance rather than calling them every // time in onDraw(). paint = new Paint(Paint.ANTI_ALIAS_FLAG); Resources resources = getResources(); maskColor = resources.getColor(R.color.viewfinder_mask); resultColor = resources.getColor(R.color.result_view); laserColor = resources.getColor(R.color.viewfinder_laser); //设置添加的变量值--start cornerColor = Color.GREEN; density = context.getResources().getDisplayMetrics().density; //将像素转换成dp ScreenRate = (int)(20 * density); //设置添加的变量值--end resultPointColor = resources.getColor(R.color.possible_result_points); scannerAlpha = 0; possibleResultPoints = new ArrayList&lt;&gt;(5); lastPossibleResultPoints = null; } b.修改onDraw方法中部分代码： 修改前代码段： if (resultBitmap != null) { // Draw the opaque result bitmap over the scanning rectangle paint.setAlpha(CURRENT_POINT_OPACITY); canvas.drawBitmap(resultBitmap, null, frame, paint); } else { // Draw a red &quot;laser scanner&quot; line through the middle to show // decoding is active paint.setColor(laserColor); paint.setAlpha(SCANNER_ALPHA[scannerAlpha]); scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length; int middle = frame.height() / 2 + frame.top; canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1, middle + 2, paint); float scaleX = frame.width() / (float) previewFrame.width(); float scaleY = frame.height() / (float) previewFrame.height(); List&lt;ResultPoint&gt; currentPossible = possibleResultPoints; List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints; int frameLeft = frame.left; int frameTop = frame.top; if (currentPossible.isEmpty()) { lastPossibleResultPoints = null; } else { possibleResultPoints = new ArrayList&lt;&gt;(5); lastPossibleResultPoints = currentPossible; paint.setAlpha(CURRENT_POINT_OPACITY); paint.setColor(resultPointColor); synchronized (currentPossible) { for (ResultPoint point : currentPossible) { canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX), frameTop + (int) (point.getY() * scaleY), POINT_SIZE, paint); } } } if (currentLast != null) { paint.setAlpha(CURRENT_POINT_OPACITY / 2); paint.setColor(resultPointColor); synchronized (currentLast) { float radius = POINT_SIZE / 2.0f; for (ResultPoint point : currentLast) { canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX), frameTop + (int) (point.getY() * scaleY), radius, paint); } } } // Request another update at the animation interval, but only // repaint the laser line, // not the entire viewfinder mask. postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE, frame.top - POINT_SIZE, frame.right + POINT_SIZE, frame.bottom + POINT_SIZE); } 修改后代码段： if (resultBitmap != null) { // Draw the opaque result bitmap over the scanning rectangle paint.setAlpha(CURRENT_POINT_OPACITY); canvas.drawBitmap(resultBitmap, null, frame, paint); } else { // Draw a red &quot;laser scanner&quot; line through the middle to show // decoding is active /*paint.setColor(laserColor); paint.setAlpha(SCANNER_ALPHA[scannerAlpha]); scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length; int middle = frame.height() / 2 + frame.top; canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1, middle + 2, paint);*/ float scaleX = frame.width() / (float) previewFrame.width(); float scaleY = frame.height() / (float) previewFrame.height(); List&lt;ResultPoint&gt; currentPossible = possibleResultPoints; List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints; int frameLeft = frame.left; int frameTop = frame.top; if (currentPossible.isEmpty()) { lastPossibleResultPoints = null; } else { possibleResultPoints = new ArrayList&lt;&gt;(5); lastPossibleResultPoints = currentPossible; paint.setAlpha(CURRENT_POINT_OPACITY); paint.setColor(resultPointColor); synchronized (currentPossible) { for (ResultPoint point : currentPossible) { canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX), frameTop + (int) (point.getY() * scaleY), POINT_SIZE, paint); } } } if (currentLast != null) { paint.setAlpha(CURRENT_POINT_OPACITY / 2); paint.setColor(resultPointColor); synchronized (currentLast) { float radius = POINT_SIZE / 2.0f; for (ResultPoint point : currentLast) { canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX), frameTop + (int) (point.getY() * scaleY), radius, paint); } } } /* * 如下为了优化扫描框，绘制边角 */ paint.setColor(cornerColor); canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate, frame.top + CORNER_WIDTH, paint); canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH, frame.top + ScreenRate, paint); canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right, frame.top + CORNER_WIDTH, paint); canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right, frame.top + ScreenRate, paint); canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left + ScreenRate, frame.bottom, paint); canvas.drawRect(frame.left, frame.bottom - ScreenRate, frame.left + CORNER_WIDTH, frame.bottom, paint); canvas.drawRect(frame.right - ScreenRate, frame.bottom - CORNER_WIDTH, frame.right, frame.bottom, paint); canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom - ScreenRate, frame.right, frame.bottom, paint); /* * 如下绘制中间上下滚动的横线 */ //初始化中间线滑动的最上边和最下边 if(!isFirst){ isFirst = true; slideTop = frame.top; slideBottom = frame.bottom; } //绘制中间的线,每次刷新界面，中间的线往下移动SPEEN_DISTANCE slideTop += SPEEN_DISTANCE; if(slideTop &gt;= frame.bottom){ slideTop = frame.top; } canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint); // Request another update at the animation interval, but only // repaint the laser line, // not the entire viewfinder mask. postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE, frame.top - POINT_SIZE, frame.right + POINT_SIZE, frame.bottom + POINT_SIZE); } **注意**：上面的代码中，中间那根线微信是用的图片(图片可以自己制作，也可以反编译微信apk从中获取)，这里是画的线条，如果你想更加仿真点就将下面的代码： canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, paint); 修改为： Rect lineRect = new Rect(); lineRect.left = frame.left; lineRect.right = frame.right; lineRect.top = slideTop; lineRect.bottom = slideTop + 18; canvas.drawBitmap(((BitmapDrawable)(getResources().getDrawable(R.drawable.qrcode_scan_line))).getBitmap(), null, lineRect, paint); 4.实战并整合待续(实际使用中，一般都是应用APP包括了扫描功能，而不是将扫码功能单独作为一个APP，因此需要对BS工程进行简化，使其可以作为其他应用工程的依赖lib，并去除那些不需要的功能，然后就直接整合进APP。)","tags":[{"name":"Zxing","slug":"Zxing","permalink":"http://cstsinghua.github.io/tags/Zxing/"}]},{"title":"Eclipse动态调试Android应用指南","date":"2016-06-13T07:41:13.000Z","path":"2016/06/13/Eclipse动态调试指南/","text":"Eclipse动态调试指南本文对Eclipse进行动态调试做一个全面的讲解（动态调试还可以采用netbeans等工具，暂不阐述），旨在为广大只有apk而没有源代码的程序猿提供排查bug的另辟蹊径。 操作步骤1.反编译对目标apk使用apktool反编译出可调试的smali代码到out文件夹，目前apktool最新的版本是2.0.1。 e.g. java -jar apktool_2.0.1.jar d -d target.apk -o out 注意:-d参数是必须的，因为这样反编译出来的代码后缀均是java，因为只有java文件才能被eclipse/netbeans识别调试。 2.设置调试标记在输出的out文件夹中，用文本编辑工具打开AndroidManifest.xml，在application节点中设置属性android:debuggable=”true”。 e.g. &lt;application android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;com.boyaa.godsdk.core.MutiUnipayApplication&quot;&gt; 3.在主Activity的onCreate事件中添加调试等待(可选)注意:如果不需要在程序的开头调试的话，建议忽略这一步。 用文本编辑工具打开主类文件，找到onCreate方法，在第一句前插入invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V，记得添加a=0;//的前缀保持上下一致，结果如下： a=0;// # virtual methods a=0;// .method protected onCreate(Landroid/os/Bundle;)V a=0;// invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V a=0;// a=0;// .locals 1 a=0;// .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle; a=0;// a=0;// .prologue a=0;// .line 11 a=0;// invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V 4.保存文件，用apktool重新编译打包为debug.apke.g. java -jar apktool_2.0.1.jar b -d out -o debug.apk 5.对debug.apk签名(建议采用安卓逆向助手)，生成debug_sign.apk当然也可以直接采用JDK里面的签名工具通过命令行手动进行签名： e.g. “jarsigner” -keystore “C:\\Users\\CoulsonChen\\Desktop\\kop.keystore” -storepass “kop1122334” -keypass “kop1122334” “D:\\t\\125.apk” “kop” -sigalg SHA1withRSA -digestalg SHA1 6.上传debug_sign.apk至手机或模拟器，然后安装并运行。如果启用第3步，这时你会看到程序运行后停留在白屏界面，这时不要动设备和退出程序，因为程序现在是运行到刚才添加的waitForDebugger代码这里，这行代码的意思是一直挂起中，等待调试器。 如果未启用第3步，则apk正常运行(与普通安装apk无异)。 7.启动eclipse，构建java项目 File -&gt; New -&gt; Project -&gt; Java Project -&gt; Next Project Name随便起，Use default location选项去掉，Location选择第1步指定的out文件夹，然后Next 把smali文件夹设为Source Folder，然后Finish 8.在eclipse中，在需要关注的地方添加断点设置断点示例： 设置断点示意图 打开DDMS（路径在%android-sdks%\\tools\\ddms.bat）,如果在第6步中运行了修改后的程序，在DDMS的设备列表中会显示可以调试的程序。 DDMS的设备列表 从上图可以看到，调试的端口为8608 9.现在要做的就是把代码与调试程序关联即可回到eclipse，配置远程调试 菜单Run -&gt; Debug -&gt; Debug Configurations 双击Remote Java Application，Host处默认localhost就行，Port填第9步得到的8608，然后Apply -&gt; Debug。 示意图： 关联源码和程序 10.切换至debug视图看到程序已经运行并中断在下一行可执行的代码了，相关的变量可以直接查看了。示意图： 最终调试","tags":[{"name":"动态调试","slug":"动态调试","permalink":"http://cstsinghua.github.io/tags/动态调试/"}]},{"title":"apktool打包之后apk包体变大","date":"2016-06-13T07:40:18.000Z","path":"2016/06/13/apktool打包之后包体变大/","text":"apktool重(编译)打包之后apk包体变大原因原因：应该是apktool 2.0.3版本之后引入了两个字段 compressionType: doNotCompress: 这两个字段会决定重新编译apk时哪些类型的文件不会压缩，从而影响最终生成的apk的包体大小。 解决办法一：调整不压缩的文件类型请对比apktool 2.0.1和2.1.1版本反编译之后目录下的apktool.yml文件： 2.0.1： 2.1.1： 因此，可以动态调整doNotCompress字段中不压缩的文件类型(比如删除图中的- lua行)，来达到压缩的效果，从而使得包体大小保持与原有大小基本一致。 解决办法二：利用apktool低版本及apktool高版本释放的1.apk既然apktool 2.0.1及其之下版本未引入doNotCompress字段，那么可以采用高版本的apktool释放的1.apk(framework)来作为apktool 2.0.1及其之下版本重编译时的框架依赖。这样可以解决2.0.1重编译依赖Android6.0系统特性的apk失败的问题。 举例：首先用apktool 2.0.1反编译target.apk，然后将更高版本的apktool释放(反编译操作时候就会自动释放出来)的1.apk覆盖掉apktool 2.0.1的1.apk，1.apk文件一般放在Home_dir\\apktool\\framework\\1.apk,其中Home_dir是操作系统的默认Home目录，windows平台可以打开cmd，提示的目录即为Home_dir。当然也可以采用Everything搜索等工具全局搜索下就知道其路径了。最后，用apktool 2.0.1版本重新编译target.apk反编译时生成的目录，即可编译成功。","tags":[{"name":"apktool","slug":"apktool","permalink":"http://cstsinghua.github.io/tags/apktool/"},{"name":"Apktool打包","slug":"Apktool打包","permalink":"http://cstsinghua.github.io/tags/Apktool打包/"},{"name":"apk","slug":"apk","permalink":"http://cstsinghua.github.io/tags/apk/"},{"name":"size","slug":"size","permalink":"http://cstsinghua.github.io/tags/size/"}]},{"title":"Android热修复","date":"2016-06-13T07:38:15.000Z","path":"2016/06/13/Android热修复的思路/","text":"Android热修复的方式关于动态热修复，目前发现的思路集中在三点： 方式1：既然是热修复，那么就是新的类替换掉旧的类，而java世界类的加载是通过类加载器来实现，而Android应用程序的默认类加载器PathClassLoader加载的时候其实是通过关联的DexFile来实现(动态加载的时候已经反复涉及，这里不再赘述)，当有多个Dex文件的时候，是按照dexElements中的顺序来执行，如果一旦加载到则返回该类，否则遍历查询dexElements中的所有元素，直到最终查询完，那么基于这个事实，则可以将新类的dex文件加载的时候对应的Element放置在最前面，这样PathClassLoader加载的时候就自然先加载到新类而不是旧的有问题的类，但是这种机制在多个mutildex时存在缺陷，具体请参见下面转发链接的阐述，另外一旦某个类已经被加载，则失效了，因为一旦被加载之后，PathClassLoader的loadClass已经直接返回class而不会去查询，这样使得往往下载修复包之后需要在下次启动才能加载。当然这个办法基于纯java实现，非侵入性，与平台无关； 方式2：基于阿里的AndFix开源项目，这个的出发点是另外一个角度，类被类加载器加载进来之后，那么其实本质还是虚拟机在管理，而根据java虚拟机包括Dalvik虚拟机的内存模型(可以查看我那本深入理解java虚拟机书籍相关章节)，类的class文件加载进来之后存放在方法区，那么既然已经认定这个类被加载了，怎么做到热修复，阿里的方式确实巧妙，因为java虚拟机本身是C++语言实现的，通过JNI的方式可以获取到方法区中方法的引用，修改方法内部的执行引用，具体的还需要更加深入研究，将方法的执行逻辑指向了新方法，这种情况下可以做到及时加载及时修复，不用重启应用，缺点是通过JNI方式，so的兼容性决定了适用性，不过阿里的做得已经不错，当然一旦Android平台的虚拟机内部实现改变，就需要重新修改so对应的C++代码，目前首选这个方式； 另外，生成新旧dex的patch也是一个关键点，阿里提供了这样一个工具：AppPatch。生成patch的过程，大概是基于smali和baksmali，先加载新的和旧的两个dex文件得到所有的class，然后通过getImplementation()方法可对比他们的方法实现是否一致，将对比结果分成添加的方法/字段和修改的方法/字段分别保存起来，在重新生成的差异化dex文件时，根据对比结果在相应的方法或者字段前添加注解标志。要深入理解的话需要熟悉一下smali/baksmali的源码以及dalvik虚拟机的文件结构。 方式3：阿里的Dexposed开源项目，也是纯java实现，基于大名鼎鼎的 Xposed framework project开源项目，面向AOP切面编程的思想，目前还没有很深入研究，可能与方式1有些类似，也可能基于动态代理等方式来做到。不过目前这个项目只能适用于5.0以下系统，目前不建议使用。 链接 关于方式1： http://blog.csdn.net/lzyzsd/article/details/49843581， https://github.com/jasonross/Nuwa 关于方式2： https://github.com/alibaba/AndFix 关于方式3： https://github.com/alibaba/dexposed","tags":[{"name":"Android热修复","slug":"Android热修复","permalink":"http://cstsinghua.github.io/tags/Android热修复/"}]},{"title":"Android动态加载机制","date":"2016-06-13T07:36:18.000Z","path":"2016/06/13/Android动态加载机制/","text":"1.引言在Android开发中，存在一些场景： 在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？ 引用官方原文http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about： `Both these error conditions display a common number: 65,536. This number is significant in that it represents the total number of references that can be invoked by the code within a single Dalvik Executable (dex) bytecode file. If you have built an Android app and received this error, then congratulations, you have a lot of code! This document explains how to move past this limitation and continue building your app.` 众所周知，Android进行反编译APK获取其中的资源和代码相对比较容易，那么在某些特定场景和功能，开发者不希望其核心代码被他人轻易反编译破解，此时应该怎么办？安全方面的考虑，比如in-app purchase？ 随着Android的发展，应用的功能越来越多，越来越复杂，其APK大小也跟随着膨胀，而APK的大小影响着用户的接受程度，许多应用市场也会限制上传包的大小，如何做到既减小APK的大小，同时又可以扩展更多功能？扩展考虑？ 其他？热插拔？类似插件的机制？… 以上的问题自然就引出一个概念，能不能动态地加载Android代码或者资源，甚至动态加载APK执行？ 答案是肯定的！熟悉Java的朋友应该了解JVM可以动态加载类，核心思想是通过ClassLoader加载本地的或者从网络传输获得的类代码，从而可以在运行时动态加载类。Android平台的应用开发主要采用Java语言，而dalvik虚拟机的类加载机制类似于JVM。 本文先介绍JVM的类加载原理，讲述Java最基本的类加载机制，为Android类加载做铺垫。然后，重点介绍Android的类加载机制，及常见的实现方式。最后，在前面的基础上，扩展开来，从Android的类加载引申到更广泛的层面上，即动态加载机制(插件机制)、安全方面。从这里可以看到，整个发展历程成阶梯上升，前面的是基础也是基石，而越到后面才是实际开发中更常见的场景，也是更加复杂和综合的应用。概括之，Android的动态加载机制发展历程：普通的类(Class文件)加载-&gt;普通jar包(包含dex)加载-&gt;包含资源的jar加载-&gt;直接加载其他应用程序APK。 2.JVM的类加载机制Java的类(class)文件是通过类加载器来加载的，每一个类加载器，都拥有一个独立的类名称空间，因此，只有比较两类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 注意：上面提及的“相等”概念，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象关系判断等情况。 2.1 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器均由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。 从Java程序员的角度来看，类加载器划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器： 启动类加载器(Bootstrap ClassLoader):这个类加载器负责将存放在/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可。 扩展类加载器(Extension ClassLoader)：该加载器由sun.misc.Launcher$ExtClassLoader实现，其负责加载/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器(Application ClassLoader)：该类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般也称它为系统类加载器。其负责加载用户类路径(ClassPath)上所指定的库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的关系一般如下图所示： ClassLoader之间关系 上图中的这种层次关系，被称为类加载器的双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合的关系来复用父类加载器的代码。 类加载器的双亲委派模型在JDK1.2期间被引入并被广发应用于之后的几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。 双亲委派模型的工作过程：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。 类加载由类加载器的loadClass方法执行，而实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass方法之中，如下面代码(基于JDK 1.7版本的源码)所示，其逻辑为：先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法执行自定义的加载过程。 /** * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;. The * default implementation of this method searches for classes in the * following order: * * &lt;p&gt;&lt;ol&gt; * * &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class * has already been loaded. &lt;/p&gt;&lt;/li&gt; * * &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method * on the parent class loader. If the parent is &lt;tt&gt;null&lt;/tt&gt; the class * loader built-in to the virtual machine is used, instead. &lt;/p&gt;&lt;/li&gt; * * &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the * class. &lt;/p&gt;&lt;/li&gt; * * &lt;/ol&gt; * * &lt;p&gt; If the class was found using the above steps, and the * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object. * * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override {@link * #findClass(String)}, rather than this method. &lt;/p&gt; * * &lt;p&gt; Unless overridden, this method synchronizes on the result of * {@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;} method * during the entire class loading process. * * @param name * The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class * * @param resolve * If &lt;tt&gt;true&lt;/tt&gt; then resolve the class * * @return The resulting &lt;tt&gt;Class&lt;/tt&gt; object * * @throws ClassNotFoundException * If the class could not be found */ protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 2.2 类加载过程类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)，这7个阶段顺序如下图所示： ClassLoading 上图中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地执行，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也被称为动态绑定或晚期绑定)。 3.Android中的类加载机制Android的类加载机制与JVM的类加载机制类似。也采用了双亲委派模型。Android系统定义的ClassLoader相关类的架构如下图所示： Android的ClassLoader架构 如上图所示，ClassLoader是整个类加载器的顶层类，其为抽象类，实现了类加载器所要求的通用架构。Android中提供了几个该类的具体实现类，比如dalvik.system.PathClassLoader，应用程序可以实现ClassLoader来提供加载类的特殊方式。 3.1 Android中的主要类加载器介绍从上图可知，java.lang.ClassLoader是类加载器的顶层类，dalvik.system.BaseDexClassLoader是为各种基于dex的类加载器的实现提供一个基本功能的基类。其子类dalvik.system.PathClassLoader和dalvik.system.DexClassLoader是我们关注的重点，负责具体的类加载。 dalvik.system.PathClassLoader Android源码的解释是： Provides a simple ClassLoader implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s). 大意是，PathClassLoader可以加载包含在本地文件系统中的文件和目录列表中代码和资源，但是无法从网络加载类。Android本身采用该类加载器作为其系统的和应用程序的默认类加载器，换句话说，Android系统的框架层的类和应用程序默认情况下的类加载均有该类来完成。那么要实现自定义的类加载器，采用该类就不太可行了，那只能另辟蹊径。 dalvik.system.DexClassLoader Android源码的解释是： A class loader that loads classes from .jar and .apk files containing a classes.dex entry. This can be used to execute code not installed as part of an application. This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getCodeCacheDir() to create such a directory: File dexOutputDir = context.getCodeCacheDir(); Do not cache optimized classes on external storage. External storage does not provide access controls necessary to protect your application from code injection attacks. 从上面说明不难看出，DexClassLoader可以从包含dex的jar或者apk文件中加载类和资源，用于加载应用程序非安装时附带的代码。这恰恰就是我们所需要的，因为我们希望在应用运行期间，动态地从文件系统或者从网络下载包含dex的文件，然后加载进内存执行。 请注意：DexClassLoader需要提供一个目录用于缓存优化的class文件，因此为了安全，请将该目录设置为应用程序私有的目录，不要采用外部存储目录。 DexClassLoader有一个构造方法： public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) 其中，dexPath为包含dex的jar或者apk的存放路径，optimizedDirectory代表存放优化的dex的目录，libraryPath代表本地代码存放的路径，parent指定父加载器，一般采用Context调用getClassLoader()获取并传入，如果传入null，则采用启动类加载器作为父加载器。 DexClassLoader负责加载类的方法仍是继承自ClassLoader的loadClass方法： Class&lt;?&gt; java.lang.ClassLoader.loadClass(String className) throws ClassNotFoundException 3.2 DexClassLoader加载类示例既然我们可以直接使用DexClassLoader来动态加载应用程序外部的dex，那么这个过程具体是怎样的呢，且看下文分解。 3.2.1 DexClassLoader加载示例1本示例来自Google官方blog，具体地址为http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html，源码也可以从该网址中的链接下载http://code.google.com/p/android-custom-class-loading-sample，本文另外提供一个地址下载(本文作者修改后在本地运行的版本，主要涉及修改里面的local.properties，配置本地的Android SDK tools的安装目录)，下载请点击：本地Sample下载 这里摘录其中的步骤，并做一个简单描述。 代码结构： 该应用程序包含三个类： com.example.dex.MainActivity: 调用库代码的UI组件 com.example.dex.LibraryInterface: 库代码API的接口定义 com.example.dex.lib.LibraryProvider: lib库的实现 lib库打包进第二个dex, 而剩下的类被装入主dex(也就是默认的dex)。下面的构建章节详细地阐述了怎么实现这个目的。当然，实际情况下的的打包的策略依赖于开发者实际要处理的特定场景。 类加载和方法调用： 包含lib库的第二个dex文件，存储在应用程序的assets目录。首先，第二个dex文件必须复制到类加载可以直接加载的文件路径(Android内核是Linux，则path的形式与普通的linux文件路径类似)，本示例代码采用应用APP的私有内部储存区域来存放该dex(从技术层面来说，外部存储也可以满足需求，但是考虑到安全性，建议保存在内部存储)。 如下是MainActivity的代码片段。 // Before the secondary dex file can be processed by the DexClassLoader, // it has to be first copied from asset resource to a storage location. File dexInternalStoragePath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE), SECONDARY_DEX_NAME); ... BufferedInputStream bis = null; OutputStream dexWriter = null; static final int BUF_SIZE = 8 * 1024; try { bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME)); dexWriter = new BufferedOutputStream( new FileOutputStream(dexInternalStoragePath)); byte[] buf = new byte[BUF_SIZE]; int len; while((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) { dexWriter.write(buf, 0, len); } dexWriter.close(); bis.close(); } catch (. . .) {...} 下一步，初始化创建一个DexClassLoader去加载从第二个dex中提取出来的库。有几种方式可以调用加载类的方法。在本示例中，类实例被强制转换成其实现的接口，这样就通过调用接口中定义的方法直接调用。这样的方式更方便，当然，通过反射获取Method，然后Method调用invoke方法也是可行，但反射更加复杂且比较慢。但利用反射也有其优点，即不需要第二个dex文件中的lib库实现特定的接口。 // Internal storage where the DexClassLoader writes the optimized dex file to final File optimizedDexOutputPath = getDir(&quot;outdex&quot;, Context.MODE_PRIVATE); DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(), optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader()); Class libProviderClazz = null; try { // Load the library. libProviderClazz = cl.loadClass(&quot;com.example.dex.lib.LibraryProvider&quot;); // Cast the return object to the library interface so that the // caller can directly invoke methods in the interface. // Alternatively, the caller can invoke methods through reflection, // which is more verbose. LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance(); lib.showAwesomeToast(this, &quot;hello&quot;); } catch (Exception e) { ... } 构建过程(build process) 为了生成两个独立的dex文件，我们需要调整标准的构建过程。为了实现该技巧，可以简单地修改工程的Ant构建配置文件build.xml中到的”dex” target标签。 修改后的”dex” target标签执行下列操作： a. 创建两个存储目录，用于存储默认dex和第二个dex； b. 选择性地从PROJECT_ROOT/bin/classes复制class文件至上面的两个目录； &lt;!-- Primary dex to include everything but the concrete library implementation. --&gt; &lt;copy todir=&quot;${out.classes.absolute.dir}.1&quot; &gt; &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt; &lt;exclude name=&quot;com/example/dex/lib/**&quot; /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;!-- Secondary dex to include the concrete library implementation. --&gt; &lt;copy todir=&quot;${out.classes.absolute.dir}.2&quot; &gt; &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt; &lt;include name=&quot;com/example/dex/lib/**&quot; /&gt; &lt;/fileset&gt; &lt;/copy&gt; c.将上述两个目录中的.class文件转换成两个独立的dex文件； d.将第二个dex文件添加到一个jar文件中，jar文件是DexClassLoader期望的输入格式(其实只要里面包含dex即可)。最后，存储该jar文件至工程的assets目录。 &lt;!-- Package the output in the assets directory of the apk. --&gt; &lt;jar destfile=&quot;${asset.absolute.dir}/secondary_dex.jar&quot; basedir=&quot;${out.absolute.dir}/secondary_dex_dir&quot; includes=&quot;classes.dex&quot; /&gt; 为了达成上面的构建目的，需要在工程目录下执行&quot;ant debug&quot;或者&quot;ant release&quot;命令(前提是需要下载apache的[Ant构建工具](https://www.apache.org/dist/ant/ &quot;Ant&quot;)，且不能使用Eclipse的自动构建方式)。 3.2.2 DexClassLoader加载示例2示例1主要是定制了ant的构建过程，这样在生成apk的时候已经对class文件加以分割，生成了独立的多个dex文件，并且自动地放入了apk的assets目录。运行时，非默认dex采用DexClassLoader加载。如果觉得修改Eclipse自动构建过程麻烦(主要是需要配置build.xml)，更直观的方式是，新建一个空工程，将lib库的包copy进去，编译该工程，会在工程的bin目录下生成代码相关的jar文件，再利用dex2jar工具将jar转换成第二个dex即可，将第二个dex放入工程的assets目录，其他步骤与示例1完全一致。或者，直接新建的工程，从生成的apk从提取dex(即第二个dex)，然后放入工程的assets目录，其他方面别无二样。 3.3 DexClassLoader加载的缺点，类加载的进一步探索从上面的示例和DexClassLoader的API不难发现，DexClassLoader加载类的时候必须知道dex path，而且需要指定存放优化的dex目录，这就是说，DexClassLoader工作前提是必须将dex存放在文件系统中，虽然可以存放在应用程序私有的目录中，但是一旦黑客绕过这道Android系统的文件权限管理的篱笆，那么就能获取到dex文件，然后反编译并获取其中的内容。所以，DexClassLoader这样的加载机制存在安全问题。那么，怎么样回避这个问题呢？ 一个直观的方法，就是能不能直接对dex文件进行加密，这样即使保存在文件系统，其他人要想破解则必须先解密dex。但是，一旦加密dex，那么在加载的时候也必须先进行解密，解密的过程如果用java来完成，那仍然是不安全的。另外，优化的dex仍然需保存在文件系统中，这还是不可行。 从上面讲述的类加载的双亲委派模型可知，一个类加载器，先委派父类加载器去加载，如果无法加载，则调用自身的findClass方法去按照自定义方式加载类。关键就在于此，其实DexClassLoader替我们处理好了底层的封装细节，我们只是调用了DexClassLoader的loadClass方法而已。那么，要想突破DexClassLoader的缺陷，也就不得不深入研究下DexClassLoader本身的loadClass和findClass方法，从中寻找蛛丝马迹，抑或一种启发，进而编写属于我们自己的DexClassLoader。 其实，Android4.0版本增加了对内存中DEX数据的动态加载(稍后看源码可以确认这一点)，这样就克服了使用DexClassLoader时DEX以文件形式明文存放在存储设备上的缺点，内存中DEX数据可以来源于解密后的文件或者网络。这样就增加了DEX数据的安全性。但是DexClassLoader并没有暴露该种加载方式。开发者需要在JAVA层实现自己的Dex ClassLoader。本文提供两个Android源码下载的链接地址： Android官方下载地址：https://android.googlesource.com Web在线浏览及下载地址：http://androidxref.com DexClassLoader的源码(下面基于ICS4.0.3的源码)： /** * A class loader that loads classes from {@code .jar} and {@code .apk} files * containing a {@code classes.dex} entry. This can be used to execute code not * installed as part of an application. * * &lt;p&gt;This class loader requires an application-private, writable directory to * cache optimized classes. Use {@code Context.getDir(String, int)} to create * such a directory: &lt;pre&gt; {@code * File dexOutputDir = context.getDir(&quot;dex&quot;, 0); * }&lt;/pre&gt; * * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt; * External storage does not provide access controls necessary to protect your * application from code injection attacks. */ public class DexClassLoader extends BaseDexClassLoader { /** * Creates a {@code DexClassLoader} that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * {@code path.separator} system property, which defaults to {@code :}. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } 可以看出，DexClassLoader本身没有任何逻辑，只是继承了BaseDexClassLoader，并提供了一个构造器而已。 BaseDexClassLoader源码： /** * Base class for common functionality between various dex-based * {@link ClassLoader} implementations. */ public class BaseDexClassLoader extends ClassLoader { /** originally specified path (just used for {@code toString()}) */ private final String originalPath; /** structured lists of path elements */ private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.originalPath = dexPath; this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { Class clazz = pathList.findClass(name); if (clazz == null) { throw new ClassNotFoundException(name); } return clazz; } @Override protected URL findResource(String name) { return pathList.findResource(name); } @Override protected Enumeration&lt;URL&gt; findResources(String name) { return pathList.findResources(name); } @Override public String findLibrary(String name) { return pathList.findLibrary(name); } /** * Returns package information for the given package. * Unfortunately, instances of this class don&apos;t really have this * information, and as a non-secure {@code ClassLoader}, it isn&apos;t * even required to, according to the spec. Yet, we want to * provide it, in order to make all those hopeful callers of * {@code myClass.getPackage().getName()} happy. Thus we construct * a {@code Package} object the first time it is being requested * and fill most of the fields with dummy values. The {@code * Package} object is then put into the {@code ClassLoader}&apos;s * package cache, so we see the same one next time. We don&apos;t * create {@code Package} objects for {@code null} arguments or * for the default package. * * &lt;p&gt;There is a limited chance that we end up with multiple * {@code Package} objects representing the same package: It can * happen when when a package is scattered across different JAR * files which were loaded by different {@code ClassLoader} * instances. This is rather unlikely, and given that this whole * thing is more or less a workaround, probably not worth the * effort to address. * * @param name the name of the class * @return the package information for the class, or {@code null} * if there is no package information available for it */ @Override protected synchronized Package getPackage(String name) { if (name != null &amp;&amp; !name.isEmpty()) { Package pack = super.getPackage(name); if (pack == null) { pack = definePackage(name, &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;, &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;, null); } return pack; } return null; } @Override public String toString() { return getClass().getName() + &quot;[&quot; + originalPath + &quot;]&quot;; } } 分析得之，BaseDexClassLoader覆写了ClassLoader的findClass方法(loadClass方法根据前面所述的双亲委派模型介绍可知是实现双亲委派模型的基础，官方是建议不要修改该方法，而覆写findClass方法)。findClass方法中其实是调用pathList.findClass(name)，而pathList是DexPathList类的实例，那么接着跟踪进入DexPathList的源码。 DexPathList的源码(findClass方法)： /** * Finds the named class in one of the dex files pointed at by * this instance. This will find the one in the earliest listed * path element. If the class is found but has not yet been * defined, then this method will define it in the defining * context that this instance was constructed with. * * @return the named class or {@code null} if the class is not * found in any of the dex files */ public Class findClass(String name) { for (Element element : dexElements) { DexFile dex = element.dexFile; if (dex != null) { Class clazz = dex.loadClassBinaryName(name, definingContext); if (clazz != null) { return clazz; } } } return null; } 在这里，发现其实又调用DexFile dex.loadClassBinaryName(name, definingContext),根据进入DexFile的源码。 DexFile的源码(loadClassBinaryName方法)： /** * Opens a DEX file from a given filename. This will usually be a ZIP/JAR * file with a &quot;classes.dex&quot; inside. * * The VM will generate the name of the corresponding file in * /data/dalvik-cache and open it, possibly creating or updating * it first if system permissions allow. Don&apos;t pass in the name of * a file in /data/dalvik-cache, as the named file is expected to be * in its original (pre-dexopt) state. * * @param fileName * the filename of the DEX file * * @throws IOException * if an I/O error occurs, such as the file not being found or * access rights missing for opening it */ public DexFile(String fileName) throws IOException { mCookie = openDexFile(fileName, null, 0); mFileName = fileName; guard.open(&quot;close&quot;); //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie); } ... /** * See {@link #loadClass(String, ClassLoader)}. * * This takes a &quot;binary&quot; class name to better match ClassLoader semantics. * * @hide */ public Class loadClassBinaryName(String name, ClassLoader loader) { return defineClass(name, loader, mCookie); } private native static Class defineClass(String name, ClassLoader loader, int cookie); 最终，通过JNI调用了本地方法defineClass(String name, ClassLoader loader, int cookie)。在实例化DexFile类的时候，在构造方法里面， 关键处为mCookie = openDexFile(fileName, null, 0)，这里即将dex文件打开并加装，而在DexFile里面还有几个方法： /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ native private static int openDexFile(String sourceName, String outputName, int flags) throws IOException; /* * Open a DEX file based on a {@code byte[]}. The value returned * is a magic VM cookie. On failure, a RuntimeException is thrown. */ native private static int openDexFile(byte[] fileContents); /* * Close DEX file. */ native private static void closeDexFile(int cookie); 上面这些本地方法实现是在/dalvik/vm/native/dalvik_system_DexFile.cpp里面。native private static int openDexFile(byte[] fileContents)方法正是Android 4.0之后引入的，即前面所述的增加了对内存中DEX数据的动态加载。byte[] fileContents可以来自于网络或者解密dex文件。利用这一点，开发者可以解决DexClassLoader的缺点。 3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1通过上面内容，我们知道DexClassLoader自身加载类的逻辑实质上是通过DexFile类的loadClassBinaryName方法(该方法被隐藏)完成，而该方法最终调用dalvik_system_DexFile.cpp里面的本地方法defineClass来完成，同时DexFile的实例化调用了dalvik_system_DexFile.cpp里面的openDexFile方法来完成文件加载。 DexFile加载类的关键：defineClass和openDexFile方法，因为安全方面考虑，自然我们这里选择的openDexFile方法是openDexFile(byte[] fileContents)。 实现自定义的DexClassLoader，那么原理上我们可以通过反射调用DexFile的defineClass和openDexFile方法。首先，从本地获取或者从网络获取到dex文件的字节流byte[] fileContents，然后反射调用openDexFile(byte[] fileContents)获得magic VM cookie值，最后反射调用defineClass(String name, ClassLoader loader, int cookie)返回加载的Class。 3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2该方法参考http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf 自定义DexClassLoader方式1存在一个问题，即dex的字节流存在Java层，因此相对来说还是不够安全。这种需求下，就需要开发者直接通过JNI调用底层函数解析。在dalvik_system_DexFile.cpp中，定义了DalvikNativeMethod： const DalvikNativeMethod dvm_dalvik_system_DexFile[] = { { &quot;openDexFile&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;I)I&quot;, Dalvik_dalvik_system_DexFile_openDexFile }, { &quot;openDexFile&quot;, &quot;([B)I&quot;, Dalvik_dalvik_system_DexFile_openDexFile_bytearray }, { &quot;closeDexFile&quot;, &quot;(I)V&quot;, Dalvik_dalvik_system_DexFile_closeDexFile }, { &quot;defineClass&quot;, &quot;(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;&quot;, Dalvik_dalvik_system_DexFile_defineClass }, { &quot;getClassNameList&quot;, &quot;(I)[Ljava/lang/String;&quot;, Dalvik_dalvik_system_DexFile_getClassNameList }, { &quot;isDexOptNeeded&quot;, &quot;(Ljava/lang/String;)Z&quot;, Dalvik_dalvik_system_DexFile_isDexOptNeeded }, { NULL, NULL, NULL }, }; OnLoad method + dlsym获取Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法指针 JNINativeMethod *dvm_dalvik_system_DexFile; JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { void *ldvm = (void*)dlopen(&quot;libdvm.so&quot;, RTLD_LAZY); dvm_dalvik_system_DexFile = (JNINativeMethod*)dlsym(ldvm, &quot;dvm_dalvik_system_DexFile&quot;); void (*openDexFile)(const u4* args, JValue* pResult); lookup(openDexFile, &quot;dvm_dalvik_system_DexFile&quot;, &quot;([B)I&quot;, &amp;openDexFile); } int lookup (JNINativeMethod *table, const char *name, const char *sig, void (**fnPtrout) (u4 const *, union JValue *)) { int i = 0; while (table[i].name != NULL) { if ( (strcmp(name, table[i].name) == 0) &amp;&amp; (strcmp(sig, table[i].signature) == 0) ) { *fnPtrout = table[i].fnPtr; return 1; } i++; } return 0; } 调用Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析Dex数据 ArrayObject *ao; // header+dex content u4 args[] = { (u4)ao }; JValue pResult ; jint result ; openDexFile(args, &amp;pResult); result = (jint)pResult.l; return result; 第三步实现JAVA层Dex ClassLoader完成类的加载： int cookie = openDexFile(...); Class&lt;?&gt; cls = null; String as[] = getClassNameList(cookie); for(int z=0; z&lt;as.length; z++) { if(as[z].equals(&quot;com.immunapp.hes2013.MainActivity&quot;)) { cls=defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie ); } else { defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie ); } 3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3该方式源自http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf 自定义DexClassLoader方式2也存在确定，即只支持Android4.0以上系统，因为Android4.0系统才在底层引入了Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析。要想克服这个问题，就需要自修改Dalvik字节码(即按照上面dalvik_system_DexFile.cpp的逻辑，我们自定义实现其逻辑)。大致流程如下(由于本文作者对C++不熟悉，因此只能是浅尝辄止，有兴趣的开发者可以自行实践)。 搜索内存查找DEX特征（dex\\n035） 读取/proc/self/maps文件获取dex map地址,它将以_SC_PAGESIZE内存页对齐, 相对Map开始地址偏移0x28 DEX格式解析(请参考https://source.android.com/tech/dalvik/dex-format.html) 找到代码正确的位置 第一步定位到具体类，第二步定位到具体方法，获取方法字节码相对data section偏移量。 解锁内存 mprotect((unsigned char*)aligned,PROT_WRITE | PROT_READ, len); 修改相应的代码 memcpy((unsigned char*)code_off,opcodes, len); 这里提供一个示例，下载地址：自修改Dalvik字节码实现Dex加载Sample 4.Android动态加载引申前面提到，Android动态加载机制的发展历程，随着需求的扩展，人们不仅仅满足于加载jar，还希望加载包含资源的jar甚至直接加载第三方APK，这样就带来更强的扩展性。我们知道，正常情况下，Android应用的APK需要安装注册，然后才能运行，怎样才能通过宿主程序打开别的APK呢，就如同通过安装运行一样。 很明显，前提仍然是类和资源的动态加载，即前面章节描述的内容。但是仅仅做到这些不够，还有很多问题需要解决： 需加载的apk中的资源怎样引用？ 需加载的apk的界面就算被加载，怎么与用户交互? 怎样管理加载的APK中的组件的生命周期？ …等等… 需求产生动力，有了动力就有才能的发挥。聪明的人们自然会想到各种办法解决这些问题。当前，BAT等公司都有自己成熟的动态加载机制，但是不是开源的。而开源的加载机制方面，比较有影响的有：dynamic-load-apk和360的DroidPlugin。 开发者如果对动态加载APK感兴趣，建议深入研究上述的开源项目，这里就不再赘述其中的原理了。里面很多思路值得借鉴，但同时还有很大的完善空间，发挥你的聪明才智，试试吧。","tags":[{"name":"动态加载","slug":"动态加载","permalink":"http://cstsinghua.github.io/tags/动态加载/"}]},{"title":"Android安装APK详解","date":"2016-06-13T07:34:37.000Z","path":"2016/06/13/Android安装APK详解/","text":"引言众所周知，Android应用最终是打包成.apk格式（其实就是一个压缩包），然后安装至手机并运行的。APK即Android Package的缩写，那么，Android安装应用APK的具体方式及其详细过程是怎样的呢？下面，我们逐一揭开里面的层层面纱。 Android应用APK安装的方式一般而言，Android应用安装有如下四种方式： 系统应用安装：开机时加载系统的APK和应用，没有安装界面； 网络下载应用安装：通过各种market应用完成，没有安装界面； ADB工具安装：即通过Android的SDK开发tools里面的adb.exe程序安装，没有安装界面； 第三方应用安装：通过SD卡里的APK文件安装(比如双击APK文件触发)，有安装界面，系统默认已经安装了一个安装卸载应用的程序，即由packageinstaller.apk应用处理安装及卸载过程的界面。Android APK安装概述应用安装涉及到的目录 /system/app ：系统自带的应用程序，获得adb root权限才能删除 /data/app ：用户程序安装的目录。安装时把apk文件复制到此目录 /data/data ：存放应用程序的数据 /data/dalvik-cache：将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,当然，ART–Android Runtime的可执行文件格式为oat，启用ART时，系统会执行dex文件转换至oat文件) /data/system ：该目录下的packages.xml文件，类似于Windows的注册表，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。 /data/system/packages.xml中内容详解(这里列举的标签内容不一定完整，只是列举核心内容，packages.xml的完整定义详见官方文档)： 该文件的根节点是…，内容树结构如下图所示： /data/system/packages.xml结构图 (1)permissions标签定义了目前系统中定义的所有权限。主要分为两类：系统定义的（package属性为android）和APK定义的（package属性为APK的包名）。 (2)package代表一个APK的属性，它的属性含义如下（这里并未完全列出，如需了解全部属性，请查看官方文档）。 name：APK的包名 codePath:安装路径。有/system/app系统APK和/data/app两种。/system/app存放系统出厂时预置的一些APK，/data/app存放用户安装的第三方APK。 system:如果APK被安装在/system/app下，system的值为true；安装在/data/app下面的话，值为true。 ts:时间戳 version:APK的版本号 sharedUserId/userId:Android系统启动一个普通的APK时，会为这个APK分配一个独立的UID，这就是userId。如果APK要和系统中其它APK使用相同的UID的话，那就是sharedUserId。关于共享UID，下面有更详细的描述。 package的子标签perms:APK的AndroidManifest.xml文件中，每使用一个标签，标签中就会增加一项。 (3)代表一个共享UID，通常，共同实现一系列相似功能的APK共享一个UID。其子标签中的权限代表了这个共享UID的权限，所有使用的同一个共享UID的APK运行在同一进程中，这个进程的UID就是这个共享UID，这些APK都具有这个共享UID的权限。其属性包括： name:共享UID的名字，在APK的android:sharedUserId属性中使用。 userId：使用这个共享UID的所有APK运行时所在的进程的UID。 安装过程总述安卓系统安装一个应用时，系统大致会进行如下操作： 复制APK安装包到data/app目录下，文件名会以应用的package命名； 解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录(一般情况下，会先执行dexopt即dex文件的优化，将优化后的dex文件保存至该目录下)，并data/data目录下创建对应的应用数据目录(data/data目录可读可写)； 更新/data/system/packages.xml中的内容，将APK的信息加入进去。 卸载过程概述对照安装过程，卸载过程与之相逆： 删除安装过程中在上述目录下创建的文件及目录。 安装应用的过程代码解析鉴于APK安装有四种方式，这里分别对各种方式下的安装详细过程进行代码级的解析。 安装过程代码解析的前奏注意：由于Android API迭代较快，版本众多，不过关于安装和卸载的逻辑核心（代码主干）是不变的，最新level级别的API可能会加入更多分支或细节完善代码，一般建议以低版本的API作为分析基础，这样便于更加快速地厘清代码流程和主干，本文以API level14的源码做切入点,引用源代码部分前面的数字表示行号，对应于源文件里面的行号 我们知道，Android里面的包信息管理、安装和卸载等均是通过android/content/pm/PackageManager.java()这个类来完成的。而获取PackageManager的方式一般是：android/content/Context.getPackageManager()方法获取。 查看Context.java，可以发现Context类是抽象的，getPackageManager()也是抽象的。 /** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */ 51 public abstract class Context { ... 196 /** Return PackageManager instance to find global package information. */ 197 public abstract PackageManager getPackageManager(); 而Context的具体实现是android/app/ContextImpl.java里面的ContextImpl类，如下所示： /** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */ 138 class ContextImpl extends Context { ... 481 @Override 482 public PackageManager getPackageManager() { 483 if (mPackageManager != null) { 484 return mPackageManager; 485 } 486 487 IPackageManager pm = ActivityThread.getPackageManager(); 488 if (pm != null) { 489 // Doesn&apos;t matter if we make more than one instance. 490 return (mPackageManager = new ApplicationPackageManager(this, pm)); 491 } 492 493 return null; 494 } 可以看出，获取到的实际上是android/app/ApplicationPackageManager.java定义的ApplicationPackageManager类的实例。进入ApplicationPackageManager.java，代码如下： 60 /*package*/ 61 final class ApplicationPackageManager extends PackageManager { ... 723 ApplicationPackageManager(ContextImpl context, 724 IPackageManager pm) { 725 mContext = context; 726 mPM = pm; 727 } ... 934 @Override 935 public void installPackage(Uri packageURI, IPackageInstallObserver observer, int flags, 936 String installerPackageName) { 937 try { 938 mPM.installPackage(packageURI, observer, flags, installerPackageName); 939 } catch (RemoteException e) { 940 // Should never happen! 941 } 942 } 943 944 @Override 945 public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer, 946 int flags, String installerPackageName, Uri verificationURI, 947 ManifestDigest manifestDigest) { 948 try { 949 mPM.installPackageWithVerification(packageURI, observer, flags, installerPackageName, 950 verificationURI, manifestDigest); 951 } catch (RemoteException e) { 952 // Should never happen! 953 } 954 } 955 956 @Override 957 public void verifyPendingInstall(int id, int response) { 958 try { 959 mPM.verifyPendingInstall(id, response); 960 } catch (RemoteException e) { 961 // Should never happen! 962 } 963 } ... 1226 private final IPackageManager mPM; 进入ApplicationPackageManager，其继承了PackageManager，这里其实采用了组合模式，其实ApplicationPackageManager的installPackage方法内部是调用内部组合变量mPM的installPackage方法，其实其他继承自PackageManager的方法的内部逻辑也都是实际调用了mPM变量的对应方法。而mPM变量是在ApplicationPackageManager的构造方法传入(726行，mPM = pm;)，因此回滚到Context.java的487行(IPackageManager pm = ActivityThread.getPackageManager();),这里的pm就是最终执行安装或者其他操作的对象。跟踪下去，android/app/ActivityThread.java： 114 /** 115 * This manages the execution of the main thread in an 116 * application process, scheduling and executing activities, 117 * broadcasts, and other operations on it as the activity 118 * manager requests. 119 * 120 * {@hide} 121 */ 122 public final class ActivityThread { ... 1395 public static IPackageManager getPackageManager() { 1396 if (sPackageManager != null) { 1397 //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager); 1398 return sPackageManager; 1399 } 1400 IBinder b = ServiceManager.getService(&quot;package&quot;); 1401 //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b); 1402 sPackageManager = IPackageManager.Stub.asInterface(b); 1403 //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager); 1404 return sPackageManager; 1405 } 1406 通过上面代码可以发现，最终返回的IPackageManager的实例对象是通过绑定系统的package服务获取到的，熟悉Android的朋友应该清楚，这实际就是调用PackageManager对应的service来完成。至此，可以明确PackageManager类的安装等等操作实际是通过com/android、server/pm/PackageManagerService.java中定义的类PackageManagerService来完成，其详细代码如下： 140 /** 141 * Keep track of all those .apks everywhere. 142 * 143 * This is very central to the platform&apos;s security; please run the unit 144 * tests whenever making modifications here: 145 * 146 mmm frameworks/base/tests/AndroidTests 147 adb install -r -f out/target/product/passion/data/app/AndroidTests.apk 148 adb shell am instrument -w -e class com.android.unit_tests.PackageManagerTests com.android.unit_tests/android.test.InstrumentationTestRunner 149 * 150 * {@hide} 151 */ 152 public class PackageManagerService extends IPackageManager.Stub { ... 439 class PackageHandler extends Handler { 440 private boolean mBound = false; 441 final ArrayList&lt;HandlerParams&gt; mPendingInstalls = 442 new ArrayList&lt;HandlerParams&gt;(); 443 444 private boolean connectToService() { 445 if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Trying to bind to&quot; + 446 &quot; DefaultContainerService&quot;); 447 Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT); 448 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 449 if (mContext.bindService(service, mDefContainerConn, 450 Context.BIND_AUTO_CREATE)) { 451 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 452 mBound = true; 453 return true; 454 } 455 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 456 return false; 457 } 458 459 private void disconnectService() { 460 mContainerService = null; 461 mBound = false; 462 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 463 mContext.unbindService(mDefContainerConn); 464 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 465 } 466 467 PackageHandler(Looper looper) { 468 super(looper); 469 } 470 471 public void handleMessage(Message msg) { 472 try { 473 doHandleMessage(msg); 474 } finally { 475 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 476 } 477 } 478 479 void doHandleMessage(Message msg) { 480 switch (msg.what) { 481 case INIT_COPY: { 482 if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy&quot;); 483 HandlerParams params = (HandlerParams) msg.obj; 484 int idx = mPendingInstalls.size(); 485 if (DEBUG_INSTALL) Slog.i(TAG, &quot;idx=&quot; + idx); 486 // If a bind was already initiated we dont really 487 // need to do anything. The pending install 488 // will be processed later on. 489 if (!mBound) { 490 // If this is the only one pending we might 491 // have to bind to the service again. 492 if (!connectToService()) { 493 Slog.e(TAG, &quot;Failed to bind to media container service&quot;); 494 params.serviceError(); 495 return; 496 } else { 497 // Once we bind to the service, the first 498 // pending request will be processed. 499 mPendingInstalls.add(idx, params); 500 } 501 } else { 502 mPendingInstalls.add(idx, params); 503 // Already bound to the service. Just make 504 // sure we trigger off processing the first request. 505 if (idx == 0) { 506 mHandler.sendEmptyMessage(MCS_BOUND); 507 } 508 } 509 break; 510 } 511 case MCS_BOUND: { 512 if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;); 513 if (msg.obj != null) { 514 mContainerService = (IMediaContainerService) msg.obj; 515 } 516 if (mContainerService == null) { 517 // Something seriously wrong. Bail out 518 Slog.e(TAG, &quot;Cannot bind to media container service&quot;); 519 for (HandlerParams params : mPendingInstalls) { 520 mPendingInstalls.remove(0); 521 // Indicate service bind error 522 params.serviceError(); 523 } 524 mPendingInstalls.clear(); 525 } else if (mPendingInstalls.size() &gt; 0) { 526 HandlerParams params = mPendingInstalls.get(0); 527 if (params != null) { 528 if (params.startCopy()) { 529 // We are done... look for more work or to 530 // go idle. 531 if (DEBUG_SD_INSTALL) Log.i(TAG, 532 &quot;Checking for more work or unbind...&quot;); 533 // Delete pending install 534 if (mPendingInstalls.size() &gt; 0) { 535 mPendingInstalls.remove(0); 536 } 537 if (mPendingInstalls.size() == 0) { 538 if (mBound) { 539 if (DEBUG_SD_INSTALL) Log.i(TAG, 540 &quot;Posting delayed MCS_UNBIND&quot;); 541 removeMessages(MCS_UNBIND); 542 Message ubmsg = obtainMessage(MCS_UNBIND); 543 // Unbind after a little delay, to avoid 544 // continual thrashing. 545 sendMessageDelayed(ubmsg, 10000); 546 } 547 } else { 548 // There are more pending requests in queue. 549 // Just post MCS_BOUND message to trigger processing 550 // of next pending install. 551 if (DEBUG_SD_INSTALL) Log.i(TAG, 552 &quot;Posting MCS_BOUND for next woek&quot;); 553 mHandler.sendEmptyMessage(MCS_BOUND); 554 } 555 } 556 } 557 } else { 558 // Should never happen ideally. 559 Slog.w(TAG, &quot;Empty queue&quot;); 560 } 561 break; 562 } 563 case MCS_RECONNECT: { 564 if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_reconnect&quot;); 565 if (mPendingInstalls.size() &gt; 0) { 566 if (mBound) { 567 disconnectService(); 568 } 569 if (!connectToService()) { 570 Slog.e(TAG, &quot;Failed to bind to media container service&quot;); 571 for (HandlerParams params : mPendingInstalls) { 572 mPendingInstalls.remove(0); 573 // Indicate service bind error 574 params.serviceError(); 575 } 576 mPendingInstalls.clear(); 577 } 578 } 579 break; 580 } 581 case MCS_UNBIND: { 582 // If there is no actual work left, then time to unbind. 583 if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_unbind&quot;); 584 585 if (mPendingInstalls.size() == 0 &amp;&amp; mPendingVerification.size() == 0) { 586 if (mBound) { 587 if (DEBUG_INSTALL) Slog.i(TAG, &quot;calling disconnectService()&quot;); 588 589 disconnectService(); 590 } 591 } else if (mPendingInstalls.size() &gt; 0) { 592 // There are more pending requests in queue. 593 // Just post MCS_BOUND message to trigger processing 594 // of next pending install. 595 mHandler.sendEmptyMessage(MCS_BOUND); 596 } 597 598 break; 599 } 600 case MCS_GIVE_UP: { 601 if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_giveup too many retries&quot;); 602 mPendingInstalls.remove(0); 603 break; 604 } 605 case SEND_PENDING_BROADCAST: { 606 String packages[]; 607 ArrayList&lt;String&gt; components[]; 608 int size = 0; 609 int uids[]; 610 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 611 synchronized (mPackages) { 612 if (mPendingBroadcasts == null) { 613 return; 614 } 615 size = mPendingBroadcasts.size(); 616 if (size &lt;= 0) { 617 // Nothing to be done. Just return 618 return; 619 } 620 packages = new String[size]; 621 components = new ArrayList[size]; 622 uids = new int[size]; 623 Iterator&lt;HashMap.Entry&lt;String, ArrayList&lt;String&gt;&gt;&gt; 624 it = mPendingBroadcasts.entrySet().iterator(); 625 int i = 0; 626 while (it.hasNext() &amp;&amp; i &lt; size) { 627 HashMap.Entry&lt;String, ArrayList&lt;String&gt;&gt; ent = it.next(); 628 packages[i] = ent.getKey(); 629 components[i] = ent.getValue(); 630 PackageSetting ps = mSettings.mPackages.get(ent.getKey()); 631 uids[i] = (ps != null) ? ps.userId : -1; 632 i++; 633 } 634 size = i; 635 mPendingBroadcasts.clear(); 636 } 637 // Send broadcasts 638 for (int i = 0; i &lt; size; i++) { 639 sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]); 640 } 641 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 642 break; 643 } 644 case START_CLEANING_PACKAGE: { 645 String packageName = (String)msg.obj; 646 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 647 synchronized (mPackages) { 648 if (!mSettings.mPackagesToBeCleaned.contains(packageName)) { 649 mSettings.mPackagesToBeCleaned.add(packageName); 650 } 651 } 652 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 653 startCleaningPackages(); 654 } break; 655 case POST_INSTALL: { 656 if (DEBUG_INSTALL) Log.v(TAG, &quot;Handling post-install for &quot; + msg.arg1); 657 PostInstallData data = mRunningInstalls.get(msg.arg1); 658 mRunningInstalls.delete(msg.arg1); 659 boolean deleteOld = false; 660 661 if (data != null) { 662 InstallArgs args = data.args; 663 PackageInstalledInfo res = data.res; 664 665 if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) { 666 res.removedInfo.sendBroadcast(false, true); 667 Bundle extras = new Bundle(1); 668 extras.putInt(Intent.EXTRA_UID, res.uid); 669 final boolean update = res.removedInfo.removedPackage != null; 670 if (update) { 671 extras.putBoolean(Intent.EXTRA_REPLACING, true); 672 } 673 sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, 674 res.pkg.applicationInfo.packageName, 675 extras, null, null); 676 if (update) { 677 sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, 678 res.pkg.applicationInfo.packageName, 679 extras, null, null); 680 sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, 681 null, null, 682 res.pkg.applicationInfo.packageName, null); 683 } 684 if (res.removedInfo.args != null) { 685 // Remove the replaced package&apos;s older resources safely now 686 deleteOld = true; 687 } 688 } 689 // Force a gc to clear up things 690 Runtime.getRuntime().gc(); 691 // We delete after a gc for applications on sdcard. 692 if (deleteOld) { 693 synchronized (mInstallLock) { 694 res.removedInfo.args.doPostDeleteLI(true); 695 } 696 } 697 if (args.observer != null) { 698 try { 699 args.observer.packageInstalled(res.name, res.returnCode); 700 } catch (RemoteException e) { 701 Slog.i(TAG, &quot;Observer no longer exists.&quot;); 702 } 703 } 704 } else { 705 Slog.e(TAG, &quot;Bogus post-install token &quot; + msg.arg1); 706 } 707 } break; 708 case UPDATED_MEDIA_STATUS: { 709 if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Got message UPDATED_MEDIA_STATUS&quot;); 710 boolean reportStatus = msg.arg1 == 1; 711 boolean doGc = msg.arg2 == 1; 712 if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;reportStatus=&quot; + reportStatus + &quot;, doGc = &quot; + doGc); 713 if (doGc) { 714 // Force a gc to clear up stale containers. 715 Runtime.getRuntime().gc(); 716 } 717 if (msg.obj != null) { 718 @SuppressWarnings(&quot;unchecked&quot;) 719 Set&lt;SdInstallArgs&gt; args = (Set&lt;SdInstallArgs&gt;) msg.obj; 720 if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Unloading all containers&quot;); 721 // Unload containers 722 unloadAllContainers(args); 723 } 724 if (reportStatus) { 725 try { 726 if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Invoking MountService call back&quot;); 727 PackageHelper.getMountService().finishMediaUpdate(); 728 } catch (RemoteException e) { 729 Log.e(TAG, &quot;MountService not running?&quot;); 730 } 731 } 732 } break; 733 case WRITE_SETTINGS: { 734 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 735 synchronized (mPackages) { 736 removeMessages(WRITE_SETTINGS); 737 removeMessages(WRITE_STOPPED_PACKAGES); 738 mSettings.writeLPr(); 739 } 740 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 741 } break; 742 case WRITE_STOPPED_PACKAGES: { 743 Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); 744 synchronized (mPackages) { 745 removeMessages(WRITE_STOPPED_PACKAGES); 746 mSettings.writeStoppedLPr(); 747 } 748 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); 749 } break; 750 case CHECK_PENDING_VERIFICATION: { 751 final int verificationId = msg.arg1; 752 final PackageVerificationState state = mPendingVerification.get(verificationId); 753 754 if (state != null) { 755 final InstallArgs args = state.getInstallArgs(); 756 Slog.i(TAG, &quot;Verification timed out for &quot; + args.packageURI.toString()); 757 mPendingVerification.remove(verificationId); 758 759 int ret = PackageManager.INSTALL_FAILED_VERIFICATION_TIMEOUT; 760 processPendingInstall(args, ret); 761 762 mHandler.sendEmptyMessage(MCS_UNBIND); 763 } 764 765 break; 766 } 767 case PACKAGE_VERIFIED: { 768 final int verificationId = msg.arg1; 769 770 final PackageVerificationState state = mPendingVerification.get(verificationId); 771 if (state == null) { 772 Slog.w(TAG, &quot;Invalid verification token &quot; + verificationId + &quot; received&quot;); 773 break; 774 } 775 776 final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj; 777 778 state.setVerifierResponse(response.callerUid, response.code); 779 780 if (state.isVerificationComplete()) { 781 mPendingVerification.remove(verificationId); 782 783 final InstallArgs args = state.getInstallArgs(); 784 785 int ret; 786 if (state.isInstallAllowed()) { 787 ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR; 788 try { 789 ret = args.copyApk(mContainerService, true); 790 } catch (RemoteException e) { 791 Slog.e(TAG, &quot;Could not contact the ContainerService&quot;); 792 } 793 } else { 794 ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; 795 } 796 797 processPendingInstall(args, ret); 798 799 mHandler.sendEmptyMessage(MCS_UNBIND); 800 } 801 802 break; 803 } 804 } 805 } 806 } ... ... 831 public static final IPackageManager main(Context context, boolean factoryTest, 832 boolean onlyCore) { 833 PackageManagerService m = new PackageManagerService(context, factoryTest, onlyCore); 834 ServiceManager.addService(&quot;package&quot;, m); 835 return m; 836 } ... ... 860 public PackageManagerService(Context context, boolean factoryTest, boolean onlyCore) { 861 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, 862 SystemClock.uptimeMillis()); 863 864 if (mSdkVersion &lt;= 0) { 865 Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;); 866 } 867 868 mContext = context; 869 mFactoryTest = factoryTest; 870 mOnlyCore = onlyCore; 871 mNoDexOpt = &quot;eng&quot;.equals(SystemProperties.get(&quot;ro.build.type&quot;)); 872 mMetrics = new DisplayMetrics(); 873 mSettings = new Settings(); 874 mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, 875 Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM); 876 mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, 877 MULTIPLE_APPLICATION_UIDS 878 ? RADIO_UID : FIRST_APPLICATION_UID, 879 ApplicationInfo.FLAG_SYSTEM); 880 mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, 881 MULTIPLE_APPLICATION_UIDS 882 ? LOG_UID : FIRST_APPLICATION_UID, 883 ApplicationInfo.FLAG_SYSTEM); 884 mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, 885 MULTIPLE_APPLICATION_UIDS 886 ? NFC_UID : FIRST_APPLICATION_UID, 887 ApplicationInfo.FLAG_SYSTEM); 888 889 String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;); 890 if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) { 891 if (&quot;*&quot;.equals(separateProcesses)) { 892 mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES; 893 mSeparateProcesses = null; 894 Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;); 895 } else { 896 mDefParseFlags = 0; 897 mSeparateProcesses = separateProcesses.split(&quot;,&quot;); 898 Slog.w(TAG, &quot;Running with debug.separate_processes: &quot; 899 + separateProcesses); 900 } 901 } else { 902 mDefParseFlags = 0; 903 mSeparateProcesses = null; 904 } 905 906 mInstaller = new Installer(); 907 908 WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); 909 Display d = wm.getDefaultDisplay(); 910 d.getMetrics(mMetrics); 911 912 synchronized (mInstallLock) { 913 // writer 914 synchronized (mPackages) { 915 mHandlerThread.start(); 916 mHandler = new PackageHandler(mHandlerThread.getLooper()); 917 918 File dataDir = Environment.getDataDirectory(); 919 mAppDataDir = new File(dataDir, &quot;data&quot;); 920 mUserAppDataDir = new File(dataDir, &quot;user&quot;); 921 mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); 922 923 mUserManager = new UserManager(mInstaller, mUserAppDataDir); 924 925 readPermissions(); 926 927 mRestoredSettings = mSettings.readLPw(); 928 long startTime = SystemClock.uptimeMillis(); 929 930 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, 931 startTime); 932 933 // Set flag to monitor and not change apk file paths when 934 // scanning install directories. 935 int scanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX; 936 if (mNoDexOpt) { 937 Slog.w(TAG, &quot;Running ENG build: no pre-dexopt!&quot;); 938 scanMode |= SCAN_NO_DEX; 939 } 940 941 final HashSet&lt;String&gt; libFiles = new HashSet&lt;String&gt;(); 942 943 mFrameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;); 944 mDalvikCacheDir = new File(dataDir, &quot;dalvik-cache&quot;); 945 946 boolean didDexOpt = false; 947 948 /** 949 * Out of paranoia, ensure that everything in the boot class 950 * path has been dexed. 951 */ 952 String bootClassPath = System.getProperty(&quot;java.boot.class.path&quot;); 953 if (bootClassPath != null) { 954 String[] paths = splitString(bootClassPath, &apos;:&apos;); 955 for (int i=0; i&lt;paths.length; i++) { 956 try { 957 if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) { 958 libFiles.add(paths[i]); 959 mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true); 960 didDexOpt = true; 961 } 962 } catch (FileNotFoundException e) { 963 Slog.w(TAG, &quot;Boot class path not found: &quot; + paths[i]); 964 } catch (IOException e) { 965 Slog.w(TAG, &quot;Cannot dexopt &quot; + paths[i] + &quot;; is it an APK or JAR? &quot; 966 + e.getMessage()); 967 } 968 } 969 } else { 970 Slog.w(TAG, &quot;No BOOTCLASSPATH found!&quot;); 971 } 972 973 /** 974 * Also ensure all external libraries have had dexopt run on them. 975 */ 976 if (mSharedLibraries.size() &gt; 0) { 977 Iterator&lt;String&gt; libs = mSharedLibraries.values().iterator(); 978 while (libs.hasNext()) { 979 String lib = libs.next(); 980 try { 981 if (dalvik.system.DexFile.isDexOptNeeded(lib)) { 982 libFiles.add(lib); 983 mInstaller.dexopt(lib, Process.SYSTEM_UID, true); 984 didDexOpt = true; 985 } 986 } catch (FileNotFoundException e) { 987 Slog.w(TAG, &quot;Library not found: &quot; + lib); 988 } catch (IOException e) { 989 Slog.w(TAG, &quot;Cannot dexopt &quot; + lib + &quot;; is it an APK or JAR? &quot; 990 + e.getMessage()); 991 } 992 } 993 } 994 995 // Gross hack for now: we know this file doesn&apos;t contain any 996 // code, so don&apos;t dexopt it to avoid the resulting log spew. 997 libFiles.add(mFrameworkDir.getPath() + &quot;/framework-res.apk&quot;); 998 999 /** 1000 * And there are a number of commands implemented in Java, which 1001 * we currently need to do the dexopt on so that they can be 1002 * run from a non-root shell. 1003 */ 1004 String[] frameworkFiles = mFrameworkDir.list(); 1005 if (frameworkFiles != null) { 1006 for (int i=0; i&lt;frameworkFiles.length; i++) { 1007 File libPath = new File(mFrameworkDir, frameworkFiles[i]); 1008 String path = libPath.getPath(); 1009 // Skip the file if we alrady did it. 1010 if (libFiles.contains(path)) { 1011 continue; 1012 } 1013 // Skip the file if it is not a type we want to dexopt. 1014 if (!path.endsWith(&quot;.apk&quot;) &amp;&amp; !path.endsWith(&quot;.jar&quot;)) { 1015 continue; 1016 } 1017 try { 1018 if (dalvik.system.DexFile.isDexOptNeeded(path)) { 1019 mInstaller.dexopt(path, Process.SYSTEM_UID, true); 1020 didDexOpt = true; 1021 } 1022 } catch (FileNotFoundException e) { 1023 Slog.w(TAG, &quot;Jar not found: &quot; + path); 1024 } catch (IOException e) { 1025 Slog.w(TAG, &quot;Exception reading jar: &quot; + path, e); 1026 } 1027 } 1028 } 1029 1030 if (didDexOpt) { 1031 // If we had to do a dexopt of one of the previous 1032 // things, then something on the system has changed. 1033 // Consider this significant, and wipe away all other 1034 // existing dexopt files to ensure we don&apos;t leave any 1035 // dangling around. 1036 String[] files = mDalvikCacheDir.list(); 1037 if (files != null) { 1038 for (int i=0; i&lt;files.length; i++) { 1039 String fn = files[i]; 1040 if (fn.startsWith(&quot;data@app@&quot;) 1041 || fn.startsWith(&quot;data@app-private@&quot;)) { 1042 Slog.i(TAG, &quot;Pruning dalvik file: &quot; + fn); 1043 (new File(mDalvikCacheDir, fn)).delete(); 1044 } 1045 } 1046 } 1047 } 1048 1049 // Find base frameworks (resource packages without code). 1050 mFrameworkInstallObserver = new AppDirObserver( 1051 mFrameworkDir.getPath(), OBSERVER_EVENTS, true); 1052 mFrameworkInstallObserver.startWatching(); 1053 scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM 1054 | PackageParser.PARSE_IS_SYSTEM_DIR, 1055 scanMode | SCAN_NO_DEX, 0); 1056 1057 // Collect all system packages. 1058 mSystemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); 1059 mSystemInstallObserver = new AppDirObserver( 1060 mSystemAppDir.getPath(), OBSERVER_EVENTS, true); 1061 mSystemInstallObserver.startWatching(); 1062 scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM 1063 | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0); 1064 1065 // Collect all vendor packages. 1066 mVendorAppDir = new File(&quot;/vendor/app&quot;); 1067 mVendorInstallObserver = new AppDirObserver( 1068 mVendorAppDir.getPath(), OBSERVER_EVENTS, true); 1069 mVendorInstallObserver.startWatching(); 1070 scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM 1071 | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0); 1072 1073 if (DEBUG_UPGRADE) Log.v(TAG, &quot;Running installd update commands&quot;); 1074 mInstaller.moveFiles(); 1075 1076 // Prune any system packages that no longer exist. 1077 if (!mOnlyCore) { 1078 Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); 1079 while (psit.hasNext()) { 1080 PackageSetting ps = psit.next(); 1081 if ((ps.pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) != 0 1082 &amp;&amp; !mPackages.containsKey(ps.name) 1083 &amp;&amp; !mSettings.mDisabledSysPackages.containsKey(ps.name)) { 1084 psit.remove(); 1085 String msg = &quot;System package &quot; + ps.name 1086 + &quot; no longer exists; wiping its data&quot;; 1087 reportSettingsProblem(Log.WARN, msg); 1088 mInstaller.remove(ps.name, 0); 1089 mUserManager.removePackageForAllUsers(ps.name); 1090 } 1091 } 1092 } 1093 1094 mAppInstallDir = new File(dataDir, &quot;app&quot;); 1095 //look for any incomplete package installations 1096 ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr(); 1097 //clean up list 1098 for(int i = 0; i &lt; deletePkgsList.size(); i++) { 1099 //clean up here 1100 cleanupInstallFailedPackage(deletePkgsList.get(i)); 1101 } 1102 //delete tmp files 1103 deleteTempPackageFiles(); 1104 1105 if (!mOnlyCore) { 1106 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, 1107 SystemClock.uptimeMillis()); 1108 mAppInstallObserver = new AppDirObserver( 1109 mAppInstallDir.getPath(), OBSERVER_EVENTS, false); 1110 mAppInstallObserver.startWatching(); 1111 scanDirLI(mAppInstallDir, 0, scanMode, 0); 1112 1113 mDrmAppInstallObserver = new AppDirObserver( 1114 mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false); 1115 mDrmAppInstallObserver.startWatching(); 1116 scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK, 1117 scanMode, 0); 1118 } else { 1119 mAppInstallObserver = null; 1120 mDrmAppInstallObserver = null; 1121 } 1122 1123 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, 1124 SystemClock.uptimeMillis()); 1125 Slog.i(TAG, &quot;Time to scan packages: &quot; 1126 + ((SystemClock.uptimeMillis()-startTime)/1000f) 1127 + &quot; seconds&quot;); 1128 1129 // If the platform SDK has changed since the last time we booted, 1130 // we need to re-grant app permission to catch any new ones that 1131 // appear. This is really a hack, and means that apps can in some 1132 // cases get permissions that the user didn&apos;t initially explicitly 1133 // allow... it would be nice to have some better way to handle 1134 // this situation. 1135 final boolean regrantPermissions = mSettings.mInternalSdkPlatform 1136 != mSdkVersion; 1137 if (regrantPermissions) Slog.i(TAG, &quot;Platform changed from &quot; 1138 + mSettings.mInternalSdkPlatform + &quot; to &quot; + mSdkVersion 1139 + &quot;; regranting permissions for internal storage&quot;); 1140 mSettings.mInternalSdkPlatform = mSdkVersion; 1141 1142 updatePermissionsLPw(null, null, true, regrantPermissions, regrantPermissions); 1143 1144 // can downgrade to reader 1145 mSettings.writeLPr(); 1146 1147 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, 1148 SystemClock.uptimeMillis()); 1149 1150 // Now after opening every single application zip, make sure they 1151 // are all flushed. Not really needed, but keeps things nice and 1152 // tidy. 1153 Runtime.getRuntime().gc(); 1154 1155 mRequiredVerifierPackage = getRequiredVerifierLPr(); 1156 } // synchronized (mPackages) 1157 } // synchronized (mInstallLock) 1158 } ... 仔细分析上述代码，主要分两个部分：PackageManagerService的构造方法(启动流程)（860-1158行）、PackageHandler的逻辑(439-806行)。PackageManagerService是在系统启动阶段由systemserver启动的一个java层服务，用来管理/system/framework，/system/app，/data/app，/data/app-private等目录下的apk文件，PackageManagerService的启动流程主要包括： PackageManagerService 以下是PackageManagerService主要的工作内容： 建立java层的installer与c层的installd的socket联接，使得在上层的install,remove,dexopt等功能最终由installd在底层实现； 建立PackageHandler消息循环，用于处理外部的apk安装请求消息，如adb install,packageinstaller安装apk时会发送消息； 解析/system/etc/permission下xml文件(framework/base/data/etc/)，包括platform.xml和系统支持的各种硬件模块的feature.主要工作： (1)建立底层user ids和group ids 同上层permissions之间的映射；可以指定一个权限与几个组ID对应。当一个APK被授予这个权限时，它也同时属于这几个组。 (2)给一些底层用户分配权限，如给shell授予各种permission权限；把一个权限赋予一个UID，当进程使用这个UID运行时，就具备了这个权限。 (3) library,系统增加的一些应用需要link的扩展jar库； (4) feature,系统每增加一个硬件，都要添加相应的feature.将解析结果放入mSystemPermissions,mSharedLibraries,mSettings.mPermissions,mAvailableFeatures等几个集合中供系统查询和权限配置使用 检查/data/system/packages.xml是否存在，这个文件是在解析apk时由writeLP()创建的，里面记录了系统的permissions，以及每个apk的name,codePath,flags,ts,version,uesrid等信息，这些信息主要通过apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件并保存到flash，下次开机直接从里面读取相关信息添加到内存相关列表中。当有apk升级，安装或删除时会更新这个文件。 检查BootClassPath，mSharedLibraries及/system/framework下的jar是否需要dexopt，需要的则通过dexopt进行优化； 启动AppDirObserver线程监测/system/framework,/system/app,/data/app,/data/app-private目录的事件,主要监听add和remove事件。对于目录监听底层通过inotify机制实现，inotify 是一种文件系统的变化通知机制，如文件增加、删除等事件可以立刻让用户态得知,它为用户态监视文件系统的变化提供了强大的支持。当有add event时调用scanPackageLI(File , int , int)处理；当有remove event时调用removePackageLI()处理; 对于以上几个目录下的apk逐个解析，主要是解析每个apk的AndroidMa-nifest.xml文件，处理asset/res等资源文件，建立起每个apk的配置结构信息，并将每个apk的配置信息添加到全局列表进行管理。调用installer.install()进行安装工作,检查apk里的dex文件是否需要再优化,如果需要优化则通过辅助工具dexopt进行优化处理；将解析出的componet添加到pkg的对应列表里；对apk进行签名和证书校验,进行完整性验证。 将解析的每个apk的信息保存到packages.xml和packages.list文件里，packages.list记录了如下数据：pkgName，userId，debugFlag，dataPath（包的数据路径）。 开机安装过程代码解析有了上面的认识，接下来分析安装的过程就比较轻松了(均围绕PackageManagerService.java展开)。开机安装过程的代码流程如下： 扫描各目录(/system/framework、/system/app、/vendor/app、/data/app/、/data/app-private)下的jar包或安装包： a.扫描安装“/system/framework”目录下的jar包(1049-1055行); b.扫描安装系统/system/app的应用程序(1057-1063行); c.制造商的目录下/vendor/app应用包(1065-1071行); d.扫描“/data/app”目录，即用户安装的第三方应用(1108-1111行); e.扫描” data\\app-private”目录，即安装DRM保护的APK文件（一个受保护的歌曲或受保护的视频是使用DRM保护的文件）（1113-1117行）。 扫描目录关键方法的代码清单： 2732 private void scanDirLI(File dir, int flags, int scanMode, long currentTime) { 2733 String[] files = dir.list(); 2734 if (files == null) { 2735 Log.d(TAG, &quot;No files in app dir &quot; + dir); 2736 return; 2737 } 2738 2739 if (DEBUG_PACKAGE_SCANNING) { 2740 Log.d(TAG, &quot;Scanning app dir &quot; + dir); 2741 } 2742 2743 int i; 2744 for (i=0; i&lt;files.length; i++) { 2745 File file = new File(dir, files[i]); 2746 if (!isPackageFilename(files[i])) { 2747 // Ignore entries which are not apk&apos;s 2748 continue; 2749 } 2750 PackageParser.Package pkg = scanPackageLI(file, 2751 flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime); 2752 // Don&apos;t mess around with apps in system partition. 2753 if (pkg == null &amp;&amp; (flags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; 2754 mLastScanError == PackageManager.INSTALL_FAILED_INVALID_APK) { 2755 // Delete the apk 2756 Slog.w(TAG, &quot;Cleaning up failed install of &quot; + file); 2757 file.delete(); 2758 } 2759 } 2760 } 从上面扫描方法的代码中可以看出实质是调用了scanPackageLI(File scanFile,int parseFlags, int scanMode, long currentTime) ，其代码在2814-2923行定义。分析其代码，发现最终实质是调用scanPackageLI(PackageParser.Package pkg,int parseFlags, int scanMode, long currentTime)。而后者这个方法代码定义在3106-3905行之间，前面一段主要是各种校验和检查，关键部分代码为： 3495 //invoke installer to do the actual installation 3496 int ret = mInstaller.install(pkgName, pkg.applicationInfo.uid, 3497 pkg.applicationInfo.uid); 3498 if (ret &lt; 0) { 3499 // Error from installer 3500 mLastScanError = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE; 3501 return null; 3502 } 3503 // Create data directories for all users 3504 mUserManager.installPackageForAllUsers(pkgName, pkg.applicationInfo.uid); 不难看出，mInstaller.install是真正执行安装之处。而看看mInstaller的定义： 258 // Used for priviledge escalation. MUST NOT BE CALLED WITH mPackages 259 // LOCK HELD. Can be called with mInstallLock held. 260 final Installer mInstaller; 查看com/android/server/pm/Installer.java，其代码相对比较少，分析起来比较容易，其install方法调用了execute(String cmd)方法，而execute(String cmd)又调用transaction(cmd)： 148 private synchronized String transaction(String cmd) { 149 if (!connect()) { 150 Slog.e(TAG, &quot;connection failed&quot;); 151 return &quot;-1&quot;; 152 } 153 154 if (!writeCommand(cmd)) { 155 /* 156 * If installd died and restarted in the background (unlikely but 157 * possible) we&apos;ll fail on the next write (this one). Try to 158 * reconnect and write the command one more time before giving up. 159 */ 160 Slog.e(TAG, &quot;write command failed? reconnect!&quot;); 161 if (!connect() || !writeCommand(cmd)) { 162 return &quot;-1&quot;; 163 } 164 } 165 if (LOCAL_DEBUG) { 166 Slog.i(TAG, &quot;send: &apos;&quot; + cmd + &quot;&apos;&quot;); 167 } 168 if (readReply()) { 169 String s = new String(buf, 0, buflen); 170 if (LOCAL_DEBUG) { 171 Slog.i(TAG, &quot;recv: &apos;&quot; + s + &quot;&apos;&quot;); 172 } 173 return s; 174 } else { 175 if (LOCAL_DEBUG) { 176 Slog.i(TAG, &quot;fail&quot;); 177 } 178 return &quot;-1&quot;; 179 } 180 } 首先是149行的connect方法： 43 private boolean connect() { 44 if (mSocket != null) { 45 return true; 46 } 47 Slog.i(TAG, &quot;connecting...&quot;); 48 try { 49 mSocket = new LocalSocket(); 50 51 LocalSocketAddress address = new LocalSocketAddress(&quot;installd&quot;, 52 LocalSocketAddress.Namespace.RESERVED); 53 54 mSocket.connect(address); 55 56 mIn = mSocket.getInputStream(); 57 mOut = mSocket.getOutputStream(); 58 } catch (IOException ex) { 59 disconnect(); 60 return false; 61 } 62 return true; 63 } 到这里已经很清楚了，实则是通过socket连接到本地方法，即指挥installd在C语言的文件中完成工作。 网络下载应用安装过程代码解析当从网络上下载APK完成后，自动调用Packagemanager的安装方法installPackage。如前面所述，最终是调用PackageManagerService的installPackage方法。如下： 4882 /* Called when a downloaded package installation has been confirmed by the user */ 4883 public void installPackage( 4884 final Uri packageURI, final IPackageInstallObserver observer, final int flags) { 4885 installPackage(packageURI, observer, flags, null); 4886 } 4887 4888 /* Called when a downloaded package installation has been confirmed by the user */ 4889 public void installPackage( 4890 final Uri packageURI, final IPackageInstallObserver observer, final int flags, 4891 final String installerPackageName) { 4892 installPackageWithVerification(packageURI, observer, flags, installerPackageName, null, 4893 null); 4894 } 4895 4896 @Override 4897 public void installPackageWithVerification(Uri packageURI, IPackageInstallObserver observer, 4898 int flags, String installerPackageName, Uri verificationURI, 4899 ManifestDigest manifestDigest) { 4900 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null); 4901 4902 final int uid = Binder.getCallingUid(); 4903 4904 final int filteredFlags; 4905 4906 if (uid == Process.SHELL_UID || uid == 0) { 4907 if (DEBUG_INSTALL) { 4908 Slog.v(TAG, &quot;Install from ADB&quot;); 4909 } 4910 filteredFlags = flags | PackageManager.INSTALL_FROM_ADB; 4911 } else { 4912 filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB; 4913 } 4914 4915 final Message msg = mHandler.obtainMessage(INIT_COPY); 4916 msg.obj = new InstallParams(packageURI, observer, filteredFlags, installerPackageName, 4917 verificationURI, manifestDigest); 4918 mHandler.sendMessage(msg); 4919 } 可以发现，调用之后进入到4945-4918行，通过PackageHandler的实例mhandler.sendMessage（msg）把信息发给继承Handler的类HandleMessage()方法。在前面章节已经介绍了PackageManagerService中PackageHandler的定义。HandleMessage()把信息发给doHandleMessage()方法,方法中用switch语句进行判定传来Message进行分支处理。这里传入的消息的msg.what是INIT_COPY，进入到INIT_COPY分支，可以看到，一旦成功绑定了com.android.defcontainer.DefaultContainerService服务，则进入506行–mHandler.sendEmptyMessage(MCS_BOUND);此时进入doHandleMessage方法的switch语句的MCS_BOUND分支，跟踪进去，关键代码： 528 if (params.startCopy()) { params是PackageManagerService中内部抽象类HandlerParams的子类InstallParams(参见上面4916行)的实例，HandlerParams代码清单： 5202 private abstract class HandlerParams { 5203 private static final int MAX_RETRIES = 4; 5204 5205 /** 5206 * Number of times startCopy() has been attempted and had a non-fatal 5207 * error. 5208 */ 5209 private int mRetries = 0; 5210 5211 final boolean startCopy() { 5212 boolean res; 5213 try { 5214 if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy&quot;); 5215 5216 if (++mRetries &gt; MAX_RETRIES) { 5217 Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;); 5218 mHandler.sendEmptyMessage(MCS_GIVE_UP); 5219 handleServiceError(); 5220 return false; 5221 } else { 5222 handleStartCopy(); 5223 res = true; 5224 } 5225 } catch (RemoteException e) { 5226 if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;); 5227 mHandler.sendEmptyMessage(MCS_RECONNECT); 5228 res = false; 5229 } 5230 handleReturnCode(); 5231 return res; 5232 } 5233 5234 final void serviceError() { 5235 if (DEBUG_INSTALL) Slog.i(TAG, &quot;serviceError&quot;); 5236 handleServiceError(); 5237 handleReturnCode(); 5238 } 5239 5240 abstract void handleStartCopy() throws RemoteException; 5241 abstract void handleServiceError(); 5242 abstract void handleReturnCode(); 5243 } 5244 startCopy()方法中关键代码是先调用handleStartCopy()方法，再调用handleReturnCode()方法(由子类实现，这里即InstallParams的handleStartCopy()方法和handleReturnCode()方法)，handleStartCopy()代码较多，但是前面基本是校验相关逻辑，关键部分在： 5557 } else { 5558 /* 5559 * No package verification is enabled, so immediately start 5560 * the remote call to initiate copy using temporary file. 5561 */ 5562 ret = args.copyApk(mContainerService, true); 5563 } args是抽象类InstallArgs的子类实现类SdInstallArgs(安装在SD卡时)或FileInstallArgs(非安装在)的实例对象，copyApk是负责将下载的APK文件copy到/data/app目录下。而handleReturnCode方法如下： 5569 @Override 5570 void handleReturnCode() { 5571 // If mArgs is null, then MCS couldn&apos;t be reached. When it 5572 // reconnects, it will try again to install. At that point, this 5573 // will succeed. 5574 if (mArgs != null) { 5575 processPendingInstall(mArgs, mRet); 5576 } 5577 } 这时可以清楚的看见processPendingInstall()被调用。其代码为： 5129 private void processPendingInstall(final InstallArgs args, final int currentStatus) { 5130 // Queue up an async operation since the package installation may take a little while. 5131 mHandler.post(new Runnable() { 5132 public void run() { 5133 mHandler.removeCallbacks(this); 5134 // Result object to be returned 5135 PackageInstalledInfo res = new PackageInstalledInfo(); 5136 res.returnCode = currentStatus; 5137 res.uid = -1; 5138 res.pkg = null; 5139 res.removedInfo = new PackageRemovedInfo(); 5140 if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) { 5141 args.doPreInstall(res.returnCode); 5142 synchronized (mInstallLock) { 5143 installPackageLI(args, true, res); 5144 } 5145 args.doPostInstall(res.returnCode); 5146 } 5147 5148 // A restore should be performed at this point if (a) the install 5149 // succeeded, (b) the operation is not an update, and (c) the new 5150 // package has a backupAgent defined. 5151 final boolean update = res.removedInfo.removedPackage != null; 5152 boolean doRestore = (!update 5153 &amp;&amp; res.pkg != null 5154 &amp;&amp; res.pkg.applicationInfo.backupAgentName != null); 5155 5156 // Set up the post-install work request bookkeeping. This will be used 5157 // and cleaned up by the post-install event handling regardless of whether 5158 // there&apos;s a restore pass performed. Token values are &gt;= 1. 5159 int token; 5160 if (mNextInstallToken &lt; 0) mNextInstallToken = 1; 5161 token = mNextInstallToken++; 5162 5163 PostInstallData data = new PostInstallData(args, res); 5164 mRunningInstalls.put(token, data); 5165 if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token); 5166 5167 if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) { 5168 // Pass responsibility to the Backup Manager. It will perform a 5169 // restore if appropriate, then pass responsibility back to the 5170 // Package Manager to run the post-install observer callbacks 5171 // and broadcasts. 5172 IBackupManager bm = IBackupManager.Stub.asInterface( 5173 ServiceManager.getService(Context.BACKUP_SERVICE)); 5174 if (bm != null) { 5175 if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token 5176 + &quot; to BM for possible restore&quot;); 5177 try { 5178 bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token); 5179 } catch (RemoteException e) { 5180 // can&apos;t happen; the backup manager is local 5181 } catch (Exception e) { 5182 Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e); 5183 doRestore = false; 5184 } 5185 } else { 5186 Slog.e(TAG, &quot;Backup Manager not found!&quot;); 5187 doRestore = false; 5188 } 5189 } 5190 5191 if (!doRestore) { 5192 // No restore possible, or the Backup Manager was mysteriously not 5193 // available -- just fire the post-install work request directly. 5194 if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token); 5195 Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); 5196 mHandler.sendMessage(msg); 5197 } 5198 } 5199 }); 5200 } 关键部分代码为5140-5146行： 5140 if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) { 5141 args.doPreInstall(res.returnCode); 5142 synchronized (mInstallLock) { 5143 installPackageLI(args, true, res); 5144 } 5145 args.doPostInstall(res.returnCode); 5146 } 这里installPackageLI(args, true, res)的代码为： 5573 private void installPackageLI(InstallArgs args, 5574 boolean newInstall, PackageInstalledInfo res) { 5575 int pFlags = args.flags; 5576 String installerPackageName = args.installerPackageName; 5577 File tmpPackageFile = new File(args.getCodePath()); 5578 boolean forwardLocked = ((pFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0); 5579 boolean onSd = ((pFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0); 5580 boolean replace = false; 5581 int scanMode = (onSd ? 0 : SCAN_MONITOR) | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE 5582 | (newInstall ? SCAN_NEW_INSTALL : 0); 5583 // Result object to be returned 5584 res.returnCode = PackageManager.INSTALL_SUCCEEDED; 5585 5586 // Retrieve PackageSettings and parse package 5587 int parseFlags = PackageParser.PARSE_CHATTY | 5588 (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | 5589 (onSd ? PackageParser.PARSE_ON_SDCARD : 0); 5590 parseFlags |= mDefParseFlags; 5591 PackageParser pp = new PackageParser(tmpPackageFile.getPath()); 5592 pp.setSeparateProcesses(mSeparateProcesses); 5593 final PackageParser.Package pkg = pp.parsePackage(tmpPackageFile, 5594 null, mMetrics, parseFlags); 5595 if (pkg == null) { 5596 res.returnCode = pp.getParseError(); 5597 return; 5598 } 5599 String pkgName = res.name = pkg.packageName; 5600 if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) { 5601 if ((pFlags&amp;PackageManager.INSTALL_ALLOW_TEST) == 0) { 5602 res.returnCode = PackageManager.INSTALL_FAILED_TEST_ONLY; 5603 return; 5604 } 5605 } 5606 if (GET_CERTIFICATES &amp;&amp; !pp.collectCertificates(pkg, parseFlags)) { 5607 res.returnCode = pp.getParseError(); 5608 return; 5609 } 5610 5611 /* If the installer passed in a manifest digest, compare it now. */ 5612 if (args.manifestDigest != null) { 5613 if (DEBUG_INSTALL) { 5614 final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot; 5615 : pkg.manifestDigest.toString(); 5616 Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot; 5617 + parsedManifest); 5618 } 5619 5620 if (!args.manifestDigest.equals(pkg.manifestDigest)) { 5621 res.returnCode = PackageManager.INSTALL_FAILED_PACKAGE_CHANGED; 5622 return; 5623 } 5624 } else if (DEBUG_INSTALL) { 5625 final String parsedManifest = pkg.manifestDigest == null 5626 ? &quot;null&quot; : pkg.manifestDigest.toString(); 5627 Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest); 5628 } 5629 5630 // Get rid of all references to package scan path via parser. 5631 pp = null; 5632 String oldCodePath = null; 5633 boolean systemApp = false; 5634 synchronized (mPackages) { 5635 // Check if installing already existing package 5636 if ((pFlags&amp;PackageManager.INSTALL_REPLACE_EXISTING) != 0) { 5637 String oldName = mSettings.mRenamedPackages.get(pkgName); 5638 if (pkg.mOriginalPackages != null 5639 &amp;&amp; pkg.mOriginalPackages.contains(oldName) 5640 &amp;&amp; mPackages.containsKey(oldName)) { 5641 // This package is derived from an original package, 5642 // and this device has been updating from that original 5643 // name. We must continue using the original name, so 5644 // rename the new package here. 5645 pkg.setPackageName(oldName); 5646 pkgName = pkg.packageName; 5647 replace = true; 5648 } else if (mPackages.containsKey(pkgName)) { 5649 // This package, under its official name, already exists 5650 // on the device; we should replace it. 5651 replace = true; 5652 } 5653 } 5654 PackageSetting ps = mSettings.mPackages.get(pkgName); 5655 if (ps != null) { 5656 oldCodePath = mSettings.mPackages.get(pkgName).codePathString; 5657 if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) { 5658 systemApp = (ps.pkg.applicationInfo.flags &amp; 5659 ApplicationInfo.FLAG_SYSTEM) != 0; 5660 } 5661 } 5662 } 5663 5664 if (systemApp &amp;&amp; onSd) { 5665 // Disable updates to system apps on sdcard 5666 Slog.w(TAG, &quot;Cannot install updates to system apps on sdcard&quot;); 5667 res.returnCode = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; 5668 return; 5669 } 5670 5671 if (!args.doRename(res.returnCode, pkgName, oldCodePath)) { 5672 res.returnCode = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE; 5673 return; 5674 } 5675 // Set application objects path explicitly after the rename 5676 setApplicationInfoPaths(pkg, args.getCodePath(), args.getResourcePath()); 5677 pkg.applicationInfo.nativeLibraryDir = args.getNativeLibraryPath(); 5678 if (replace) { 5679 replacePackageLI(pkg, parseFlags, scanMode, 5680 installerPackageName, res); 5681 } else { 5682 installNewPackageLI(pkg, parseFlags, scanMode, 5683 installerPackageName,res); 5684 } 5685 } 关键部分在最后的5678-5684行，如果是重复安装则调用replacePackageLI，负责调用installNewPackageLI(pkg, parseFlags, scanMode,installerPackageName,res);这里以installNewPackageLI为例： 6259 /* 6260 * Install a non-existing package. 6261 */ 6262 private void installNewPackageLI(PackageParser.Package pkg, 6263 int parseFlags, 6264 int scanMode, 6265 String installerPackageName, PackageInstalledInfo res) { 6266 // Remember this for later, in case we need to rollback this install 6267 String pkgName = pkg.packageName; 6268 6269 boolean dataDirExists = getDataPathForPackage(pkg.packageName, 0).exists(); 6270 res.name = pkgName; 6271 synchronized(mPackages) { 6272 if (mSettings.mRenamedPackages.containsKey(pkgName)) { 6273 // A package with the same name is already installed, though 6274 // it has been renamed to an older name. The package we 6275 // are trying to install should be installed as an update to 6276 // the existing one, but that has not been requested, so bail. 6277 Slog.w(TAG, &quot;Attempt to re-install &quot; + pkgName 6278 + &quot; without first uninstalling package running as &quot; 6279 + mSettings.mRenamedPackages.get(pkgName)); 6280 res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS; 6281 return; 6282 } 6283 if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) { 6284 // Don&apos;t allow installation over an existing package with the same name. 6285 Slog.w(TAG, &quot;Attempt to re-install &quot; + pkgName 6286 + &quot; without first uninstalling.&quot;); 6287 res.returnCode = PackageManager.INSTALL_FAILED_ALREADY_EXISTS; 6288 return; 6289 } 6290 } 6291 mLastScanError = PackageManager.INSTALL_SUCCEEDED; 6292 PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode, 6293 System.currentTimeMillis()); 6294 if (newPackage == null) { 6295 Slog.w(TAG, &quot;Package couldn&apos;t be installed in &quot; + pkg.mPath); 6296 if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) { 6297 res.returnCode = PackageManager.INSTALL_FAILED_INVALID_APK; 6298 } 6299 } else { 6300 updateSettingsLI(newPackage, 6301 installerPackageName, 6302 res); 6303 // delete the partially installed application. the data directory will have to be 6304 // restored if it was already existing 6305 if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) { 6306 // remove package from internal structures. Note that we want deletePackageX to 6307 // delete the package data and cache directories that it created in 6308 // scanPackageLocked, unless those directories existed before we even tried to 6309 // install. 6310 deletePackageLI( 6311 pkgName, false, 6312 dataDirExists ? PackageManager.DONT_DELETE_DATA : 0, 6313 res.removedInfo, true); 6314 } 6315 } 6316 } 关键代码部分为： 6292 PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanMode, 6293 System.currentTimeMillis()); 最终回到了和开机安装一样的地方，与开机方式安装调用统一方法scanPackageLI。后续步骤则完全一致了。 从ADB工具安装过程代码解析通过adb命令方式，真实的入口其实是com/android/commands/pm/Pm.java，其中showUsage方法为使用方法说明： 1111 private static void showUsage() { 1112 System.err.println(&quot;usage: pm list packages [-f] [-d] [-e] [-s] [-e] [-u] [FILTER]&quot;); 1113 System.err.println(&quot; pm list permission-groups&quot;); 1114 System.err.println(&quot; pm list permissions [-g] [-f] [-d] [-u] [GROUP]&quot;); 1115 System.err.println(&quot; pm list instrumentation [-f] [TARGET-PACKAGE]&quot;); 1116 System.err.println(&quot; pm list features&quot;); 1117 System.err.println(&quot; pm list libraries&quot;); 1118 System.err.println(&quot; pm path PACKAGE&quot;); 1119 System.err.println(&quot; pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] [-s] [-f] PATH&quot;); 1120 System.err.println(&quot; pm uninstall [-k] PACKAGE&quot;); 1121 System.err.println(&quot; pm clear PACKAGE&quot;); 1122 System.err.println(&quot; pm enable PACKAGE_OR_COMPONENT&quot;); 1123 System.err.println(&quot; pm disable PACKAGE_OR_COMPONENT&quot;); 1124 System.err.println(&quot; pm disable-user PACKAGE_OR_COMPONENT&quot;); 1125 System.err.println(&quot; pm set-install-location [0/auto] [1/internal] [2/external]&quot;); 1126 System.err.println(&quot; pm get-install-location&quot;); 1127 System.err.println(&quot; pm createUser USER_NAME&quot;); 1128 System.err.println(&quot; pm removeUser USER_ID&quot;); 1129 System.err.println(&quot;&quot;); 1130 System.err.println(&quot;pm list packages: prints all packages, optionally only&quot;); 1131 System.err.println(&quot; those whose package name contains the text in FILTER. Options:&quot;); 1132 System.err.println(&quot; -f: see their associated file.&quot;); 1133 System.err.println(&quot; -d: filter to only show disbled packages.&quot;); 1134 System.err.println(&quot; -e: filter to only show enabled packages.&quot;); 1135 System.err.println(&quot; -s: filter to only show system packages.&quot;); 1136 System.err.println(&quot; -3: filter to only show third party packages.&quot;); 1137 System.err.println(&quot; -u: also include uninstalled packages.&quot;); ... 而安装时调用的方法即runInstall(),方法内的关键代码为： 798 PackageInstallObserver obs = new PackageInstallObserver(); 799 try { 800 mPm.installPackageWithVerification(apkURI, obs, installFlags, installerPackageName, 801 verificationURI, null); 802 803 synchronized (obs) { 804 while (!obs.finished) { 805 try { 806 obs.wait(); 807 } catch (InterruptedException e) { 808 } 809 } 810 if (obs.result == PackageManager.INSTALL_SUCCEEDED) { 811 System.out.println(&quot;Success&quot;); 812 } else { 813 System.err.println(&quot;Failure [&quot; 814 + installFailureToString(obs.result) 815 + &quot;]&quot;); 816 } 817 } 818 } catch (RemoteException e) { 819 System.err.println(e.toString()); 820 System.err.println(PM_NOT_RUNNING_ERR); 821 } 可以看出，实则调用mPm变量的installPackageWithVerification方法。mPm变量为IPackageManager接口的实现类的对象，通过78行，不难发现，其实又是绑定远程的PackageManagerService来完成具体的操作，此时就回到与网络下载的地方了，后续步骤可参加网络下载部分的分析。 53 public final class Pm { 54 IPackageManager mPm; 55 56 private WeakHashMap&lt;String, Resources&gt; mResourceCache 57 = new WeakHashMap&lt;String, Resources&gt;(); 58 59 private String[] mArgs; 60 private int mNextArg; 61 private String mCurArgData; 62 63 private static final String PM_NOT_RUNNING_ERR = 64 &quot;Error: Could not access the Package Manager. Is the system running?&quot;; 65 private static final int ROOT_UID = 0; 66 67 public static void main(String[] args) { 68 new Pm().run(args); 69 } 70 71 public void run(String[] args) { 72 boolean validCommand = false; 73 if (args.length &lt; 1) { 74 showUsage(); 75 return; 76 } 77 78 mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(&quot;package&quot;)); 79 if (mPm == null) { 80 System.err.println(PM_NOT_RUNNING_ERR); 81 return; 82 } 通过第三方应用从SD卡安装的过程代码分析这其实相当于在PackagManager之上提供一个更便捷的方式给用户安装APK，系统上层的源码中有一个类(Activity)com/android/packageinstaller/PackageInstallerActivity.java，通过它可以便捷地使UI方式安装APK。PackageInstallerActivity的oncreate方法如下(本文的采用的版本可能与读者的版本不同，所以行号和代码细节会有差异，请注意)： 235 @Override 236 protected void onCreate(Bundle icicle) { 237 super.onCreate(icicle); 238 //get intent information 239 final Intent intent = getIntent(); 240 mPackageURI = intent.getData(); 241 mPm = getPackageManager(); 242 mPkgInfo = PackageUtil.getPackageInfo(mPackageURI); 243 244 // Check for parse errors 245 if(mPkgInfo == null) { 246 Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); 247 showDialogInner(DLG_PACKAGE_ERROR); 248 return; 249 } 250 251 //set view 252 requestWindowFeature(Window.FEATURE_NO_TITLE); 253 setContentView(R.layout.install_start); 254 mInstallConfirm = findViewById(R.id.install_confirm_panel); 255 mInstallConfirm.setVisibility(View.INVISIBLE); 256 PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, 257 mPkgInfo.applicationInfo, mPackageURI); 258 PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); 259 //check setting 260 if(!isInstallingUnknownAppsAllowed()) { 261 //ask user to enable setting first 262 showDialogInner(DLG_UNKNOWN_APPS); 263 return; 264 } 265 initiateInstall(); 266 } 如265行所示，进入initiateInstall方法，跟踪可以发现，又进入startInstallConfirm()方法，这主要是弹出对话框，让用户确认是否安装，如果确认，那么即进入： 273 public void onClick(View v) { 274 if(v == mOk) { 275 // Start subactivity to actually install the application 276 Intent newIntent = new Intent(); 277 newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, 278 mPkgInfo.applicationInfo); 279 newIntent.setData(mPackageURI); 280 newIntent.setClass(this, InstallAppProgress.class); 281 String installerPackageName = getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME); 282 if (installerPackageName != null) { 283 newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); 284 } 285 if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); 286 startActivity(newIntent); 287 finish(); 288 } else if(v == mCancel) { 289 // Cancel and finish 290 finish(); 291 } 292 } 确认后，打开新的activity：InstallAppProgress，com/android/packageinstaller/InstallAppProgress．java的关键代码： 126 @Override 127 public void onCreate(Bundle icicle) { 128 super.onCreate(icicle); 129 Intent intent = getIntent(); 130 mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); 131 mPackageURI = intent.getData(); 132 initView(); 133 } ... 176 public void initView() { 177 requestWindowFeature(Window.FEATURE_NO_TITLE); 178 setContentView(R.layout.op_progress); 179 int installFlags = 0; 180 PackageManager pm = getPackageManager(); 181 try { 182 PackageInfo pi = pm.getPackageInfo(mAppInfo.packageName, 183 PackageManager.GET_UNINSTALLED_PACKAGES); 184 if(pi != null) { 185 installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; 186 } 187 } catch (NameNotFoundException e) { 188 } 189 if((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING )!= 0) { 190 Log.w(TAG, &quot;Replacing package:&quot; + mAppInfo.packageName); 191 } 192 PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, mAppInfo, 193 mPackageURI); 194 mLabel = as.label; 195 PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); 196 mStatusTextView = (TextView)findViewById(R.id.center_text); 197 mStatusTextView.setText(R.string.installing); 198 mProgressBar = (ProgressBar) findViewById(R.id.progress_bar); 199 mProgressBar.setIndeterminate(true); 200 // Hide button till progress is being displayed 201 mOkPanel = (View)findViewById(R.id.buttons_panel); 202 mDoneButton = (Button)findViewById(R.id.done_button); 203 mLaunchButton = (Button)findViewById(R.id.launch_button); 204 mOkPanel.setVisibility(View.INVISIBLE); 205 206 String installerPackageName = getIntent().getStringExtra( 207 Intent.EXTRA_INSTALLER_PACKAGE_NAME); 208 PackageInstallObserver observer = new PackageInstallObserver(); 209 pm.installPackage(mPackageURI, observer, installFlags, installerPackageName); 210 } 如上所示，209行则是执行安装的地方，不难发现，这里是pm对象在180行获取，到这里，又回到和网络下载一样的地方了，后续步骤可以参见网络下载安装部分解析。 总结 安装和卸载都是通过PackageManager，实质上是实现了PackageManager的远程服务PackageManagerService来完成具体的操作，所有细节和逻辑均可以在PackageManagerService中跟踪查看； 所有安装方式殊途同归，最终就回到PackageManagerService中，然后调用底层本地代码的installd来完成。","tags":[{"name":"APK安装","slug":"APK安装","permalink":"http://cstsinghua.github.io/tags/APK安装/"}]},{"title":"Android studio动态调试","date":"2016-06-13T07:25:56.000Z","path":"2016/06/13/Android studio动态调试指南/","text":"Android studio动态调试Android studio动态调试实际上是基于Smali Debugging，而Smali Debugging基于开源的Android反编译工具apktool。请注意： SmaliDebugging has been marked as deprecated in 2.0.3, and will be removed in 2.1. Alternative tool(s) will be linked on 2.1 release. 因此，apktool 2.0.3及其之前版本，可以直接使用apktool工具来实现动态调试；而采用apktool 2.1.0及其之后版本，需要采用独立出来的工具来调试，请参见章节2 Apktool makes possible to debug smali code step by step, watch variables, set breakpoints, etc. 本文出自apktool官方网站说明http://ibotpeaches.github.io/Apktool/documentation/ General information(概述) Generally we need several things to run Java debugging session: debugger server (usually Java VM) debugger client (usually IDE like IntelliJ, Eclipse or Netbeans) client must have sources of debugged application server must have binaries compiled with debugging symbols referencing these sources sources must be java files with at least package and class definitions, to properly connect them with debugging symbols In our particular situation we have: server: Monitor (Previously DDMS), part of Android SDK, standard for debugging Android applications - explained here client: any JPDA client - most of decent IDEs have support for this protocol. sources: smali code modified by apktool to satisfy above requirements (“.java” extension, class declaration, etc.). Apktool modifies them when decoding apk in debug mode. binaries: when building apk in debug mode, apktool removes original symbols and adds new, which are referencing smali code (line numbers, registers/variables, etc.) Info: To successfully run debug sessions, the apk must be both decoded and built in debug mode. Decoding with debug decodes the application differently to allow the debug rebuild option to inject lines allowing the debugger to identify variables and types.-d / –debug General instructions(一般性步骤)Above information is enough to debug smali code using apktool, but if you aren’t familiar with DDMS and Java debugging, then you probably still don’t know how to do it. Below are simple instructions for doing it using IntelliJ or Netbeans. Decode apk in debug mode: $ apktool d -d -o out app.apk Build new apk in debug mode: $ apktool b -d out Sign, install and run new apk. Follow sub-instructions below depending on IDE. IntelliJ (Android Studio) instructions(针对Android studio的操作步骤) In IntelliJ add new Java Module Project selecting the “out” directory as project location and the “smali” subdirectory as content root dir. Run Monitor (Android SDK /tools folder), find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”. In IntelliJ: Debug -&gt; Edit Configurations. Since this is a new project, you will have to create a Debugger. Create a Remote Debugger, with the settings on “Attach” and setting the Port to 8700 (Or whatever Monitor said). The rest of fields should be ok, click “Ok”. Start the debugging session. You will see some info in a log and debugging buttons will show up in top panel. Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”. Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc. Netbeans instructions(针对Netbeans的操作步骤) In Netbeans add new Java Project with Existing Sources, select “out” directory as project root and “smali” subdirectory as sources dir. Run DDMS, find your application on a list and click it. Note port information in last column - it should be something like “86xx / 8700”. In Netbeans: Debug -&gt; Attach Debugger -&gt; select JPDA and set Port to 8700 (or whatever you saw in previous step). Rest of fields should be ok, click “Ok”. Debugging session should start: you will see some info in a log and debugging buttons will show up in top panel. Set breakpoint. You must select line with some instruction, you can’t set breakpoint on lines starting with “.”, “:” or “#”. Trigger some action in application. If you run at breakpoint, then thread should stop and you will be able to debug step by step, watch variables, etc. Limitations/Issues(限制和已知问题)Because IDE doesn’t have full sources, it doesn’t know about class members and such.Variables watching works because most of data could be read from memory (objects in Java know about their types), but if for example, you watch an object and it has some nulled member, then you won’t see, what type this member is. apktool 2.1.0之后版本动态调试(适用于Android studio)apktool 2.1.0版本之后，smali调试的逻辑独立出来，放置在smalidea项目，请参见官方地址https://github.com/JesusFreke/smali/wiki/smalidea。依照该地址说明的步骤即可实现smali代码动态调试。","tags":[{"name":"动态调试","slug":"动态调试","permalink":"http://cstsinghua.github.io/tags/动态调试/"},{"name":"smali","slug":"smali","permalink":"http://cstsinghua.github.io/tags/smali/"},{"name":"backsmali","slug":"backsmali","permalink":"http://cstsinghua.github.io/tags/backsmali/"},{"name":"apktool","slug":"apktool","permalink":"http://cstsinghua.github.io/tags/apktool/"}]},{"title":"Android APK瘦身策略","date":"2016-06-13T06:34:28.000Z","path":"2016/06/13/Android APK瘦身初探/","text":"引言随着Android技术的发展，以及用户需求的井喷，Android应用的APK大小也随着越来越“胖”，APK在安装和更新之前都需要经过网络将其下载到手机，如果APK越大消耗的流量就会越多，特别是对于使用移动网络的用户来讲，消耗流量越多就代表需要花更多的钱去购买流量。同时一些第三方应用商城也会对上传的APK大小有限制，所以为了能够让产品能够更受商城和用户欢迎，APK瘦身是第一步，更小的APK标示着更多地用户愿意去下载和体验。因此，APK瘦身大有必要！ APK文件结构Android应用的APK文件其实就是一个压缩文件，可以用常规的压缩软件打开，查看其目录结构。为了能够减小APK的大小，首先需要知道APK由哪些部分构成，然后针对每个部分做相应的优化工作，下图是一个APK解压后的文件结构（各APK的结构核心内容是一致的，差异化的文件暂不关注）: APK目录结构 各文件的介绍如下： classes.dex：classes.dex是java源码编译后生成的java字节码文件。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。Android模拟器中提供了一个dex文件的反编译工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，找到要查看的dex文件，执行dexdump xxx.dex（或者从压缩文件取出dex文件，直接在PC上面找到dexdump.exe的路径，然后执行命令）。另外Dedexer是一个反编译dex文件的开源工具，需要自己编译源代码。而当前，还有比如dex2jar甚至封装好的GUI的工具(比如安卓逆向助手等等)可以反编译dex文件为jar文件，再利用jd-gui工具打开jar文件，就可以阅读java源代码了。 resources.arsc：编译后的二进制资源文件 AndroidManifest.xml：清单文件，该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过压缩的，可以通过AXMLPrinter2工具解开，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml proguard.cfg：代码混淆配置文件(上图中暂无包括混淆配置)； project.properties：标示APK的target sdk和依赖关系，这里的依赖关系指示的是该APK依赖到了哪些工程(上图中暂无包括依赖配置)； assets：assets目录可以存放一些配置文件（比如webview本地资源、图片资源、音视频等等），这些文件的内容在程序运行过程中可以通过相关的API（android.content.res.AssetManager）获得。 lib：lib目录下的子目录armeabi存放的是一些so文件。这个地方多讲几句，都是在开发过程中摸索出来的。eclipse在打包的时候会根据文件名的命名规则（lib**.so）去打包so文件，开头和结尾必须分别为“lib”和“.so”，否则是不会打包到apk文件中的。其他非eclipse开发环境没有测试过。如果你是用SDK和NDK开发的话，这部分很重要，甚至可以通过把一些不是so文件的文件通过改名打包到apk中，具体能干些什么那就看你想干什么了，呵呵呵！ META-INF：META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。 res：res目录存放资源文件。包括图片、字符串、raw文件夹下面的音频文件、各种xml文件等等。 优化探讨从前面的目录结构图分析可知，APK中classes.dex、lib、资源文件是大头，APK瘦身主要就是优化这三类，关于这三种类型的文件比较成熟的优化方法有： classes.dex:这是减少apk文件至关重要的第一步。你要对自己的代码了如子掌。你要移除掉所有无用处的dependency libraries，让你的代码一天比一天优秀，持续地优化你的代码。总而言之，保持一个简洁，最新的代码基础是减少apk文件至关重要的一环。当然，从零开始一个项目并为这个项目保持一份简洁的代码基础很容易。项目越老，这个工作就越困难。事实上，拥有一大段历史背景的项目必须要去处理各种死代码和无用代码。还好有许多的开发工具可以帮我们来做这些事情……Proguard 是一个很强悍的工具，它可以帮你在代码编译时对代码进行混淆，优化和压缩。它有一个专门用来减少apk文件大小的功能叫做 tree-shaking。Proguard 会遍历你的所有代码然后找出无用处的代码。所有这些不可达（或者不需要）的代码都会在生成最终的apk文件之前被清除掉。Proguard 也会重命名你的类属性，类和接口，然整个代码尽可能地保持轻量级水平。也许现在你会认为 Proguard 是一个相当有效地工具。但是能力越大，责任也就越大。现在许多开发这认为Proguard有点让人不省心，因为它会重度依赖反射。哪些类或者属性需要被处理或者不能处理都要开发者对Proguard进行配置。但通过代码混淆，删掉不必要的jar包和代码可实现dex文件的优化； lib:一个硬件设备对应一个架构（mips、arm或者x86），只保留与设备架构相关的库文件夹（主流的架构都是arm的，mips属于小众，默认也是支持arm的so的，但x86的不支持），这样可以大大降低lib文件夹的大小； 资源文件：Proguard 只会对 Java 代码起作用，那么对哪些资源文件呢？比如一张图片 my_image 在 res/drawable 文件夹中，没有被使用，Proguard 只会移除掉 R 类中的引用，但是图片依然还在文件夹中。Lint 一个静态的代码分析器，你只需通过调用 ./gradlew lint这个简单地命令它就能帮你检查所有无用的资源文件。它在检测完之后会提供一份详细的资源文件清单，并将无用的资源列在“UnusedResources: Unused resources” 区域之下。只要你不通过反射来反问这些无用资源，你就可以放心地移除这些文件了。Lint 会分析资源文件(比如 /res 文件夹下面的文件) ，但是会跳过 assets 文件 ( /assets 文件夹下面的文件)。事实上assets 文件是可以通过它们的文件名直接访问的，而不需要通过Java引用或者XML引用。因此，Lint 也不能判定某个 asset 文件在项目中是否有用。这全取决于开发者对这个文件夹的维护了。如果你没有使用某个asset 文件，那么你就可以直接清除这个文件。通过Lint工具扫描代码中没有使用到的静态资源。 上面介绍的三种类型文件的优化方案的确能够在一定程度上减小APK的大小，但在最近做项目的过程中经过研究发现还可以更进一步优化APK的大小，具体方案如下： 多分辨率适配：这里的水很深，网上也有很多文章介绍经验（比如一套图、一套布局，多套dimens.xml文件，在使用最小资源的情况下搞定多分辨率适配），Android官网也有专门的篇章介绍，详细研究可以参看； 预置数据：和游戏一样，程序和数据分离，进入模块时下载预置数据（下载的策略需要注重用户体验，在需要使用数据的地方下载）； 图片资源：压缩优化图片资源（图片资源的优化原则是：在不降低图片效果、保证APK显示效果的前提下缩小图片文件的大小。），或者使用新的图片格式，Aapt（Android Asset Packaging Tool）就内置了 保真图像压缩算法。例如，一个只需 256 色的真彩PNG图片会被aapt 通过一个颜色调色板转化成一个 8-bit PNG 文件。这可以帮助你减少图片文件的大小。当然你还可以通过Google查找相应的优化工具，比如 压缩png图片的常用工具有tinypng（https://tinypng.com）、pngquant（https://pngquant.org/）、ImageAlpha 和 ImageOptim 等。还有一种只在Android平台上存在的图片文件也可以优化，它就是 9-patches。就目前所了解的情况，还没发现针对这类图片文件的高效优化工具。然而你只需要求你的设计师将它的可扩展区域和内容区域尽可能地减少即可。这不但可以减少资源文件的大小，还能使得以后资源文件的维护变得更加简单。你可以从中选择一个适合你的工具。而Android支持的新式的图片格式webP，下面详细介绍图片资源优化(压缩)的方案。 图片压缩工具介绍1.tinypng： tinypng是一个支持压缩png和jpg图片格式的网站（https://tinypng.com），通过其独特的算法（通过一种叫“量化”的技术，把原本png文件的24位真彩色压缩为8位的索引演示，是一种矢量压缩方法，把颜色值用数值123等代替。）可以实现在无损压缩的情况下图片文件大小缩小到原来的30%-50%甚至更多。 tinypng的缺点是在压缩某些带有过渡效果（带alpha值）的图片时，图片会失真，这种图片可以将png图片转换为下面介绍的webP格式，可以在保证图片质量的前提下大幅缩小图片的大小。需要说明的是：tinypng支持png和jpg图片的压缩，并且也支持9图的压缩。 tinypng提供了开放接口供开发者开发属于自己的压缩工具，不过这是付费服务，对于普通用户来说，tinypng为每个用户提供的每月图片免费压缩数量（目前是500张/月）已经足够了。 2.使用webP图片格式： WebP是谷歌研发出来的一种图片数据格式，它是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。目前很多公司已经将webP技术运用到Android APP中，比如FaceBook、腾讯、淘宝。webP相比于png最明显的问题是加载稍慢，不过现在的智能设备硬件配置越来越高，这都不是事儿。 假如你打算在 App 中使用 WebP，除了 Android4.0 以上提供的原生支持外，其他版本以可以使用官方提供的解析库webp-android-backport编译成so使用。 通常UI提供的图片都是png或者jpg格式，我们可以通过智图或者isparta将其它格式的图片转换成webP格式，isparta可实现批量转换，墙裂推荐！ 总结APK瘦身是一个系统工程，不可能一蹴而就，而且与APK的体验及功能等密切相关，不能顾此失彼，既要保证APK和画面的质量，又要尽量减少APK的体积，因此，需要综合考虑各个因素，做出更优的策略。","tags":[{"name":"APK瘦身","slug":"APK瘦身","permalink":"http://cstsinghua.github.io/tags/APK瘦身/"}]},{"title":"python安装某些第三方包报错解决办法","date":"2016-06-13T01:57:02.000Z","path":"2016/06/13/python安装第三方包错误解决/","text":"1. python安装某些第三方包报错vcvarsall.bat原因：python安装某些第三方包(这里主要针对Windows平台)，主要是涉及系统底层和本地代码库时，需要C编译环境，Windows平台下，python本身是通过VC的编译环境编译的，不同的python版本对应不同的VC的动态库，同事，第三方库可能是采用其他编译器（比如GNU C、Cygwin、MinGW等）编译扩展的C代码。 Mingw官方链接：http://sourceforge.net/projects/mingw/ 官方说明：python3的安装包的构建主要是通过内置的Distutils工具来完成(https://docs.python.org/3.4/install/) Whenever possible, the Distutils try to use the configuration information made available by the Python interpreter used to run the setup.py script. For example, the same compiler and linker flags used to compile Python will also be used for compiling extensions. Usually this will work well, but in complicated situations this might be inappropriate. This section discusses how to override the usual Distutils behaviour. 解决方案： 安装python对应版本的VC编译器，可以直接安装整个visual studio； 如果不想整个安装VC，则可以选择安装MinGW（并将其安装后的bin等目录加入到系统path），然后配置python分发包的默认编译工具，即在python安装目录的Lib\\distutils目录下(比如安装的python3.4版本，那么即似C:\\Python34\\Lib\\distutils)，新建distutils.cfg文件(如果已有，则直接编辑之)。打开该文件，在前面添加如下内容。 [build] compiler=mingw32 上述设置之后python distutils构建带C扩展的库或者安装C扩展的库之时，全部都切换至设置的编译器，如果只是想修改某一次的构建或者安装时使用的编译器，则可以在构建或者安装的时候加上参数，如： python setup.py build --compiler=mingw32 install 2.安装某些包时报错，类似”collect2.exe: error: ld returned 1 exit status”，C:\\Python27\\libs/libpython27.a(dmmes01026.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; C:\\Python27\\libs/libpython27.a(dmmes00281.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; C:\\Python27\\libs/libpython27.a(dmmes00105.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; C:\\Python27\\libs/libpython27.a(dmmes00253.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; C:\\Python27\\libs/libpython27.a(dmmes00227.o):(.idata$7+0x0): undefined reference to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; C:\\Python27\\libs/libpython27.a(dmmes00712.o):(.idata$7+0x0): more undefined references to `_head_C__build27_cpython_PCBuild_libpython27_a&apos; follow collect2.exe: error: ld returned 1 exit status 原因：和问题1本质一样，由于Windows平台下的python编译器本身由VC环境编译，其生成的pythonxx.dll(xx是版本号，比如27、34)和pythonxx.lib等可能与需要安装的第三方库（采用Cygwin、MinGW等编译器(环境)生成并发布）无法兼容. 解决方案： To create Python extensions, you need to link against the Python library. Unfortunately, most Python distributions are provided with Pythonxx.lib, a library in Microsoft Visual C++ format. GCC expects a.a file (libpythonxx.a to be precise.). Here’s how to convert pythonxx.lib to libpythonxx.a: a.Download pexport (from here or http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/). b.Get pythonxx.dll (it should be somewhere on your harddrive). c.Run : pexports pythonxx.dll &gt; pythonxx.def This will extract all symbols from pythonxx.dll and write them into pythonxx.def. d.Run : dlltool –dllname pythonxx.dll –def pythonxx.def –output-lib libpythonxx.a This will create libpythonxx.a (dlltool is part of MinGW utilities).Copy libpythonxx.a to c:\\pythonxx\\libs\\ (in the same directory as pythonxx.lib).This trick should work for all Python versions, including future releases of Python. You can also use this trick to convert other libraries.","tags":[{"name":"安装第三方包","slug":"安装第三方包","permalink":"http://cstsinghua.github.io/tags/安装第三方包/"}]},{"title":"Hello World","date":"2016-06-13T01:57:02.000Z","path":"2016/06/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment For Test: 文件下载","tags":[{"name":"杂项","slug":"杂项","permalink":"http://cstsinghua.github.io/tags/杂项/"}]},{"title":"推送方案","date":"2016-06-08T09:09:16.000Z","path":"2016/06/08/推送方案/","text":"本文梳理当前主流的推送技术，对里面涉及到的概念和技术进行全面的阐述 推送简介推送技术，又名反向AJAX，指的是一种基于Internet，将由中心或发布者发出消息传输给用户的技术。与之相对的是拉取（参见AJAX），这种情况下请求是由用户或客户端主动向服务端发起，以拉取消息。(摘自维基百科) 在移动互联网时代以前的手机，如果有事情发生需要通知用户，则会有一个窗口弹出，将告诉用户正在发生什么事情。可能是未接电话的提示，日历的提醒，或是一封新的彩信。推送功能最早是被用于Email中，用来提示我们新的信息。由于时代的发展和移动互联网的热潮，推送功能更加地普及，已经不再仅仅用在推送邮件了，更多地用在我们的APP中了。 当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震应急通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息，一般来说有两种方法：第一种是客户端使用Pull（拉）的方式，就是隔一段时间就去服务器上获取一下信息，看是否有更新的信息出现。第二种就是 服务器使用Push（推送）的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。这样，客户端就能自动的接收到消息。 虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能，但是明显来说Push方式比Pull方式更优越。因为Pull方式更费客户端的网络流量，更主要的是费电量，还需要我们的程序不停地去监测服务端的变化。 在开发Android和iPhone应用程序时，我们往往需要从服务器不定的向手机客户端即时推送各种通知消息。我们只需要在Android或IPhone的通知栏处向下一拉，就展开了Notification Panel，可以集中一览各种各样通知消息。目前IOS平台上已经有了比较简单的和完美的推送通知解决方案(参见下文APNs)，可是Android平台上实现则是乱象丛生，当然也可以说是百家争鸣。下文会详细介绍。 怎么实现推送及各种方式的比较从上面推送的介绍可知，要实现消息推送，肯定存在多种思路和方案。 一些分析文章或链接： tokudu写的较全面分析推送机制的原创文章 http://www.cnblogs.com/hanyonglu/archive/2012/03/04/2378971.html http://blog.csdn.net/shagoo/article/details/7899466 http://my.oschina.net/nicsun/blog/98184?fromerr=P9V1ZUai 这里罗列出目前收集到的推送实现机制： 1. Poll(轮询)：从名字很明显就告诉你，它甚至不是一种真正的推送。该方式基于从后台的本地或远程服务周期性地从服务器轮询获取消息。轮询越频繁，那么就获取更加实时的推送。实现轮询的方式很多种，比如可以采用HTTP协议。 优点: 实现简单，成本低。 缺点: 实时性差，更严重地是, 轮询较15-30次/分钟更频繁的话，将会很快耗尽电池电量。参见一些实验数据: https://labs.ericsson.com/apis/mobile-java-push/blog/save-device-battery-mobile-java-push 2. SMS(短信) ：Android系统运行应用拦截SMS短信息。当有新的事件时，服务器发送一掉经过特别加密处理的SMS到手机端。此时，APP可以拦截所有的短信，并从中找到来自自己服务器发出的消息，然后弹出一个通知。 优点: 实现简单，实时性非常好. 缺点: 对应应用开发者和用户来说代价高昂. 发送SMS需要成本，不同的运营商的策略都有差异，如果想实现基于SMS的全球性的推送，那么开发者很可能需要为此支付大笔金钱。站在用户的角度，保护隐私，以及不愿意因为使用APP而付出额外的SMS费用，都是必须考虑的事情。 3. Persistent TCP/IP(TCP长连接)：手机端与服务器之间建立一条TCP长连接(大部分时间处于idle空闲状态)，并且通过偶尔发送心跳包来使长连接保持存活。一旦服务端有新的事件，则可以通过这条长连接来发送消息到客户端。 术语解释：Client/Server通信方式建立后，下一步就需要考虑通信连接的方式，主要有两种方式的连接，即长连接通信与短连接通信。关于TCP/IP的相关知识和原理可以参见《TCP/IP详解》(W.Richard Stevens著)短连接：短连接通信是指 Client 方与 Server 方每进行一次通信报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于多个 Client 连接一个 Server 情况，常用于机构与用户之间通信，比如 OLTP（联机事务处理）类应用。在短连接情况下，Client 端完成任务后，就关闭连接并退出。在 Server 端，可以通过循环 accept()，使 Server 不会退出，并连续处理 Client 的请求。长连接：长连接通信是指 Client 方与 Server 方先建立通讯连接，连接建立后不会断开，然后再进行报文发送和接收，报文发送与接收完毕后，原来连接不会断开而继续存在，因此可以连续进行交易报文的发送与接收。这种方式下由于通讯连接一直存在，其 TCP/IP 状态是 Established，可以用操作系统的命令 netstat 查看连接是否建立。由于在长连接情况下，Client 端和 Server 端一样可以固定使用一个端口，所以长连接下的 Client 也需要使用 bind() 来绑定 Client 的端口。在长连接方式下，需要循环读写通信数据。为了区分每一次交易的通信数据，每一次交易数据常常需要在数据头部指定该次交易的长度，接收 API 需要首先读出该长度，然后再按该长度读出指定长度的字节。长连接方式常用于一个 Client 端对一个 Server 端的通讯，一般常用于机构与机构之间的商业应用通信，以处理机构之间连续的大量的信息数据交换。或者说可用于两个系统之间持续的信息交流情况。通常为了加快两个系统之间的信息交流，通常还需要建立几条长连接的并行通信线路。 优点: 实时性好 缺点: 很难在客户端和服务端之间实现可靠的长连接(服务)。IOS系统不允许APP驻留在后台，而Android系统也会在系统可用内存很少的时候杀掉某些服务，所以推送通知服务很可能就被杀掉。另外，一旦手机进入睡眠状态，这个时候正常情况下也是无法接收和处理服务器发送的消息。而且在耗电方面，也需要谨慎对待。 前面两种方式都有比较明显的缺点，而且对此我们无能为力。但是，第三种方式，即TCP长连接的缺点并非那么严重。只要我们进行良好的设计和付出努力，长连接方式可以较好地工作。毕竟，GMail, GTalk以及Google Voice都可以实现实时更新。事实上，非常多的开发者都认同TCP长连接可能是实现推送的最佳方式。而市场上主流的推送方案，包括IOS和Android官方的推送方案在本质上都是采用了TCP长连接的机制来实现。本质上，APNs 与GCM是类似的技术实现原理：即系统层有一个常驻的 TCP 长连接，一直保持的长连接，即使手机休眠的时候也在保持的长连接。 当前主流的推送方案先看看主流平台官方的方案吧。当前移动端的两大平台IOS和Android均有自己官方的推送解决方案。 IOS平台： APNs （Apple Push Notification service），官方链接：苹果推送APNs官网 Android平台： GCM (Google Cloud Messaging），官方链接：Google官方推送GCM 值得一提的是，Google官方最初退出的推送方案是Android Cloud to Device Messaging (C2DM) ，已被废弃，于2015.10.20完全关闭。关于C2DM和GCM的差异，以及从C2DM迁移到GCM，可以参见C2DM迁移到GCM 除了官方的方案，也存在很多第三方解决方案，这里只提国内的，原因你懂的。目前主要有： 较早的：JPush、个推 后来的：腾讯的信鸽、小米推送、百度推送、华为推送、友盟推送等 关于第三方推送方案的使用统计，可以参见GitHub上面的一个调查：Android 第三方 Push 推送方案使用调查 正如前文提到，目前上述方案基本都是基于长连接的方式来实现。而平台自身提供的方案将实现长连接的服务内置在系统内部，这样就即使APP进程被kill了，那么仍然可以接受消息。而第三方的方案，一旦APP进程被kill(准确来说是实现长连接的service所在的进程)，那么就无法接受推送的消息了。 大家在本质上都是采用长连接，但是基于长连接来实现推送，在上层实现方面存在很多的协议和具体方案： 使用MQTT协议 MQTT(MQ Telemetry Transport)是IBM开发的基于轻量级的、基于”发布/订阅”模式的消息传输协议,用于有限制的设备(比如嵌入式设备)和低带宽、高延迟或不可靠的网络。 MQTT官网：http://mqtt.org/ 当前已有多个基于MQTT协议的推送开源项目： tokudu达人的开源项目：MQTT客户端项目、MQTT服务端PHP实现 IBM官方的开源实现：paho项目、MQTT broker 其他：MQTT客户端实现 优点：协议简洁、小巧、可扩展性强、省流量、省电，应用到企业领域，已有多个开源项目提供参考。 缺点：不够成熟、实现较复杂，部署硬件成本较高。 使用XMPP协议（Openfire + Spark + Smack） XMPP（Extensible Messageing and Presence Protocol：可扩展消息与存在协议）是目前主流的四种IM（IM：instant messaging,即时消息）协议之一，其他三种分别为：即时信息和空间协议(IMPP)、空间和即时信息协议(PRIM)、针对即时通讯和空间平衡扩充的进程开始协议SIP(SIMPLE)。其是基于XML协议的通讯协议，前身是Jabber，已由IETF国际标准化组织完成了标准化工作。 Spark,smack和Openfire，这三个合起来就是一个完整的XMPP IM实现。包括服务器端——Openfire，客户端——Spark，XMPP 传输协议的实现——Smack（记住，XMPP是一个协议，协议是需要实现的，Smack起到的就是这样的一个作用）。三者都是基于Java 语言的实现。 当前已有基于XMPP开发Android推送的开源项目：androidpn项目 优点：协议成熟、强大、可扩展性强、主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。 缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。 自主开发协议 自主开发相关协议，实现可靠长连接和服务端。比如各大互联网公司推出的推送方案(当然，这里面很多其实是在一些开源项目上进行二次开发而成) 优点：完全自主设计，可控，不用担心数据外泄。 缺点：实现难度大，开发成本很高 我们的推送方案基于上面的信息，对于一个普通公司，如果想在自己的APP里面实现推送，可以有如下一些方式： 集成官方推送，比较靠谱，但是Android平台下，由于众所周知的原因，你懂的，GCM基本无法满足要求； 集成第三方推送，简单，也比较可靠，比如集成个推推送，但是存在一些问题： 需要向第三方支付费用，可能费用不菲 数据存在泄露的风险 自主开发 如果完全另起炉灶，那难度比较大，成本也很高。因此基于现有的MQTT或XMPP协议，及其相关的开源项目，是比较可行的方案。 那么到底选择哪一个协议呢？待续！个人倾向于MQTT协议，因为其更轻量级，对于流量和电量的消耗相对更少，而且现有的服务端实现Mosquitto的单机性能也非常不错，且可以实现集群部署。 当然，自主设计存在以下一些问题需要解决： 稳定保持长连接； 服务端的设计，怎么考虑跨多个平台(另外，富媒体消息等，不仅仅是服务端推送，业务端上行upstream，支持多种协议，以及后续其他扩展)，怎么支持2000K甚至更高并发量的长连接及其服务器集群设计； 推送ID策略的设计 再论长连接长连接方案乍一听怪怪的, 对网络通信或TCP/IP协议族不是很了解人难免会问：什么是长连接? 定时发送心跳, 这和轮询有什么区别? 心跳是干什么的? 同样是定期和服务器沟通, 为什么长连接就比轮询更加优秀? 手机休眠了TCP连接不会断掉吗? 什么是长连接与长连接相对的就是短连接。先说短连接, 短连接是通讯双方有数据交互时就建立一个连接, 数据发送完成后，则断开此连接. 短连接和长连接示意图 长连接就是大家建立连接之后, 不主动断开。 双方互相发送数据, 发完了也不主动断开连接, 之后有需要发送的数据就继续通过这个连接发送。 TCP连接在默认的情况下就是所谓的长连接(前提是应用层没有设置keepalive，下文会做摘要介绍，详细内容关于keepalive请参见《TCP/IP详解 卷1 协议》第二版第17章), 也就是说连接双方都不主动关闭连接, 这个连接就应该一直存在。以下英文段落摘自《TCP/IP详解 卷1 协议》第二版第17章(p793)的引言部分。 Many newcomers to TCP/IP are surprised to learn that no data whatsoever flows across an idle TCP/IP connection.This is，if neither process at the ends of a TCP connection is sending data to the other,nothing is exchanged between the two TCP endpoints.There is no polling,for example,as you might find with other networking protocols.This means that we can start a client process that establishes a TCP connection with a sever and walk away for hours,days,weeks,or months,and the connection should remain up.In theory, intermediate routers can crash and reboot,data lines may go down and back up,but as long as neither host at the ends of the connection reboots(or changes its IP address),the connection remainsestablished.This is how TCP/IP was designed. Note: The previous statement assumes that neither application——neither the client nor the server——has application-level timers to detect inactivity,causing either application to terminate.It also assumes that no intermediate router is keeping state about the connection(such as a NAT box)that is required for proper operation that it might delete because of inactivity or lose because of system failure.In today’s Internet，these are big assumptions. 关于TCP keepalive： TCP keepalive is a controversial feature.Either end of a TCP connection may request keepalives,which are turned off by default，for their respective direction of the connection.A keepalive can be set for one side,both sides,or neither side.There are several configurable parameters that control ths operation of keepalives.If there is no activity on the connection for some period of time(called the keepalive time),the side(s) with keepalive enabled sends a keepalive probe to its peer(s).If no response is received,the probe is repeated periodically with a period set by the keepalive interval until a number of probes equal to the number keepalive probes is reached.If this happens,the peer’s system is determined to be unreachable and the connection is terminated. The value KeepaliveTime defaults to 7,200,000ms(2 hours);KeepaliveInterval defaults to 1000ms(1s).If there is no response to ten keepalive probes,Windows terminates the connection. Note that [RFC1122] places certain restrictions on the use of keepalives.In particular,the keepalive time must beconfigurable and must not default to less than 2 hours.In addition,keepalives must not be enabled unless an application requests one(although this behavior is violated if the net.inet.tcp.alwayskeepalive variable is set).Linux does not provide a native facility for adding keepalives to applications that do not request it,but a special library can be preloaded(i.e., loaded prior to ordinary shared libraries)to get this effect [LKA]. 但是网络中的情况是复杂的, 这个连接可能会被切断。比如客户端到服务器的链路因为故障断了, 或者服务器宕机了, 或者是你家网线被人剪了, 这些都是一些莫名其妙的导致连接被切断的因素, 还有几种比较特殊的： NAT条目老化或超时 因为IPv4地址不足， 或者我们想通过无线路由器上网， 我们的设备可能会处在一个NAT设备的后面,用户终端或PC实际分配到的IP是私有IP。而NAT设备的出口则是公有IP，当然也存在多级NAT级联的情况。生活中最常见的NAT设备是家用路由器。关于NAT技术和原理请参见经典文章http://www.bford.info/pub/net/p2pnat/ NAT设备会在IP封包通过设备时修改源/目的IP地址。对于家用路由器来说， 使用的是网络地址端口转换(NAPT，Network Address/Port Translation)， 它不仅改IP，还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP。 举个例子， NAPT维护一个类似下表的NAT表。 内网地址 外网地址 192.168.0.2:5566 120.132.92.21:9200 192.168.0.3:7788 120.132.92.21:9201 192.168.0.3:8888 120.132.92.21:9202 NAT设备会根据NAT表对出去和进来的数据做修改， 比如将192.168.0.3:8888发出去的封包改成120.132.92.21:9202， 外部就认为他们是在和120.132.92.21:9202通信。 同时NAT设备会将120.132.92.21:9202收到的封包的IP和端口改成192.168.0.3:8888， 再发给内网的主机， 这样内部和外部就能双向通信了， 但如果其中192.168.0.3:8888 == 120.132.92.21:9202这一映射因为某些原因被NAT设备淘汰了， 那么外部设备就无法直接与192.168.0.3:8888通信了。 我们的设备经常是处在NAT设备的后面， 比如在公司的内部网络内， 查一下自己分配到的IP，其实是内网IP，表明我们在NAT设备后面。 一般情况下，在网络设备比如路由器上面，NAT条目(表)存在老化时间(参见《TCP/IP详解 卷1 协议》第二版第7章)，超过老化时间(一般SOHO级路由器如TP-LINK路由器UDP对应的NAT条目老化时间在5min左右，而TCP也相差不大)，则会清空对应的NAT条目。此外，大部分移动无线网络运营商在链路上一段时间内没有数据通讯后，会淘汰NAT表中的对应项， 造成链路中断。 网络状态切换 手机网络和WIFI网络切换， 网络断开和连上等情况， 也会使长连接断开。 这里原因可能比较多， 但结果无非就是IP变了， 或者被系统通知连接断了。 DHCP的租期 一般而言，PC端或手机终端获取IP地址的方式大多是动态获取，即通过DHCP协议从DHCP服务器(一般由路由器同时兼任)获取。目前测试发现安卓系统对DHCP的处理有Bug， DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。 心跳包的作用从《TCP/IP详解 卷1 协议》可知，TCP长连接本质上不需要心跳包来维持。那为什么要有心跳包呢? 其实主要是为了防止上面提到的NAT超时，既然一些NAT设备判断是否淘汰NAT映射条目的依据是一定时间内没有数据，那么客户端就主动发一个数据。 当然，如果仅仅是为了防止NAT超时，可以让服务器来发送心跳包给客户端，不过这样做有个弊病就是，万一连接断了，服务器就再也联系不上客户端了，所以心跳包必须由客户端发送，客户端发现连接断了，还可以尝试重连服务器。 所以心跳包的主要作用是防止NAT超时，其次是探测连接是否断开。最终目的也就是判断长连接是否存活有效。 链路断开，没有写操作的TCP连接是感知不到的，除非这个时候发送数据给服务器，造成写超时，否则TCP连接不会知道断开了。主动kill掉一方的进程。 另一方会关闭TCP连接。是系统代进程给服务器发的FIN。TCP连接就是这样。只有明确的收到对方发来的关闭连接的消息(收到RST也会关闭, 大家都懂)。或者自己意识到发生了写超时， 否则它认为连接还存在。 心跳包的时间间隔既然心跳包的主要作用是防止NAT超时， 那么这个间隔就大有文章了。 发送心跳包势必要先唤醒设备， 然后才能发送， 如果唤醒设备过于频繁， 或者直接导致设备无法休眠， 会大量消耗电量， 而且移动网络下进行网络通信， 比在wifi下耗电得多。所以这个心跳包的时间间隔应该尽量的长， 最理想的情况就是根本没有NAT超时。 现实是残酷的，根据网上的一些说法，中移动2/3G下，NAT超时时间为5分钟，中国电信3G则大于28分钟，理想的情况下，客户端应当以略小于NAT超时时间的间隔来发送心跳包。 wifi下， NAT超时时间都会比较长， 据说宽带的网关一般没有空闲释放机制， GCM有些时候在wifi下的心跳比在移动网络下的心跳要快， 可能是因为wifi下联网通信耗费的电量比移动网络下小。 关于如何让心跳间隔逼近NAT超时的间隔， 同时自动适应NAT超时间隔的变化， 可以参看Android微信智能心跳方案。 怎样发送心跳包Android手机可以进入休眠状态，为了不让NAT映射条目失效，我们需要定时的发心跳，以刷新NAT表项，避免被淘汰。 Android 上定时运行任务常用的方法有2种，一种方法用Timer，另一种是AlarmManager。 Timer Android的Timer类可以用来计划需要循环执行的任务，Timer的问题是它需要用WakeLock让CPU保持唤醒状态(即Timer的时钟是依赖于CPU的)，这样会大量消耗手机电量，大大减短手机待机时间。这种方式不能满足我们的需求。 AlarmManager AlarmManager是Android系统封装的用于管理RTC的模块，RTC(Real Time Clock)是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。 这意味着，如果我们用AlarmManager来定时执行任务，CPU可以正常的休眠，只有在需要运行任务时醒来一段很短的时间。 关于Android的休眠和AlarmManager定期执行发送心跳包，可以参见下文的详细阐述。 服务器如何处理心跳包如果客户端心跳间隔是固定的， 那么服务器在连接闲置超过这个时间还没收到心跳时， 可以认为对方掉线， 关闭连接。 如果客户端心跳会动态改变，如上节提到的微信心跳方案， 应当设置一个最大值， 超过这个最大值才认为对方掉线。还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时。 可以直接认为对方掉线。这个就需要具体业务具体分析了，也许还有更优的策略， 这里就不写了。 心跳包和轮询的区别心跳包和轮询看起来类似， 都是客户端主动联系服务器， 但是区别很大。 轮询是为了获取数据， 而心跳是为了保活TCP连接； 轮询得越频繁， 获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系； 轮询比心跳能耗更高， 因为一次轮询需要经过TCP三次握手， 四次挥手， 单次心跳不需要建立和拆除TCP连接。 TCP唤醒Android至此，我们可以维护稳定的长连接了，但是要长连接只是推送的基础，要想服务端的推送消息实时达到客户端(通过长连接)，还有更多事情要做。 首先，也是最棘手的问题，如果Android手机休眠了，这个时候服务端通过长连接发送的数据能被手机接收到吗？其次，即使手机能接收到数据，那么又是怎么唤醒手机CPU来显示通知消息以及执行相关APP逻辑呢？ 要回答以上的问题，我们必须了解Android系统的休眠原理，以及Android手机的硬件架构。 Android手机的硬件架构引用1：以下英文部分摘自书籍《Developing Software for Symbian OS 2nd Edition: A Beginner’s Guide to Creating Symbian OS v9 Smartphone Applications in C++ 》，作者：Steve Babin。Google图书上的链接Developing Software for Symbian OS 2nd Edition。注：京东和亚马逊均有售。 Two-processor smartphone model Typically,a smartphone contains two processors:a baseband processor and an application processor(sometimes known as the radio and PDA processors).Figure 3.5 shows a typical high-level view of a two-processor system. The baseband processor runs on the low-level radio telephony protocols,like the GSM signaling stack mentioned before.Baseband software is time-critical and requires a real-time operating system(RTOS).The RTOS can be proprietary,or a commercial one such as Nucleus,OSE,or VRTX.The application processor runs Symbian OS and its applications.An IPC(inter-processor communication)mechanism is supplied to communicate between the two processors when needed. Why the need for two processors?The main reason is because Symbian OS(EKA1) does not provide the real-time response needed for the baseband software,thus requiring a dedicated processor running an RTOS.With EKA2,however,this is no longer a restriction,as shown in the next section. 引用2：另外，维基百科上面的描述如下(链接为https://en.wikipedia.org/wiki/Baseband_processor)： A baseband processor (also known as baseband radio processor, BP, or BBP) is a device (a chip or part of a chip) in a network interface that manages all the radio functions (all functions that require an antenna); however, this term is generally not used in reference to Wi-Fi and Bluetooth radios. A baseband processor typically uses its own RAM and firmware. == Overview == Baseband processors typically run a real-time operating system (RTOS) as their firmware, such as ENEA AB|ENEA’s Operating System Embedded|OSE, Nucleus RTOS (iPhone 3G/3GS/iPad), ThreadX (iPhone 4), and Versatile Real-Time Executive|VRTX. There are more than a few significant manufacturers of baseband processors, including Broadcom, Icera, Intel Mobile Communications (former Infineon wireless division), MediaTek, Qualcomm, Spreadtrum, and ST-Ericsson. The rationale of separating the baseband processor from the main processor (known as the AP or Application Processor) is threefold: Radio performance Radio control functions (signal modulation, encoding, radio frequency shifting, etc.) are highly timing-dependent, and require a real-time operating system. Legal Some authorities (e.g. the U.S. [[Federal Communications Commission]] (FCC)) require that the entire software stack running on a device which communicates with the cellular network must be certified. Separating the BP into a different component allows reusing them without having to certify the full AP. Radio reliability Separating the BP into a different component ensures proper radio operation while allowing application and OS changes. 引用3：此外，虽然在Android开发官网上面没有搜索到BP的介绍，但是在其中一个页面，出现了这个术语。http://developer.android.com/intl/zh-cn/reference/android/app/ActivityManager.MemoryInfo.html 引用4：在链接http://www.wisegeek.com/what-is-a-baseband-processor.htm上也有一段关于智能手机BP和CPU独立开来的背景方面比较详细的阐述。 Mobile phones and other devices typically require considerable processing power to control their computational and communications functions. The Central Processing Unit (CPU) of such a device allows for many functions, and often includes several software applications and drivers. Most mobile communications devices also include a Baseband Processor (BP), separate from the CPU. Generally, it manages the radio control functions, such as signal generation, modulation, encoding, as well as frequency shifting. It can also manage the transmission of signals. The baseband processor is typically located on the same circuit board as the CPU, but consists of a separate radio electronics component. It can therefore have a different programming interface and control software. The hardware function is often independent of the operations of other phone components as well. A benefit to this is usually that changes to software applications and operating systems do not affect the operation of the BP. Software bugs can affect other capabilities, but the baseband processor will usually function without a problem in such a case. An applications processor is often used to manage all of the software programs on a device. A separate baseband processor can also enable phone designers to create applications and user interfaces without having to worry about changes to the BP or the way radio signals are processed. Wireless communication capabilities have continued to increase through the early 21st century. Some baseband radio processor models can handle many channels at once, usually while processing all receive and transmit demands. This type of device sometimes includes multiple processing components. One kind has four, so it can combine parameter estimation, signal searching, transmission, and receiving functions and other capabilities. The BP can also search for mobile signals and track them, as well as select antennas automatically. In many cases, a baseband processor is contained in a common integrated circuit package, such as a ball grid array. Low power models are often available as well. As of 2011, baseband processor capabilities are often supportive of the fourth generation protocols for wireless communication. The processor is often part of the device’s modem, and can include other features such as Flash memory. A low power memory baseband processor often has connections to common interfaces, such as Universal Serial Bus (USB) found in most computers and mobile devices. The design of separate processors in a phone is not only efficient, but able to prevent malfunctions due to software bugs, which could cause widespread phone problems as well as network issues. 从上面的信息可知，我们可以认为Android手机有两个处理器(即使从物理形态上是一个CPU，但BP和CPU即AP在逻辑上应该是独立的)，一个叫Application Processor(AP)，一个叫Baseband Processor(BP)。AP是ARM(或x86等)架构的处理器，用于运行Android系统和应用程序；BP用于运行实时操作系统(RTOS)，通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP，LCD，WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。 Android的休眠(睡眠)机制和唤醒机制Android的休眠(睡眠)机制要准确定义Android设备的电源状态，其实比较难，因为目前没有找到官方对此的规范定义。而网上的资料则众说纷纭，莫衷一是。不过综合各家意见来看，本人比较倾向于如下的状态划分： sleep stages/levels awake dim screen off CPU off (true “sleep” or “deep sleep”) power off 其中2、3、4属于广义的sleep范畴。当然，如果将键盘等设备也纳入考虑的话，上面的划分还需要更细一些，这里未作考虑。 When an Android device is left idle, it will first dim, then turn off the screen, and ultimately turn off the CPU. This prevents the device’s battery from quickly getting drained(参见http://developer.android.com/intl/zh-cn/training/scheduling/index.html) Android的WakeLock机制Android系统是通过WakeLock来实现唤醒CPU、屏幕、键盘及其他相关硬件组件的。以下英文内容摘录自wakelocks-for-android和Wakelocks: Detect No-Sleep Issues in Android* Applications Wakelock：A wakelock is a software mechanism to control the power state of the host device. The OS exports explicit power management handles and APIs to specify when a particular component needs to stay on, or awake, until it is explicitly released from duty. The wakelock mechanism is implemented in two levels: user and kernel. The figure shows the internal design of Android wakelock implementation. The user wakelock can be utilized by either high-level OS services or applications and is provided by the power management service. It allows an application to control the power state of the device. A kernel wakelock is held by the OS kernel or a driver. A user wakelock is mapped to a kernel wakelock. Any active kernel-level wakelock prevents the system from being suspended to ACPI S3 (suspended to RAM) state, which is the highest power saving state for mobile devices. Android Android User WakelocksAndroid设备的电源状态可以通过android.os.PowerManager类来控制(参见Android开发官网的API介绍)。这是比较细粒度控制电源状态的方式，如果是更便捷地控制，可以参见Managing Device Awake State 示例代码： PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, &quot;My Tag&quot;); wl.acquire(); ..screen will stay on during this section.. wl.release(); Android设备的休眠分为以下几个等级(最高等级的休眠是屏幕、键盘、CPU全部休眠)： Flag Value CPU Screen Keyboard 睡眠状态 Off Off Off PARTIAL_WAKE_LOCK On* Off Off SCREEN_DIM_WAKE_LOCK On Dim Off SCREEN_BRIGHT_WAKE_LOCK On Bright Off FULL_WAKE_LOCK On Bright Bright Note that since API level 17, FULL_WAKE_LOCK has been deprecated. Applications should use FLAG_KEEP_SCREEN_ON. 上面表格中的*表示：如果你持有一个partial wake lock， 无论任何的显示超时或屏幕状态甚至即使用户按下电源键，CPU都将会保持运行。在其他的wake locks机制下，CPU将会保持运行，但是用户可以通过按下电源键使得设备进入睡眠。 此外， 我们可以添加两个额外的flag，flag仅仅会影响屏幕的行为。不过这两个flag与PARTIAL_WAKE_LOCK组合使用时将无任何效果。 Flag Value Description ACQUIRE_CAUSES_WAKEUP Normal wake locks don’t actually turn on the illumination. Instead, they cause the illumination to remain on once it turns on (e.g. from user activity). This flag will force the screen and/or keyboard to turn on immediately, when the WakeLock is acquired. A typical use would be for notifications which are important for the user to see immediately. ON_AFTER_RELEASE If this flag is set, the user activity timer will be reset when the WakeLock is released, causing the illumination to remain on a bit longer. This can be used to reduce flicker if you are cycling between wake lock conditions. 任何使用WakeLock的应用程序必须在清单文件manifest.xml中标签下添加android.permission.WAKE_LOCK权限。 Android Kernel WakelocksKernel wakelocks are low-level wakelocks held by the kernel. They can be acquired/ released internally from the kernel. As such, application developers have less direct control on them, but an application’s behaviour can indirectly trigger these wakelocks and increase battery consumption inadvertently. Here are examples of kernel wakelocks. Wlan_rx: Held by the kernel when data is sent or received over Wi-Fi*. PowerManagerService: Is the container for all partial wakelocks. Sync: Held while the sync process is running. Alarm_rtc: Handles the alarm (when an application or process checks periodically on something). Main: Keeps the kernel awake. This is the last one to be released when the system goes to suspend mode. 可以注意到，Wlan_rx内核wakelock，因此可以确认WIFI连接下数据接收可以唤醒CPU。 Android的网络数据怎样唤醒CPU？如上面所述，Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。 完全没必要担心AP休眠会导致收不到消息推送。通讯协议栈运行于BP，一旦收到数据包。BP会将AP唤醒。唤醒的时间足够AP执行代码完成对收到的数据包的处理过程。其它的如Connectivity事件触发时AP同样会被唤醒。那么唯一的问题就是程序如何执行向服务器发送心跳包的逻辑。你显然不能靠AP来做心跳计时。Android提供的Alarm Manager就是来解决这个问题的。RTC (Real Time Clock) 是一个独立的硬件时钟，可以在CPU休眠时正常运行，在预设的时间到达时，通过中断唤醒CPU。那么Wake Lock API有啥用呢？ 比如心跳包从请求到应答，比如断线重连重新登陆这些关键逻辑的执行过程，就需要Wake Lock来保护。而一旦一个关键逻辑执行成功，就应该立即释放掉Wake Lock了。两次心跳请求间隔5到10分钟，基本不会怎么耗电。除非网络不稳定，频繁断线重连，那种情况办法不多。 移动网络下， 网络数据通过BP来完成，BP接收到网络数据，将唤醒CPU，然后CPU执行后续逻辑。 Wifi连接下，目前了解到的情况是，WIFI可以休眠，即设备进入sleep状态时，WIFI也可以进入sleep，一旦WIFI进入sleep，则WIFI连接断开，无法接收到服务端下发的数据了。而且一旦WIFI断开，那么手机将会切换到蜂窝移动网络链接，此时也会造成IP地址更换，进而导致长连接断开。另外，据不可考证的信息，WIFI连接下数据传输消耗的电量较蜂窝移动网络少。当然有说法是WIFI待机状态的电量消耗反过来比蜂窝移动网络standby时消耗电量多。所以，一般是建议让WIFI一直不会进入休眠状态(Never)。而WIFI连接收到网络数据时，通过Wlan_rx内核WakeLock唤醒CPU，继而执行后续的APP逻辑(不过该部分的官方资料暂未找到)。那么，怎样设置WIFI的休眠策略呢，Android官方有相关的配置供参考WIFI_SLEEP_POLICY，API Level17以后则是http://developer.android.com/intl/zh-cn/reference/android/provider/Settings.Global.html#WIFI_SLEEP_POLICY。 示例代码： 那么我们在开启应用时，首先取出这个值，代码： private void setWifiDormancy() { int value = Settings.System.getInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY, Settings.System.WIFI_SLEEP_POLICY_DEFAULT); final SharedPreferences prefs = getSharedPreferences(getString(R.string.wifi_sleep_policy), Context.MODE_PRIVATE); Editor editor = prefs.edit(); editor.putInt(getString(R.string.wifi_sleep_policy_default), value); editor.commit(); if(Settings.System.WIFI_SLEEP_POLICY_NEVER != value) { Settings.System.putInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY, WIFI_SLEEP_POLICY_NEVER); } } 在应用退出我们需将这个设置的值还原： private void restoreWifiDormancy() { final SharedPreferences prefs = getSharedPreferences(getString(R.string.wifi_sleep_policy), Context.MODE_PRIVATE); int defaultPolicy = prefs.getInt(getString(R.string.wifi_sleep_policy_default), Settings.System.WIFI_SLEEP_POLICY_DEFAULT); Settings.System.putInt(getContentResolver(), Settings.System.WIFI_SLEEP_POLICY, defaultPolicy); } 这样初始设置，退出还原我们可以让应用一直处于wifi模式下（不过前提是有wifi网络哦）。 推送中最重要的部分就是让手机尽量休眠，只有在服务器需要它处理数据时才唤醒它，这正好符合我们的要求。","tags":[{"name":"Push","slug":"Push","permalink":"http://cstsinghua.github.io/tags/Push/"},{"name":"推送","slug":"推送","permalink":"http://cstsinghua.github.io/tags/推送/"},{"name":"长连接","slug":"长连接","permalink":"http://cstsinghua.github.io/tags/长连接/"},{"name":"进程保活","slug":"进程保活","permalink":"http://cstsinghua.github.io/tags/进程保活/"},{"name":"定时器","slug":"定时器","permalink":"http://cstsinghua.github.io/tags/定时器/"},{"name":"Timer","slug":"Timer","permalink":"http://cstsinghua.github.io/tags/Timer/"}]}]