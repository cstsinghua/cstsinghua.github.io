<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?5bdd93f06ab5180cf97a5e1c1033c6ef"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    <link rel="canonical" href="http://cstsinghua.github.io/2016/06/13/Android动态加载机制/">
    
    
    <title>Android动态加载机制 | Atypical programmer | 做一个非典型程序员</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="动态加载">
    <meta name="description" content="1.引言在Android开发中，存在一些场景：

在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？ 引用官方原文http://developer.android.com/intl/zh-cn/tools/building/multidex.html">
<meta property="og:type" content="article">
<meta property="og:title" content="Android动态加载机制">
<meta property="og:url" content="http://cstsinghua.github.io/2016/06/13/Android动态加载机制/index.html">
<meta property="og:site_name" content="Atypical programmer">
<meta property="og:description" content="1.引言在Android开发中，存在一些场景：

在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？ 引用官方原文http://developer.android.com/intl/zh-cn/tools/building/multidex.html">
<meta property="og:image" content="http://i.imgur.com/YR2iX5b.png">
<meta property="og:image" content="http://i.imgur.com/wwFyQk9.png">
<meta property="og:image" content="http://i.imgur.com/FWdhXzZ.png">
<meta property="og:updated_time" content="2016-12-22T10:46:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android动态加载机制">
<meta name="twitter:description" content="1.引言在Android开发中，存在一些场景：

在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？ 引用官方原文http://developer.android.com/intl/zh-cn/tools/building/multidex.html">
<meta name="twitter:image" content="http://i.imgur.com/YR2iX5b.png">
    
        <link rel="alternate" type="application/atom+xml" title="Atypical programmer" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.16">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/logo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Cstsinghua</h5>
          <a href="mailto:cstsinghua@126.com" title="cstsinghua@126.com" class="mail">cstsinghua@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Android"  >
                <i class="icon icon-lg icon-android"></i>
                Android
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Java"  >
                <i class="icon icon-lg icon-coffee"></i>
                Java
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Python"  >
                <i class="icon icon-lg icon-product-hunt"></i>
                Python
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/NodeJS"  >
                <i class="icon icon-lg icon-shield"></i>
                NodeJS
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/版本控制/"  >
                <i class="icon icon-lg icon-git"></i>
                版本控制
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/杂项/"  >
                <i class="icon icon-lg icon-book"></i>
                杂项
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/sitemap.xml"  >
                <i class="icon icon-lg icon-sitemap"></i>
                Sitemap
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/cstsinghua" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://developer.android.com"  >
                <i class="icon icon-lg icon-link"></i>
                Android官网
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android动态加载机制</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="搜尋">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android动态加载机制</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-06-13T07:36:18.000Z" itemprop="datePublished" class="page-time">
  2016-06-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-引言"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.引言</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-JVM的类加载机制"><span class="post-toc-number">2.</span> <span class="post-toc-text">2.JVM的类加载机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-双亲委派模型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">2.1 双亲委派模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-类加载过程"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.2 类加载过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-Android中的类加载机制"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.Android中的类加载机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-Android中的主要类加载器介绍"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">3.1 Android中的主要类加载器介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-DexClassLoader加载类示例"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">3.2 DexClassLoader加载类示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-1-DexClassLoader加载示例1"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">3.2.1 DexClassLoader加载示例1</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-2-DexClassLoader加载示例2"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">3.2.2 DexClassLoader加载示例2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-DexClassLoader加载的缺点，类加载的进一步探索"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">3.3 DexClassLoader加载的缺点，类加载的进一步探索</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1"><span class="post-toc-number">3.2.3.1.</span> <span class="post-toc-text">3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2"><span class="post-toc-number">3.2.3.2.</span> <span class="post-toc-text">3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3"><span class="post-toc-number">3.2.3.3.</span> <span class="post-toc-text">3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-Android动态加载引申"><span class="post-toc-number">4.</span> <span class="post-toc-text">4.Android动态加载引申</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Android动态加载机制"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android动态加载机制</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-06-13 15:36:18" datetime="2016-06-13T07:36:18.000Z"  itemprop="datePublished">2016-06-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>在Android开发中，存在一些场景：</p>
<ol>
<li><p>在低版本的Android平台(Dalvik虚拟机执行说明限制， Dalvik Executable specification)，每个dex的方法数不能超过65535，那么超过了怎么办？突破平台限制？<br> 引用官方原文<a href="http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about" title="每个Dex的方法数不能超过65535" target="_blank" rel="external">http://developer.android.com/intl/zh-cn/tools/building/multidex.html#about</a>：</p>
<pre><code>`Both these error conditions display a common number: 65,536. This number is significant in that it represents the total number of references that can be invoked by the code within a single Dalvik Executable (dex) bytecode file. If you have built an Android app and received this error, then congratulations, you have a lot of code! This document explains how to move past this limitation and continue building your app.`
</code></pre></li>
<li><p>众所周知，Android进行反编译APK获取其中的资源和代码相对比较容易，那么在某些特定场景和功能，开发者不希望其核心代码被他人轻易反编译破解，此时应该怎么办？安全方面的考虑，比如in-app purchase？</p>
</li>
<li>随着Android的发展，应用的功能越来越多，越来越复杂，其APK大小也跟随着膨胀，而APK的大小影响着用户的接受程度，许多应用市场也会限制上传包的大小，如何做到既减小APK的大小，同时又可以扩展更多功能？扩展考虑？</li>
<li>其他？热插拔？类似插件的机制？…</li>
</ol>
<p>以上的问题自然就引出一个概念，能不能动态地加载Android代码或者资源，甚至动态加载APK执行？</p>
<p>答案是肯定的！熟悉Java的朋友应该了解JVM可以动态加载类，核心思想是通过ClassLoader加载本地的或者从网络传输获得的类代码，从而可以在运行时动态加载类。Android平台的应用开发主要采用Java语言，而dalvik虚拟机的类加载机制类似于JVM。</p>
<p>本文先介绍JVM的类加载原理，讲述Java最基本的类加载机制，为Android类加载做铺垫。然后，重点介绍Android的类加载机制，及常见的实现方式。最后，在前面的基础上，扩展开来，从Android的类加载引申到更广泛的层面上，即动态加载机制(插件机制)、安全方面。从这里可以看到，整个发展历程成阶梯上升，前面的是基础也是基石，而越到后面才是实际开发中更常见的场景，也是更加复杂和综合的应用。概括之，<strong>Android的动态加载机制发展历程：普通的类(Class文件)加载-&gt;普通jar包(包含dex)加载-&gt;包含资源的jar加载-&gt;直接加载其他应用程序APK</strong>。</p>
<h1 id="2-JVM的类加载机制"><a href="#2-JVM的类加载机制" class="headerlink" title="2.JVM的类加载机制"></a>2.JVM的类加载机制</h1><p>Java的类(class)文件是通过类加载器来加载的，每一个类加载器，都拥有一个独立的类名称空间，因此，只有比较两类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>注意：上面提及的“相等”概念，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象关系判断等情况。</strong></p>
<h2 id="2-1-双亲委派模型"><a href="#2-1-双亲委派模型" class="headerlink" title="2.1 双亲委派模型"></a>2.1 双亲委派模型</h2><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器均由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。</p>
<p>从Java程序员的角度来看，类加载器划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader):这个类加载器负责将存放在<java_home>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可。</java_home></li>
<li>扩展类加载器(Extension ClassLoader)：该加载器由sun.misc.Launcher$ExtClassLoader实现，其负责加载<java_home>/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li>
<li>应用程序类加载器(Application ClassLoader)：该类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般也称它为系统类加载器。其负责加载用户类路径(ClassPath)上所指定的库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自定义的类加载器。这些类加载器之间的关系一般如下图所示：<br><img src="http://i.imgur.com/YR2iX5b.png" alt="ClassLoader之间关系"></p>
<p>上图中的这种层次关系，被称为类加载器的双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合的关系来复用父类加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并被广发应用于之后的几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p><strong>双亲委派模型的工作过程：</strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p>
<p>类加载由类加载器的loadClass方法执行，而<strong>实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass方法之中</strong>，如下面代码(基于JDK 1.7版本的源码)所示，其逻辑为：<strong>先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法执行自定义的加载过程</strong>。</p>
<pre><code>/**
 * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The
 * default implementation of this method searches for classes in the
 * following order:
 *
 * &lt;p&gt;&lt;ol&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
 *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method
 *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class
 *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
 *   class.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt; If the class was found using the above steps, and the
 * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link
 * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.
 *
 * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override {@link
 * #findClass(String)}, rather than this method.  &lt;/p&gt;
 *
 * &lt;p&gt; Unless overridden, this method synchronizes on the result of
 * {@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;} method
 * during the entire class loading process.
 *
 * @param  name
 *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
 *
 * @param  resolve
 *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class
 *
 * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
 *
 * @throws  ClassNotFoundException
 *          If the class could not be found
 */
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre><h2 id="2-2-类加载过程"><a href="#2-2-类加载过程" class="headerlink" title="2.2 类加载过程"></a>2.2 类加载过程</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)，这7个阶段顺序如下图所示：</p>
<p><img src="http://i.imgur.com/wwFyQk9.png" alt="ClassLoading process"></p>
<p>上图中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地执行，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也被称为动态绑定或晚期绑定)。</p>
<h1 id="3-Android中的类加载机制"><a href="#3-Android中的类加载机制" class="headerlink" title="3.Android中的类加载机制"></a>3.Android中的类加载机制</h1><p>Android的类加载机制与JVM的类加载机制类似。也采用了双亲委派模型。Android系统定义的ClassLoader相关类的架构如下图所示：</p>
<p><img src="http://i.imgur.com/FWdhXzZ.png" alt="Android的ClassLoader架构"></p>
<p>如上图所示，ClassLoader是整个类加载器的顶层类，其为抽象类，实现了类加载器所要求的通用架构。Android中提供了几个该类的具体实现类，比如dalvik.system.PathClassLoader，应用程序可以实现ClassLoader来提供加载类的特殊方式。</p>
<h2 id="3-1-Android中的主要类加载器介绍"><a href="#3-1-Android中的主要类加载器介绍" class="headerlink" title="3.1 Android中的主要类加载器介绍"></a>3.1 Android中的主要类加载器介绍</h2><p>从上图可知，java.lang.ClassLoader是类加载器的顶层类，dalvik.system.BaseDexClassLoader是为各种基于dex的类加载器的实现提供一个基本功能的基类。其子类dalvik.system.PathClassLoader和dalvik.system.DexClassLoader是我们关注的重点，负责具体的类加载。</p>
<ol>
<li><p><strong>dalvik.system.PathClassLoader</strong></p>
<p> Android源码的解释是：</p>
<pre><code>Provides a simple ClassLoader implementation that operates on a list of files and directories in the local file system, but does not attempt to load classes from the network. Android uses this class for its system class loader and for its application class loader(s).
</code></pre><p> 大意是，PathClassLoader可以加载包含在本地文件系统中的文件和目录列表中代码和资源，但是无法从网络加载类。Android本身采用该类加载器作为其系统的和应用程序的默认类加载器，换句话说，Android系统的框架层的类和应用程序默认情况下的类加载均有该类来完成。那么要实现自定义的类加载器，采用该类就不太可行了，那只能另辟蹊径。</p>
</li>
<li><p><strong>dalvik.system.DexClassLoader</strong><br> Android源码的解释是：</p>
<pre><code>A class loader that loads classes from .jar and .apk files containing a classes.dex entry. This can be used to execute code not installed as part of an application.

This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getCodeCacheDir() to create such a directory:

   File dexOutputDir = context.getCodeCacheDir();

Do not cache optimized classes on external storage. External storage does not provide access controls necessary to protect your application from code injection attacks.
</code></pre><p> 从上面说明不难看出，DexClassLoader可以从包含dex的jar或者apk文件中加载类和资源，用于加载应用程序非安装时附带的代码。这恰恰就是我们所需要的，因为我们希望在应用运行期间，动态地从文件系统或者从网络下载包含dex的文件，然后加载进内存执行。</p>
<p> <strong>请注意：DexClassLoader需要提供一个目录用于缓存优化的class文件，因此为了安全，请将该目录设置为应用程序私有的目录，不要采用外部存储目录。</strong></p>
<p> DexClassLoader有一个构造方法：</p>
<pre><code>public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)
</code></pre><p> 其中，dexPath为包含dex的jar或者apk的存放路径，optimizedDirectory代表存放优化的dex的目录，libraryPath代表本地代码存放的路径，parent指定父加载器，一般采用Context调用getClassLoader()获取并传入，如果传入null，则采用启动类加载器作为父加载器。</p>
<p> DexClassLoader负责加载类的方法仍是继承自ClassLoader的loadClass方法：</p>
<pre><code>Class&lt;?&gt; java.lang.ClassLoader.loadClass(String className) throws ClassNotFoundException
</code></pre></li>
</ol>
<h2 id="3-2-DexClassLoader加载类示例"><a href="#3-2-DexClassLoader加载类示例" class="headerlink" title="3.2 DexClassLoader加载类示例"></a>3.2 DexClassLoader加载类示例</h2><p>既然我们可以直接使用DexClassLoader来动态加载应用程序外部的dex，那么这个过程具体是怎样的呢，且看下文分解。</p>
<h3 id="3-2-1-DexClassLoader加载示例1"><a href="#3-2-1-DexClassLoader加载示例1" class="headerlink" title="3.2.1 DexClassLoader加载示例1"></a>3.2.1 DexClassLoader加载示例1</h3><p>本示例来自Google官方blog，具体地址为<a href="http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html" title="Custom Class Loading in Dalvik" target="_blank" rel="external">http://android-developers.blogspot.sg/2011/07/custom-class-loading-in-dalvik.html</a>，源码也可以从该网址中的链接下载<a href="http://code.google.com/p/android-custom-class-loading-sample" title="sample下载" target="_blank" rel="external">http://code.google.com/p/android-custom-class-loading-sample</a>，本文另外提供一个地址下载(本文作者修改后在本地运行的版本，主要涉及修改里面的local.properties，配置本地的Android SDK tools的安装目录)，下载请点击：<a href="http://172.20.154.39:8080/android-custom-class-loading-sample.zip" title="Sample本地下载地址" target="_blank" rel="external">本地Sample下载</a></p>
<p>这里摘录其中的步骤，并做一个简单描述。</p>
<ol>
<li><p>代码结构：</p>
<p> 该应用程序包含三个类：</p>
<ul>
<li>com.example.dex.MainActivity: 调用库代码的UI组件</li>
<li>com.example.dex.LibraryInterface: 库代码API的接口定义</li>
<li><p>com.example.dex.lib.LibraryProvider: lib库的实现</p>
<p>lib库打包进第二个dex, 而剩下的类被装入主dex(也就是默认的dex)。下面的构建章节详细地阐述了怎么实现这个目的。当然，实际情况下的的打包的策略依赖于开发者实际要处理的特定场景。</p>
</li>
</ul>
</li>
<li><p>类加载和方法调用：</p>
<p> 包含lib库的第二个dex文件，存储在应用程序的assets目录。首先，第二个dex文件必须复制到类加载可以直接加载的文件路径(Android内核是Linux，则path的形式与普通的linux文件路径类似)，本示例代码采用应用APP的私有内部储存区域来存放该dex(从技术层面来说，外部存储也可以满足需求，但是考虑到安全性，建议保存在内部存储)。<br> 如下是MainActivity的代码片段。</p>
<pre><code>// Before the secondary dex file can be processed by the DexClassLoader,
// it has to be first copied from asset resource to a storage location.
File dexInternalStoragePath = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE),
        SECONDARY_DEX_NAME);
...
BufferedInputStream bis = null;
OutputStream dexWriter = null;

static final int BUF_SIZE = 8 * 1024;
try {
    bis = new BufferedInputStream(getAssets().open(SECONDARY_DEX_NAME));
    dexWriter = new BufferedOutputStream(
        new FileOutputStream(dexInternalStoragePath));
    byte[] buf = new byte[BUF_SIZE];
    int len;
    while((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) {
        dexWriter.write(buf, 0, len);
    }
    dexWriter.close();
    bis.close();

} catch (. . .) {...}
</code></pre><p> 下一步，初始化创建一个DexClassLoader去加载从第二个dex中提取出来的库。有几种方式可以调用加载类的方法。在本示例中，类实例被强制转换成其实现的接口，这样就通过调用接口中定义的方法直接调用。这样的方式更方便，当然，通过反射获取Method，然后Method调用invoke方法也是可行，但反射更加复杂且比较慢。但利用反射也有其优点，即不需要第二个dex文件中的lib库实现特定的接口。</p>
<pre><code>// Internal storage where the DexClassLoader writes the optimized dex file to
final File optimizedDexOutputPath = getDir(&quot;outdex&quot;, Context.MODE_PRIVATE);

DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),
                                       optimizedDexOutputPath.getAbsolutePath(),
                                       null,
                                       getClassLoader());
Class libProviderClazz = null;
try {
    // Load the library.
    libProviderClazz =
        cl.loadClass(&quot;com.example.dex.lib.LibraryProvider&quot;);
    // Cast the return object to the library interface so that the
    // caller can directly invoke methods in the interface.
    // Alternatively, the caller can invoke methods through reflection,
    // which is more verbose. 
    LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();
    lib.showAwesomeToast(this, &quot;hello&quot;);
} catch (Exception e) { ... }
</code></pre></li>
<li><p>构建过程(build process)</p>
<p> 为了生成两个独立的dex文件，我们需要调整标准的构建过程。为了实现该技巧，可以简单地修改工程的Ant构建配置文件build.xml中到的”dex” target标签。</p>
<p> 修改后的”dex” target标签执行下列操作：</p>
</li>
</ol>
<pre><code>a. 创建两个存储目录，用于存储默认dex和第二个dex；

b. 选择性地从PROJECT_ROOT/bin/classes复制class文件至上面的两个目录；

    &lt;!-- Primary dex to include everything but the concrete library
             implementation. --&gt;
        &lt;copy todir=&quot;${out.classes.absolute.dir}.1&quot; &gt;
            &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;
                    &lt;exclude name=&quot;com/example/dex/lib/**&quot; /&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;
        &lt;!-- Secondary dex to include the concrete library implementation. --&gt;
        &lt;copy todir=&quot;${out.classes.absolute.dir}.2&quot; &gt;
            &lt;fileset dir=&quot;${out.classes.absolute.dir}&quot; &gt;
                    &lt;include name=&quot;com/example/dex/lib/**&quot; /&gt;
            &lt;/fileset&gt;
        &lt;/copy&gt;   

 c.将上述两个目录中的.class文件转换成两个独立的dex文件；

 d.将第二个dex文件添加到一个jar文件中，jar文件是DexClassLoader期望的输入格式(其实只要里面包含dex即可)。最后，存储该jar文件至工程的assets目录。

     &lt;!-- Package the output in the assets directory of the apk. --&gt;
        &lt;jar destfile=&quot;${asset.absolute.dir}/secondary_dex.jar&quot;
               basedir=&quot;${out.absolute.dir}/secondary_dex_dir&quot;
               includes=&quot;classes.dex&quot; /&gt;

为了达成上面的构建目的，需要在工程目录下执行&quot;ant debug&quot;或者&quot;ant release&quot;命令(前提是需要下载apache的[Ant构建工具](https://www.apache.org/dist/ant/ &quot;Ant&quot;)，且不能使用Eclipse的自动构建方式)。
</code></pre><h3 id="3-2-2-DexClassLoader加载示例2"><a href="#3-2-2-DexClassLoader加载示例2" class="headerlink" title="3.2.2 DexClassLoader加载示例2"></a>3.2.2 DexClassLoader加载示例2</h3><p>示例1主要是定制了ant的构建过程，这样在生成apk的时候已经对class文件加以分割，生成了独立的多个dex文件，并且自动地放入了apk的assets目录。运行时，非默认dex采用DexClassLoader加载。如果觉得修改Eclipse自动构建过程麻烦(主要是需要配置build.xml)，更直观的方式是，新建一个空工程，将lib库的包copy进去，编译该工程，会在工程的bin目录下生成代码相关的jar文件，再利用dex2jar工具将jar转换成第二个dex即可，将第二个dex放入工程的assets目录，其他步骤与示例1完全一致。或者，直接新建的工程，从生成的apk从提取dex(即第二个dex)，然后放入工程的assets目录，其他方面别无二样。</p>
<h3 id="3-3-DexClassLoader加载的缺点，类加载的进一步探索"><a href="#3-3-DexClassLoader加载的缺点，类加载的进一步探索" class="headerlink" title="3.3 DexClassLoader加载的缺点，类加载的进一步探索"></a>3.3 DexClassLoader加载的缺点，类加载的进一步探索</h3><p>从上面的示例和DexClassLoader的API不难发现，DexClassLoader加载类的时候必须知道dex path，而且需要指定存放优化的dex目录，这就是说，DexClassLoader工作前提是必须将<font color="red"><strong>dex存放在文件系统</strong></font>中，虽然可以存放在应用程序私有的目录中，但是一旦黑客绕过这道Android系统的文件权限管理的篱笆，那么就能获取到dex文件，然后反编译并获取其中的内容。所以，DexClassLoader这样的加载机制存在安全问题。那么，怎么样回避这个问题呢？</p>
<p>一个直观的方法，就是能不能直接对dex文件进行加密，这样即使保存在文件系统，其他人要想破解则必须先解密dex。但是，一旦加密dex，那么在加载的时候也必须先进行解密，解密的过程如果用java来完成，那仍然是不安全的。另外，优化的dex仍然需保存在文件系统中，这还是不可行。</p>
<p>从上面讲述的类加载的双亲委派模型可知，一个类加载器，先委派父类加载器去加载，如果无法加载，则调用自身的findClass方法去按照自定义方式加载类。关键就在于此，其实DexClassLoader替我们处理好了底层的封装细节，我们只是调用了DexClassLoader的loadClass方法而已。那么，要想突破DexClassLoader的缺陷，也就不得不深入研究下DexClassLoader本身的loadClass和findClass方法，从中寻找蛛丝马迹，抑或一种启发，进而编写属于我们自己的DexClassLoader。</p>
<p>其实，Android4.0版本增加了对内存中DEX数据的动态加载(稍后看源码可以确认这一点)，这样就克服了使用DexClassLoader时DEX以文件形式明文存放在存储设备上的缺点，内存中DEX数据可以来源于解密后的文件或者网络。这样就增加了DEX数据的安全性。但是DexClassLoader并没有暴露该种加载方式。开发者需要在JAVA层实现自己的Dex ClassLoader。本文提供两个Android源码下载的链接地址：</p>
<p>Android官方下载地址：<a href="https://android.googlesource.com" title="Android官方源码" target="_blank" rel="external">https://android.googlesource.com</a></p>
<p>Web在线浏览及下载地址：<a href="http://androidxref.com" title="Android源码web在线浏览和下载" target="_blank" rel="external">http://androidxref.com</a></p>
<ul>
<li><p>DexClassLoader的源码(下面基于ICS4.0.3的源码)：</p>
<pre><code>/**
 * A class loader that loads classes from {@code .jar} and {@code .apk} files
 * containing a {@code classes.dex} entry. This can be used to execute code not
 * installed as part of an application.
 *
 * &lt;p&gt;This class loader requires an application-private, writable directory to
 * cache optimized classes. Use {@code Context.getDir(String, int)} to create
 * such a directory: &lt;pre&gt;   {@code
 *   File dexOutputDir = context.getDir(&quot;dex&quot;, 0);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;
 * External storage does not provide access controls necessary to protect your
 * application from code injection attacks.
 */
public class DexClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code DexClassLoader} that finds interpreted and native
     * code.  Interpreted classes are found in a set of DEX files contained
     * in Jar or APK files.
     *
     * &lt;p&gt;The path lists are separated using the character specified by the
     * {@code path.separator} system property, which defaults to {@code :}.
     *
     * @param dexPath the list of jar/apk files containing classes and
     *     resources, delimited by {@code File.pathSeparator}, which
     *     defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     *     should be written; must not be {@code null}
     * @param libraryPath the list of directories containing native
     *     libraries, delimited by {@code File.pathSeparator}; may be
     *     {@code null}
     * @param parent the parent class loader
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}
</code></pre><p>可以看出，DexClassLoader本身没有任何逻辑，只是继承了BaseDexClassLoader，并提供了一个构造器而已。</p>
</li>
<li><p>BaseDexClassLoader源码：</p>
<pre><code>/**
 * Base class for common functionality between various dex-based
 * {@link ClassLoader} implementations.
 */
public class BaseDexClassLoader extends ClassLoader {
    /** originally specified path (just used for {@code toString()}) */
    private final String originalPath;

    /** structured lists of path elements */
    private final DexPathList pathList;

    /**
     * Constructs an instance.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     * should be written; may be {@code null}
     * @param libraryPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
    public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(parent);

        this.originalPath = dexPath;
        this.pathList =
            new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        Class clazz = pathList.findClass(name);

        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }

        return clazz;
    }

    @Override
    protected URL findResource(String name) {
        return pathList.findResource(name);
    }

    @Override
    protected Enumeration&lt;URL&gt; findResources(String name) {
        return pathList.findResources(name);
    }

    @Override
    public String findLibrary(String name) {
        return pathList.findLibrary(name);
    }

    /**
     * Returns package information for the given package.
     * Unfortunately, instances of this class don&apos;t really have this
     * information, and as a non-secure {@code ClassLoader}, it isn&apos;t
     * even required to, according to the spec. Yet, we want to
     * provide it, in order to make all those hopeful callers of
     * {@code myClass.getPackage().getName()} happy. Thus we construct
     * a {@code Package} object the first time it is being requested
     * and fill most of the fields with dummy values. The {@code
     * Package} object is then put into the {@code ClassLoader}&apos;s
     * package cache, so we see the same one next time. We don&apos;t
     * create {@code Package} objects for {@code null} arguments or
     * for the default package.
     *
     * &lt;p&gt;There is a limited chance that we end up with multiple
     * {@code Package} objects representing the same package: It can
     * happen when when a package is scattered across different JAR
     * files which were loaded by different {@code ClassLoader}
     * instances. This is rather unlikely, and given that this whole
     * thing is more or less a workaround, probably not worth the
     * effort to address.
     *
     * @param name the name of the class
     * @return the package information for the class, or {@code null}
     * if there is no package information available for it
     */
    @Override
    protected synchronized Package getPackage(String name) {
        if (name != null &amp;&amp; !name.isEmpty()) {
            Package pack = super.getPackage(name);

            if (pack == null) {
                pack = definePackage(name, &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;,
                        &quot;Unknown&quot;, &quot;0.0&quot;, &quot;Unknown&quot;, null);
            }

            return pack;
        }

        return null;
    }

    @Override
    public String toString() {
        return getClass().getName() + &quot;[&quot; + originalPath + &quot;]&quot;;
    }
}
</code></pre></li>
</ul>
<p>分析得之，BaseDexClassLoader覆写了ClassLoader的findClass方法(loadClass方法根据前面所述的双亲委派模型介绍可知是实现双亲委派模型的基础，官方是建议不要修改该方法，而覆写findClass方法)。findClass方法中其实是调用pathList.findClass(name)，而pathList是DexPathList类的实例，那么接着跟踪进入DexPathList的源码。</p>
<ul>
<li><p>DexPathList的源码(findClass方法)：</p>
<pre><code>/**
 * Finds the named class in one of the dex files pointed at by
 * this instance. This will find the one in the earliest listed
 * path element. If the class is found but has not yet been
 * defined, then this method will define it in the defining
 * context that this instance was constructed with.
 *
 * @return the named class or {@code null} if the class is not
 * found in any of the dex files
 */
public Class findClass(String name) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext);
            if (clazz != null) {
                return clazz;
            }
        }
    }

    return null;
}
</code></pre></li>
</ul>
<p>在这里，发现其实又调用DexFile dex.loadClassBinaryName(name, definingContext),根据进入DexFile的源码。</p>
<ul>
<li><p>DexFile的源码(loadClassBinaryName方法)：</p>
<pre><code>/**
 * Opens a DEX file from a given filename. This will usually be a ZIP/JAR
 * file with a &quot;classes.dex&quot; inside.
 *
 * The VM will generate the name of the corresponding file in
 * /data/dalvik-cache and open it, possibly creating or updating
 * it first if system permissions allow.  Don&apos;t pass in the name of
 * a file in /data/dalvik-cache, as the named file is expected to be
 * in its original (pre-dexopt) state.
 *
 * @param fileName
 *            the filename of the DEX file
 *
 * @throws IOException
 *             if an I/O error occurs, such as the file not being found or
 *             access rights missing for opening it
 */
public DexFile(String fileName) throws IOException {
    mCookie = openDexFile(fileName, null, 0);
    mFileName = fileName;
    guard.open(&quot;close&quot;);
    //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);
}
...
/**
 * See {@link #loadClass(String, ClassLoader)}.
 *
 * This takes a &quot;binary&quot; class name to better match ClassLoader semantics.
 *
 * @hide
 */
public Class loadClassBinaryName(String name, ClassLoader loader) {
    return defineClass(name, loader, mCookie);
}

private native static Class defineClass(String name, ClassLoader loader, int cookie);
</code></pre></li>
</ul>
<p>最终，通过JNI调用了本地方法defineClass(String name, ClassLoader loader, int cookie)。在实例化DexFile类的时候，在构造方法里面， 关键处为mCookie = openDexFile(fileName, null, 0)，这里即将dex文件打开并加装，而在DexFile里面还有几个方法：</p>
<pre><code>/*
 * Open a DEX file.  The value returned is a magic VM cookie.  On
 * failure, an IOException is thrown.
 */
native private static int openDexFile(String sourceName, String outputName,
    int flags) throws IOException;

/*
 * Open a DEX file based on a {@code byte[]}. The value returned
 * is a magic VM cookie. On failure, a RuntimeException is thrown.
 */
native private static int openDexFile(byte[] fileContents);

/*
 * Close DEX file.
 */
native private static void closeDexFile(int cookie);
</code></pre><p>上面这些本地方法实现是在/dalvik/vm/native/dalvik_system_DexFile.cpp里面。<br>native private static int openDexFile(byte[] fileContents)方法正是Android 4.0之后引入的，即前面所述的增加了对内存中DEX数据的动态加载。byte[] fileContents可以来自于网络或者解密dex文件。利用这一点，开发者可以解决DexClassLoader的缺点。</p>
<h4 id="3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1"><a href="#3-3-1-DexClassLoader进阶，自定义DexClassLoader方式1" class="headerlink" title="3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1"></a>3.3.1 DexClassLoader进阶，自定义DexClassLoader方式1</h4><p>通过上面内容，我们知道DexClassLoader自身加载类的逻辑实质上是通过DexFile类的loadClassBinaryName方法(该方法被隐藏)完成，而该方法最终调用dalvik_system_DexFile.cpp里面的本地方法defineClass来完成，同时DexFile的实例化调用了dalvik_system_DexFile.cpp里面的openDexFile方法来完成文件加载。</p>
<p>DexFile加载类的关键：defineClass和openDexFile方法，因为安全方面考虑，自然我们这里选择的openDexFile方法是openDexFile(byte[] fileContents)。</p>
<p>实现自定义的DexClassLoader，那么原理上我们可以通过反射调用DexFile的defineClass和openDexFile方法。首先，从本地获取或者从网络获取到dex文件的字节流byte[] fileContents，然后反射调用openDexFile(byte[] fileContents)获得magic VM cookie值，最后反射调用defineClass(String name, ClassLoader loader, int cookie)返回加载的Class。</p>
<h4 id="3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2"><a href="#3-3-2-DexClassLoader进阶，自定义DexClassLoader方式2" class="headerlink" title="3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2"></a>3.3.2 DexClassLoader进阶，自定义DexClassLoader方式2</h4><p>该方法参考<a href="http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf" title="JNI实现加载Dex" target="_blank" rel="external">http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf</a></p>
<p>自定义DexClassLoader方式1存在一个问题，即dex的字节流存在Java层，因此相对来说还是不够安全。这种需求下，就需要开发者直接通过JNI调用底层函数解析。在dalvik_system_DexFile.cpp中，定义了DalvikNativeMethod：</p>
<pre><code>const DalvikNativeMethod dvm_dalvik_system_DexFile[] = {
{ &quot;openDexFile&quot;,        &quot;(Ljava/lang/String;Ljava/lang/String;I)I&quot;,
    Dalvik_dalvik_system_DexFile_openDexFile },
{ &quot;openDexFile&quot;,        &quot;([B)I&quot;,
    Dalvik_dalvik_system_DexFile_openDexFile_bytearray },
{ &quot;closeDexFile&quot;,       &quot;(I)V&quot;,
    Dalvik_dalvik_system_DexFile_closeDexFile },
{ &quot;defineClass&quot;,        &quot;(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;&quot;,
    Dalvik_dalvik_system_DexFile_defineClass },
{ &quot;getClassNameList&quot;,   &quot;(I)[Ljava/lang/String;&quot;,
    Dalvik_dalvik_system_DexFile_getClassNameList },
{ &quot;isDexOptNeeded&quot;,     &quot;(Ljava/lang/String;)Z&quot;,
    Dalvik_dalvik_system_DexFile_isDexOptNeeded },
{ NULL, NULL, NULL },
</code></pre><p>};</p>
<ol>
<li><p>OnLoad method + dlsym获取Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法指针</p>
<pre><code>JNINativeMethod *dvm_dalvik_system_DexFile;
JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    void *ldvm = (void*)dlopen(&quot;libdvm.so&quot;, RTLD_LAZY);
    dvm_dalvik_system_DexFile = (JNINativeMethod*)dlsym(ldvm, &quot;dvm_dalvik_system_DexFile&quot;);
    void (*openDexFile)(const u4* args, JValue* pResult);
    lookup(openDexFile, &quot;dvm_dalvik_system_DexFile&quot;, &quot;([B)I&quot;, &amp;openDexFile);
}

int lookup (JNINativeMethod *table, const char *name, const char *sig, void (**fnPtrout)
    (u4 const *, union JValue *)) {
     int i = 0;
     while (table[i].name != NULL) {
     if ( (strcmp(name, table[i].name) == 0) &amp;&amp; (strcmp(sig, table[i].signature) == 0) ) {
     *fnPtrout = table[i].fnPtr;
     return 1;
     }
     i++;
     }
     return 0;
}
</code></pre></li>
<li><p>调用Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析Dex数据</p>
<pre><code>ArrayObject *ao; // header+dex content
u4 args[] = { (u4)ao };
JValue pResult ;
jint result ;
openDexFile(args, &amp;pResult);
result = (jint)pResult.l;
return result;
</code></pre></li>
<li><p>第三步实现JAVA层Dex ClassLoader完成类的加载：</p>
<pre><code>int cookie = openDexFile(...);
Class&lt;?&gt; cls = null;
String as[] = getClassNameList(cookie);
for(int z=0; z&lt;as.length; z++) {
 if(as[z].equals(&quot;com.immunapp.hes2013.MainActivity&quot;)) {
      cls=defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie );
} else {
     defineClass(as[z].replace(&apos;.&apos;, &apos;/&apos;), context.getClassLoader(), cookie );
}
</code></pre></li>
</ol>
<h4 id="3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3"><a href="#3-3-3-DexClassLoader进阶，自定义DexClassLoader方式3" class="headerlink" title="3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3"></a>3.3.3 DexClassLoader进阶，自定义DexClassLoader方式3</h4><p>该方式源自<a href="http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf" title="自修改Dalvik字节码加载dex" target="_blank" rel="external">http://2013.hackitoergosum.org/presentations/Day1-05.Nifty%20stuff%20that%20you%20can%20still%20do%20with%20Android%20by%20Xavier%20Martin.pdf</a></p>
<p>自定义DexClassLoader方式2也存在确定，即只支持Android4.0以上系统，因为Android4.0系统才在底层引入了Dalvik_dalvik_system_DexFile_openDexFile_bytearray方法解析。要想克服这个问题，就需要自修改Dalvik字节码(即按照上面dalvik_system_DexFile.cpp的逻辑，我们自定义实现其逻辑)。大致流程如下(由于本文作者对C++不熟悉，因此只能是浅尝辄止，有兴趣的开发者可以自行实践)。</p>
<ul>
<li><p>搜索内存查找DEX特征（dex\n035）</p>
<p>  读取/proc/self/maps文件获取dex map地址,它将以_SC_PAGESIZE内存页对齐, 相对Map开始地址偏移0x28</p>
</li>
<li><p>DEX格式解析(请参考<a href="https://source.android.com/tech/dalvik/dex-format.html" title="Dex格式解析" target="_blank" rel="external">https://source.android.com/tech/dalvik/dex-format.html</a>)</p>
</li>
<li><p>找到代码正确的位置</p>
<p>  第一步定位到具体类，第二步定位到具体方法，获取方法字节码相对data section偏移量。</p>
</li>
<li><p>解锁内存</p>
<p>  mprotect((unsigned char*)aligned,PROT_WRITE | PROT_READ, len);</p>
</li>
<li><p>修改相应的代码</p>
<p>  memcpy((unsigned char*)code_off,opcodes, len);</p>
</li>
</ul>
<p>这里提供一个示例，下载地址：<a href="http://172.20.154.39:8080/DemoActivity.zip" target="_blank" rel="external">自修改Dalvik字节码实现Dex加载Sample</a></p>
<h1 id="4-Android动态加载引申"><a href="#4-Android动态加载引申" class="headerlink" title="4.Android动态加载引申"></a>4.Android动态加载引申</h1><p>前面提到，Android动态加载机制的发展历程，随着需求的扩展，人们不仅仅满足于加载jar，还希望加载包含资源的jar甚至直接加载第三方APK，这样就带来更强的扩展性。我们知道，正常情况下，Android应用的APK需要安装注册，然后才能运行，怎样才能通过宿主程序打开别的APK呢，就如同通过安装运行一样。</p>
<p>很明显，前提仍然是类和资源的动态加载，即前面章节描述的内容。但是仅仅做到这些不够，还有很多问题需要解决：</p>
<ul>
<li>需加载的apk中的资源怎样引用？</li>
<li>需加载的apk的界面就算被加载，怎么与用户交互?</li>
<li>怎样管理加载的APK中的组件的生命周期？</li>
<li>…等等…</li>
</ul>
<p>需求产生动力，有了动力就有才能的发挥。聪明的人们自然会想到各种办法解决这些问题。当前，BAT等公司都有自己成熟的动态加载机制，但是不是开源的。而开源的加载机制方面，比较有影响的有：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" title="dynamic-load-apk地址" target="_blank" rel="external">dynamic-load-apk</a>和360的<a href="https://github.com/Qihoo360/DroidPlugin" title="DroidPlugin开源项目" target="_blank" rel="external">DroidPlugin</a>。</p>
<p>开发者如果对动态加载APK感兴趣，建议深入研究上述的开源项目，这里就不再赘述其中的原理了。里面很多思路值得借鉴，但同时还有很大的完善空间，发挥你的聪明才智，试试吧。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最後更新時間：<time datetime="2016-12-22T10:46:24.000Z" itemprop="dateUpdated">2016-12-22 18:46:24</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://cstsinghua.github.io">
            <img src="/img/logo.jpg" alt="Cstsinghua">
            Cstsinghua
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态加载/">动态加载</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&title=《Android动态加载机制》 — Atypical programmer&pic=http://cstsinghua.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&title=《Android动态加载机制》 — Atypical programmer&source=写给典型的程序员" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android动态加载机制》 — Atypical programmer&url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&via=http://cstsinghua.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/06/13/Android热修复的思路/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Android热修复</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/06/13/Android安装APK详解/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android安装APK详解</h4>
      </a>
    </div>
  
</nav>



    





<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=2146219"></script>
    <!-- UY END -->
</section>







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        Thanks~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>本部落格係採用<a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh_TW">創用 CC 姓名標示 4.0 國際 授權條款授權</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Cstsinghua &copy; 2016 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&title=《Android动态加载机制》 — Atypical programmer&pic=http://cstsinghua.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&title=《Android动态加载机制》 — Atypical programmer&source=写给典型的程序员" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android动态加载机制》 — Atypical programmer&url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/&via=http://cstsinghua.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://cstsinghua.github.io/2016/06/13/Android动态加载机制/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1259817891&web_id=1259817891')

</script>

<script src="/js/main.min.js?v=1.6.16"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.16" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
