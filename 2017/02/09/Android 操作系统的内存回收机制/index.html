<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?5bdd93f06ab5180cf97a5e1c1033c6ef"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    <link rel="canonical" href="http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/">
    
    
    <title>Android 操作系统的内存回收机制 | Atypical programmer | 做一个非典型程序员</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android,内存管理,内存回收,机制,OS">
    <meta name="description" content="Android系统内存管理和回收机制详解">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 操作系统的内存回收机制">
<meta property="og:url" content="http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/index.html">
<meta property="og:site_name" content="Atypical programmer">
<meta property="og:description" content="Android系统内存管理和回收机制详解">
<meta property="og:image" content="http://i.imgur.com/1sdyZGk.png">
<meta property="og:updated_time" content="2017-02-09T04:27:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 操作系统的内存回收机制">
<meta name="twitter:description" content="Android系统内存管理和回收机制详解">
<meta name="twitter:image" content="http://i.imgur.com/1sdyZGk.png">
    
        <link rel="alternate" type="application/atom+xml" title="Atypical programmer" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.6.16">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/logo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Cstsinghua</h5>
          <a href="mailto:cstsinghua@126.com" title="cstsinghua@126.com" class="mail">cstsinghua@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Android"  >
                <i class="icon icon-lg icon-android"></i>
                Android
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Java"  >
                <i class="icon icon-lg icon-coffee"></i>
                Java
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/Python"  >
                <i class="icon icon-lg icon-product-hunt"></i>
                Python
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/NodeJS"  >
                <i class="icon icon-lg icon-shield"></i>
                NodeJS
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/版本控制/"  >
                <i class="icon icon-lg icon-git"></i>
                版本控制
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/杂项/"  >
                <i class="icon icon-lg icon-book"></i>
                杂项
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/sitemap.xml"  >
                <i class="icon icon-lg icon-sitemap"></i>
                Sitemap
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/cstsinghua" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://developer.android.com"  >
                <i class="icon icon-lg icon-link"></i>
                Android官网
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android 操作系统的内存回收机制</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android 操作系统的内存回收机制</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-02-09T01:58:42.000Z" itemprop="datePublished" class="page-time">
  2017-02-09
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/内存管理/">内存管理</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Android-APP-的运行环境"><span class="post-toc-number">1.</span> <span class="post-toc-text">Android APP 的运行环境</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Android-内存回收原则"><span class="post-toc-number">2.</span> <span class="post-toc-text">Android 内存回收原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#默认回收过程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">默认回收过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#回收动作入口：activityIdleInternal"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">回收动作入口：activityIdleInternal()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#回收过程函数-trimApplications"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">回收过程函数 trimApplications()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Linux-内核中的内存回收"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Linux 内核中的内存回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lowmemorykiller"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">lowmemorykiller</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Oom-killer"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">Oom_killer</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#总结"><span class="post-toc-number">3.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">4.</span> <span class="post-toc-text">参考资料</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-Android 操作系统的内存回收机制"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android 操作系统的内存回收机制</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-02-09 09:58:42" datetime="2017-02-09T01:58:42.000Z"  itemprop="datePublished">2017-02-09</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/内存管理/">内存管理</a></li></ul></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Android 操作系统的内存回收机制</p>
<p>Android系统是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使应用程序关闭但不退出，并由操作系统进行进程的回收管理。本文在Application Framework与Linux内核两个层次上，以进程为粒度，对Android 操作系统的进程资源回收机制进行了剖析。读者可以从本文获得对Android应用程序的生存周期的进一步理解，从而更加合理、高效地构建应用程序。<br><a id="more"></a><br><strong>Note：本文转载自<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/</a> ，适当添加批注和修正一些有争议的地方</strong> </p>
<h1 id="Android-APP-的运行环境"><a href="#Android-APP-的运行环境" class="headerlink" title="Android APP 的运行环境"></a>Android APP 的运行环境</h1><p>Android 是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对其做了特别的设计与优化，使得其进程调度与资源管理与其他平台的Linux有明显的区别。主要包含下面几个层次：</p>
<ol>
<li>Application Framework<br>Application Framework 将整个操作系统分隔成两个部分。对应用开发者而言，所有APP都是运行在Application Framework之上，而并不需要关心系统底层的情况。Application Framework层为应用开发者提供了丰富的应用编程接口，如Activity Manager，Content Provider，Notification Manager，以及各种窗口Widget资源等。在Application Framework层，Activity是一个APP最基本的组成部分。一般每个 Activity对应于屏幕上的一个视图（或者说一屏），一个APP可以有一个或者多个Activity。应用程序被打包成.apk格式的文件，由Dalvik VM解释执行。</li>
<li>Dalvik VM(或ART)<br>Dalvik虚拟机采用寄存器架构，而不是JVM的栈结构。Java程序编译后的.class文件并不能在Dalvik中解释执行。因此Google提供了一个 dx 工具，用于将.class文件转换成Dalivk能够识别的.dex格式。具体Dalvik VM的细节不是本文重点，以下不再讨论。</li>
<li>Linux kernel<br>由上所述，所有的APP都是由Java代码编写并在Dalvik VM中得到解释执行。在Android操作系统中，每个Dalvik VM的每个Instance都对应于 Linux内核中的一个进程。可以使用adb shell工具查看系统中的当前进程。如下图所示，Android2.3.3启动后内核中的进程列表。<br><strong>图 1. Android 2.3 中的进程列表（部分）</strong><br><img src="http://i.imgur.com/1sdyZGk.png" alt=""><br>图 1 中，UID 标识为 app_xx 的每一项都是一个 app 所占用的进程，可见 Android 设计使得每个应用程序由一个独立的 Dalvik 实例解释执行，而每个 Linux 内核进程加载一个 Dalvik 实例，通过这种方式提供 app 的运行环境。如此，每个 APP 的资源被完全屏蔽，互不干扰。虽然同时引入了进程间通信的困难，但也带来了更强的安全性。</li>
</ol>
<h1 id="Android-内存回收原则"><a href="#Android-内存回收原则" class="headerlink" title="Android 内存回收原则"></a>Android 内存回收原则</h1><p>下面将从 Application Framework 和 Linux kernel 两个层次分析 Android 操作系统的资源管理机制。<br>Android 之所以采用特殊的资源管理机制，原因在于其设计之初就是面向移动终端，所有可用的内存仅限于系统 RAM，必须针对这种限制设计相应的优化方案。当 Android 应用程序退出时，并不清理其所占用的内存，Linux 内核进程也相应的继续存在，所谓“退出但不关闭”。从而使得用户调用程序时能够在第一时间得到响应。当系统内存不足时，系统将激活内存回收过程。为了不因内存回收影响用户体验（如杀死当前的活动进程），Android 基于进程中运行的组件及其状态规定了默认的五个回收优先级：</p>
<ul>
<li>IMPORTANCE_FOREGROUND:</li>
<li>IMPORTANCE_VISIBLE:</li>
<li>IMPORTANCE_SERVICE:</li>
<li>IMPORTANCE_BACKGROUND:</li>
<li>IMPORTANCE_EMPTY:</li>
</ul>
<p>这几种优先级的回收顺序是 Empty process、Background process、Service process、Visible process、Foreground process。关于划分原则参见 <a href="https://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="external">https://developer.android.com/guide/components/processes-and-threads.html</a> 文件中。</p>
<p><code>ActivityManagerService</code>集中管理所有进程的内存资源分配。所有进程需要申请或释放内存之前必须调用<code>ActivityManagerService</code>对象，获得其“许可”之后才能进行下一步操作，或者<code>ActivityManagerService</code>将直接“代劳”。类<code>ActivityManagerService</code>中涉及到内存回收的几个重要的成员方法如下：<code>trimApplications()，updateOomAdjLocked()，activityIdleInternal()</code>。这几个成员方法主要负责 Android 默认的内存回收机制，<strong>若Linux内核中的内存回收机制没有被禁用，则跳过默认回收（这里其实应该不准确，可以参考updateOomAdjLocked源码进行比对）</strong>。</p>
<h2 id="默认回收过程"><a href="#默认回收过程" class="headerlink" title="默认回收过程"></a>默认回收过程</h2><p>Android 操作系统中的内存回收可分为两个层次，即默认内存回收与内核级内存回收，本章重点对默认内存回收机制进行研究，Linux 内核层次的内存回收机制将在下一张介绍。 本章所有代码可参见<code>ActivityManagerService.java</code>。</p>
<h3 id="回收动作入口：activityIdleInternal"><a href="#回收动作入口：activityIdleInternal" class="headerlink" title="回收动作入口：activityIdleInternal()"></a>回收动作入口：activityIdleInternal()</h3><p>Android系统中内存回收的触发点大致可分为三种情况。第一，用户程序调用<code>StartActivity()</code>, 使当前活动的Activity被覆盖；第二，用户按 back 键，退出当前应用程序；第三，启动一个新的应用程序。这些能够触发内存回收的事件最终调用的函数接口就是<code>activityIdleInternal()</code>。当<code>ActivityManagerService</code>接收到异步消息<code>IDLE_TIMEOUT_MSG</code>或者<code>IDLE_NOW_MSG</code>时，<code>activityIdleInternal()</code>将会被调用。代码如下：<br><strong>清单 1. IDLE_NOW_MSG 的处理方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case IDLE_NOW_MSG:&#123; </span><br><span class="line"> IBinder token = (Ibinder)msg.obj; </span><br><span class="line">    activityIdle(token, null); </span><br><span class="line"> &#125; </span><br><span class="line"> break;</span><br></pre></td></tr></table></figure></p>
<p><strong>清单 2. IDLE_TIMEOUT_MSG 的处理方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">case IDLE_TIMEOUT_MSG: &#123; </span><br><span class="line">if (mDidDexOpt) &#123; </span><br><span class="line">       mDidDexOpt = false; </span><br><span class="line">       Message nmsg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG); </span><br><span class="line">       nmsg.obj = msg.obj; </span><br><span class="line">       mHandler.sendMessageDelayed(nmsg, IDLE_TIMEOUT); </span><br><span class="line">       return; </span><br><span class="line">   &#125; </span><br><span class="line">   IBinder token = (IBinder)msg.obj; </span><br><span class="line">   Slog.w(TAG, &quot;Activity idle timeout for &quot; + token); </span><br><span class="line">   activityIdleInternal(token, true, null); </span><br><span class="line">&#125; </span><br><span class="line">break;</span><br></pre></td></tr></table></figure></p>
<p><code>IDLE_NOW_MSG</code>由Activity的切换以及Activiy焦点的改变等事件引发，<code>IDLE_TIMEOUT_MSG</code>在Activity启动超时的情况下引发，一般这个超时时间设为10s，如果10s之内一个Activity依然没有成功启动，那么将发送异步消息<code>IDLE_TIMEOUT_MSG</code>进行资源回收。<code>activityIdleInternal()</code>的主要任务是改变系统中Activity的状态信息，并将其添加到不同状态列表中。其主要工作如下：</p>
<p>首先，调用<code>scheduleAppGcsLocked()</code>方法通知所有进行中的任务进行垃圾回收。<code>scheduleAppGcsLocked()</code>将进行调度JVM的garbage collect，回收一部分内存空间，这里仅仅是通知每个进程自行进程垃圾检查并调度回收时间，而非同步回收。然后，取出<code>mStoppingActivities</code> 和<code>mFinishigActivities</code>列表中的所有内容，暂存在临时变量中。这两个列表分别存储了当前状态为stop和finishi的activity 对象。对于 stop 列表，如果其中的activity的finish状态为true，判断是不是要立即停止，如果要立即停止则调用<code>destroyActivityLocked()</code>通知目标进程调用onDestroy()方法，否则，先调用<code>resumeTopActivity()</code>运行下一个Activity。如果finish状态为false，则调用 <code>stopActivityLocked()</code>通知客户进程停止该Activity，这种情况一般发生在调用<code>startActivity()</code>后。对于finish列表，直接调用 <code>destroyActivityLocked()</code>通知客户进程销毁目标 Activity。</p>
<p>这里的<code>destroyActivityLocked</code>等函数并没有真正意义上改变内存的使用，只是将其状态改变为“允许回收”，真正的回收在下面即将调用的 <code>trimApplications()</code>函数中。</p>
<h3 id="回收过程函数-trimApplications"><a href="#回收过程函数-trimApplications" class="headerlink" title="回收过程函数 trimApplications()"></a>回收过程函数 trimApplications()</h3><p>trimApplications() 函数的结构如下 :<br><strong>清单 3. trimApplications 函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final void trimApplications() &#123; </span><br><span class="line">    synchronized (this) &#123; </span><br><span class="line">        // First remove any unused application processes whose package </span><br><span class="line">        // has been removed. </span><br><span class="line">        for (i=mRemovedProcesses.size()-1; i&gt;=0; i--) &#123; </span><br><span class="line">           (1)//kill process; </span><br><span class="line">        &#125; </span><br><span class="line">          if (!updateOomAdjLocked()) &#123; </span><br><span class="line">           (2)//do something default </span><br><span class="line">        &#125; </span><br><span class="line">        // Finally, if there are too many activities now running, try to </span><br><span class="line">        // finish as many as we can to get back down to the limit. </span><br><span class="line">           (3)do something </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>清单3中的三个标序号的位置分别负责如下工作：</p>
<ol>
<li>当程序执行到<code>trimApplications()</code>之后，首先检查mRemovedProcesses列表中的进程。mRemovedProcesses列表中主要包含了crash的进程、5 秒内没有响应并被用户选在强制关闭的进程、以及应用开发这调用killBackgroundProcess想要杀死的进程。调用Process.killProcess 将所有此类进程全部杀死。</li>
<li>调用<code>updateOomAdjLocked()</code>函数，若成功返回，说明Linux内核支持<code>setOomAdj()</code>接口，updateOomAdjLocked将修改adj(adjustments)的值并通知 linux内核，内核根据adj值以及内存使用情况动态管理进程资源（lowmemorykiller和oom_killer）。若<code>updateOomAdjLocked()</code>返回为假，则表示当前系统不支持setOomAdj()接口，将在本地进行默认的资源回收。</li>
<li>最后，如果当前依然运行了过多的Activity，对多余的Activity进行回收。<code>trimApplications()</code>的大多数的代码都在处理Oom_killer不存在情况下的默认资源回收，下面对其默认回收过程（即代码清单3中标记(2)的位置）进行进一步分析。其回收过程可大致描述如下:</li>
</ol>
<p>步骤一，获取当前所有运行的进程mLruProcesses，mLruProcesses中的排序规则是按最近使用时间。对mLruProcesses中不能被关闭的进程进行计数，这些不能被关闭的进程包括运行service的进程，运行broadcast receiver的进程等，见如下代码。<br><strong>清单 4. 计数不能被关闭的进程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (app.persistent || app.services.size() != 0 </span><br><span class="line">            || app.curReceiver != null </span><br><span class="line">            || app.persistentActivities &gt; 0) &#123; </span><br><span class="line"> // Don&apos;t count processes holding services against our </span><br><span class="line">    // maximum process count. </span><br><span class="line">        numServiceProcs++; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤二， 设当前最大运行进程数<code>curMaxProcs = curMaxProcs + numServiceProcs</code>（即默认最大进程数与运行Service的进程数之和），如果当前进程的数量<code>mRemovedProcesses.size()</code>大于这个值，则遍历所有当前运行的进程，杀死符合条件的那些进程并释放内存。清理过程见清单 5（部分代码省略）。从清单5的代码中可以看出，进程被杀死的条件是：</p>
<ul>
<li>必须是非 persistent 进程，即非系统进程；</li>
<li>必须是空进程，即进程中没有任何activity存在。如果杀死存在Activity的进程，有可能关闭用户正在使用的程序，或者使应用程序恢复的时延变大，从而影响用户体验；</li>
<li>必须无broadcast receiver。运行broadcast receiver一般都在等待一个事件的发生，用户并不希望此类程序被系统强制关闭；</li>
<li>进程中service的数量必须为0。存在service的进程很有可能在为一个或者多个程序提供某种服务，如GPS定位服务。杀死此类进程将使其他进程无法正常服务。</li>
</ul>
<p>以上条件缺一不可。<br><strong>清单 5. 清理过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (!app.persistent &amp;&amp; app.activities.size() == 0 </span><br><span class="line">           &amp;&amp; app.curReceiver == null &amp;&amp; app.services.size() == 0) &#123; </span><br><span class="line">       if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; </span><br><span class="line">           Process.killProcess(app.pid); </span><br><span class="line">       &#125; else &#123; </span><br><span class="line">           try &#123; </span><br><span class="line">               app.thread.scheduleExit(); </span><br><span class="line">           &#125; catch (Exception e) &#123; </span><br><span class="line">               // Ignore exceptions. </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       // todo: For now we assume the application is not buggy </span><br><span class="line">       // or evil, and will quit as a result of our request. </span><br><span class="line">       // Eventually we need to drive this off of the death </span><br><span class="line">       // notification, and kill the process if it takes too long. </span><br><span class="line">       cleanUpApplicationRecordLocked(app, false, i); </span><br><span class="line">       i--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤三，再次检查当前运行的进程，如果<code>mRemovedProcesses.size()</code>仍然大于curMaxProcs则放宽条件再次进行回收。判断条件见代码清单6（部分代码省略）。下面代码中，布尔变量canQuit的值为真时，那么这个进程可以被回收。canQuit的取值分两个步骤，首先是根据进程的属性赋值。 1. 必须是非persistent进程，即非系统进程；2. 必须无broadcast receiver；3. 进程中service的数量必须为 0；4.persistent类型的activity数量为0。与步骤二唯一的不同在第 4 条，这里不要求进程是空进程，只要进程中没有persistent类型的Activity就可以（Activity 是否是persistent类型在开发阶段指定）。这些条件都满足时，再检查进程中每个Activity的属性，当该进程中所有的Activity都还必须满足三个条件：Activity的状态已经保存，当前处在不可见状态并且Activity已经Stop。这时杀掉进程只会降低下次调用程序时的加载速度，下次启动时将恢复到关闭之前的状态，并不会在用户体验上造成致命的影响，所以，canQuit置位为真。这种情况与步骤二的回收方式也有所不同，由于进程中 Activity的数量不是0，下一步需要对每个activity执行<code>destroyActivityLocked()</code>销毁，最后才杀死进程。<br><strong>清单 6. 执行 destroyActivityLocked() 销毁</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">boolean canQuit = !app.persistent &amp;&amp; app.curReceiver == null </span><br><span class="line">&amp;&amp; app.services.size() == 0 </span><br><span class="line">   &amp;&amp; app.persistentActivities == 0; </span><br><span class="line">int NUMA = app.activities.size(); </span><br><span class="line">for (j=0; j&lt;NUMA &amp;&amp; canQuit; j++) &#123; </span><br><span class="line">   HistoryRecord r = (HistoryRecord)app.activities.get(j); </span><br><span class="line">   canQuit = (r.haveState || !r.stateNotNeeded) </span><br><span class="line">           &amp;&amp; !r.visible &amp;&amp; r.stopped; </span><br><span class="line">&#125; </span><br><span class="line">if (canQuit) &#123; </span><br><span class="line">   // Finish all of the activities, and then the app itself. </span><br><span class="line">   for (j=0; j&lt;NUMA; j++) &#123; </span><br><span class="line">       HistoryRecord r = (HistoryRecord)app.activities.get(j); </span><br><span class="line">       if (!r.finishing) &#123; </span><br><span class="line">           destroyActivityLocked(r, false); </span><br><span class="line">       &#125; </span><br><span class="line">       r.resultTo = null; </span><br><span class="line">   &#125; </span><br><span class="line">   if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; </span><br><span class="line">       Process.killProcess(app.pid); </span><br><span class="line">   &#125; </span><br><span class="line">   cleanUpApplicationRecordLocked(app, false, i); </span><br><span class="line">   i--; </span><br><span class="line">   //dump(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤四，上面3个过程都是针对整个 process 进行的资源回收。在以上过程执行完毕之后，将在更小的粒度上对Activity的资源进行回收。与上面所述类似，列表mLRUActivities存储了当前所有运行中的Activity，排序规则同样为最少访问原则。<code>mLRUActivities.size()</code>返回系统中运行的Activity的数量，当其大于MAX_ACTIVITIES（MAX_ACTIVITIES是一个常量，一般值为20，代表系统中最大允许同时存在的Activity时。将回收部分满足条件的Activity以减少内存的使用。回收条件代码清单7所示：<br><strong>清单 7. 回收条件代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Finally, if there are too many activities now running, try to </span><br><span class="line">// finish as many as we can to get back down to the limit. </span><br><span class="line">for (   i=0; </span><br><span class="line">       i&lt;mLRUActivities.size() </span><br><span class="line">           &amp;&amp; mLRUActivities.size()  &gt; curMaxActivities; </span><br><span class="line">       i++) &#123; </span><br><span class="line">final HistoryRecord r </span><br><span class="line">       = (HistoryRecord)mLRUActivities.get(i); </span><br><span class="line"></span><br><span class="line">   // We can finish this one if we have its icicle saved and </span><br><span class="line">   // it is not persistent. </span><br><span class="line">   if ((r.haveState || !r.stateNotNeeded) &amp;&amp; !r.visible </span><br><span class="line">           &amp;&amp; r.stopped &amp;&amp; !r.persistent &amp;&amp; !r.finishing) &#123; </span><br><span class="line">       final int origSize = mLRUActivities.size(); </span><br><span class="line">       destroyActivityLocked(r, true); </span><br><span class="line">       if (origSize  &gt; mLRUActivities.size()) &#123; </span><br><span class="line">           i--; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里回收的只是Activity的内存资源，并不会杀死进程，也不会影响进程的运行。当进程需要调用被杀掉的Activity时，可以从保存的状态中回复，当然可能需要相对长一点的时延。</p>
<h2 id="Linux-内核中的内存回收"><a href="#Linux-内核中的内存回收" class="headerlink" title="Linux 内核中的内存回收"></a>Linux 内核中的内存回收</h2><h3 id="lowmemorykiller"><a href="#lowmemorykiller" class="headerlink" title="lowmemorykiller"></a>lowmemorykiller</h3><p>上面提到，<code>trimApplications()</code>函数中会执行一个叫做<code>updateOomAdjLocked()</code>的函数，如果返回false，则执行默认回收，若返回true则不执行默认内存回收。updateOomAdjLocked将针对每一个进程更新一个名为adj的变量，并将其告知Linux内核，内核维护一个包含adj的数据结构（即进程表），并通过lowmemorykiller检查系统内存的使用情况，在内存不足的情况下杀死一些进程并释放内存。下面将对这种Android Framework与Linux内核相配合的内存回收机制进行研究。</p>
<p>由于Android操作系统中的所有应用程序都运行在独立的Dalvik虚拟机环境中，Linux内核无法获知每个进程的运行状态，也就无法为每个进程维护一个合适的adj值，因此，Android Application Framework中必须提供一套机制以动态的更新每个进程的adj。这就是<code>updateOomAdjLocked()</code>。</p>
<p><code>updateOomAdjLocked()</code>位于ActivityManagerService中，其主要作用是为进程选择一个合适的adj值，并通知 Linux 内核更新这个值。updateOomAdjLocked 首先调用<code>computeOomAdjLocked()</code>初步计算adj的值，然后回到<code>updateOomAdjLocked()</code>对其值进行进一步修正。估算流程可参见代码。</p>
<p>关于adj，其定义在<code>task_struct-&gt;signal_struct-&gt;adj</code>, 文件 <code>/kernel/include/linux/sched.h</code>中（其实在Android源码<code>com.android.server.am.ProcessList.java</code>中有定义，但在Android 7.0及之后，adj的映射值不再是-17~16，具体可以参见源代码）。实质为进程数据结构中的一个变量，用来表示发生Out of Memory时杀死进程的优先级顺序。lowmemorykiller利用这个变量对进程的重要程度进行判断，并在内存不足时释放部分空间，其实现在文件<code>/kernel/drivers/staging/android/lowmemorykiller.c</code>中。lowmemorykiller定义了两个数组：lowmem_adj和 lowmem_minfree。其中lowmen_adj定义了一系列adj键值，而lowmem_minfree 的每个元素代表一个内存阈值。如下代码中四个阈值分别是 6MB，8MB，16MB 和 64MB，分别代表当内存小于64MB时，adj大于或等于12的那些进程将被杀死并回收，内存小于16MB时，adj大于等于6的那些进程将被杀死并回收，内存小于8MB时，adj大于等于1的那些进程将被杀死并回收，内存小于6MB时，adj大于等于0的所有进程将被杀死并回收。内核中的每个进程都持有一个adj，取值范围-17到15(准确说还是-17~16，只是16这个值用于缓存等特殊情况)，值越小代表进程的重要性越高，回收优先级越低，其中-17代表禁用自动回收。Android 系统中，只有 0-15 被使用。<br><strong>清单 8. 每个进程都持有一个 adj</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int lowmem_adj[6] = &#123; </span><br><span class="line">        0, </span><br><span class="line">        1, </span><br><span class="line">        6, </span><br><span class="line">        12, </span><br><span class="line"> &#125;; </span><br><span class="line"> static int lowmem_adj_size = 4; </span><br><span class="line"> static size_t lowmem_minfree[6] = &#123; </span><br><span class="line">        3 * 512,      /* 6MB */ </span><br><span class="line">        2 * 1024,     /* 8MB */ </span><br><span class="line">        4 * 1024,     /* 16MB */ </span><br><span class="line">        16 * 1024,    /* 64MB */ </span><br><span class="line"> &#125;; </span><br><span class="line"> static int lowmem_minfree_size = 4;</span><br></pre></td></tr></table></figure></p>
<p>lowmemorykiller注册一个lowmem_shrinker，lowmem_shrinker利用了标准Linux内核中的Cache Shrinker来实现，当空闲内存页面不足时，内核线程kswapd将用已注册的lowmem_shrinker来回收内存页面。<br><strong>清单 9. 用已注册的 lowmem_shrinker 来回收内存页面</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct shrinker lowmem_shrinker = &#123; </span><br><span class="line">                    .shrink = lowmem_shrink, </span><br><span class="line">        .seeks = DEFAULT_SEEKS * 16 </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"> static int __init lowmem_init(void) </span><br><span class="line"> &#123; </span><br><span class="line">        task_free_register(&amp;task_nb); </span><br><span class="line">        register_shrinker(&amp;lowmem_shrinker); </span><br><span class="line">        return 0; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>lowmem_shrink的代码在函数lowmem_shrink中，下面给出该函数的主要结构。lowmem_shrink根据上述规则遍历所有进程，选出需要结束的进程，通过发送一个无法忽略的信号SIGKILL强制结束这些进程<br><strong>清单 10. 强制结束进程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int lowmem_shrink(struct shrinker *s, int nr_to_scan, gfp_t gfp_mask) </span><br><span class="line"> &#123; </span><br><span class="line">        for_each_process(p) &#123; </span><br><span class="line">           //Select processes to be forced  </span><br><span class="line">        &#125; </span><br><span class="line">        if (selected) &#123; </span><br><span class="line">               force_sig(SIGKILL, selected); </span><br><span class="line">               rem -= selected_tasksize; </span><br><span class="line">        &#125; else </span><br><span class="line">        rem = -1; </span><br><span class="line">        return rem; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Oom-killer"><a href="#Oom-killer" class="headerlink" title="Oom_killer"></a>Oom_killer</h3><p>如果上述各种方法都无法释放出足够的内存空间，那么当为新的进程分配应用程序时将发生Out of Memory异常，OOM_killer将尽最后的努力杀掉一些进程来释放空间。Android中的OOM_killer继承自标准Linux 2.6内核，用于分配内存时Out of Memory的处理。Android并没有对其实现方式进行修改。其位置在linux/mm/oom_kill.c。oom_killer遍历进程，并计算所有进程的badness值，选择badness最大的那个进程将其杀掉。函数badness的声明如下：</p>
<p><code>unsigned long badness(struct task_struct *p, unsigned long uptime)</code> 函数select_bad_process返回将要杀掉的那个进程。</p>
<p><strong>清单 11. 返回将要杀掉的进程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static struct task_struct *select_bad_process(unsigned long *ppoints, </span><br><span class="line">                                            struct mem_cgroup *mem) </span><br><span class="line"> &#123; </span><br><span class="line">        for_each_process(p) &#123; </span><br><span class="line">               points = badness(p, uptime.tv_sec); </span><br><span class="line">               if (points &gt; *ppoints || !chosen) &#123; </span><br><span class="line">                       chosen = p; </span><br><span class="line">                       *ppoints = points; </span><br><span class="line">               &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return chosen; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，和lowmemorykiller一样，通过发送SIGKILL结束选中的进程。由于oom_killer与标准Linux内核并无不同，这里不再详细研究。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文研究了Android操作系统上的内存回收机制。主要包括Application Framework层的默认回收以及Linux内核中的lowmemorykiller、OOM_killer。一般来说应用开发者并不需要控制或者修改系统的内存管理以及回收，但是深入理解这些系统级的管理机制还是必要的，尤其有助于更加合理地设计应用程序，使应用程序的进程在其生命周期内高效地运行。而系统级开发者如果想要对内存管理机制进行优化，对原有机制的理解则是必不可少的重要前提。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>参考 Android 专题：    <a href="http://www.ibm.com/developerworks/cn/opensource/theme/android/" target="_blank" rel="external">Android 开发从入门到精通</a>。</li>
</ul>
<ul>
<li>更多有关移动开发方面的内容，请参考<a href="http://www.ibm.com/developerworks/cn/mobile/" target="_blank" rel="external">移动开发</a>专题。</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-02-09T04:27:59.000Z" itemprop="dateUpdated">2017-02-09 12:27:59</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://cstsinghua.github.io">
            <img src="/img/logo.jpg" alt="Cstsinghua">
            Cstsinghua
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存回收/">内存回收</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机制/">机制</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&title=《Android 操作系统的内存回收机制》 — Atypical programmer&pic=http://cstsinghua.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&title=《Android 操作系统的内存回收机制》 — Atypical programmer&source=Android 操作系统的内存回收机制
Android系统是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android 操作系统的内存回收机制》 — Atypical programmer&url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&via=http://cstsinghua.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/02/21/Android APK逆向解析/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Android APK逆向解析</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/12/02/Android热修复技术选型——三大流派解析/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android热修复技术选型——三大流派解析</h4>
      </a>
    </div>
  
</nav>



    





<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=2146219"></script>
    <!-- UY END -->
</section>







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        Thanks~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Cstsinghua &copy; 2016 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&title=《Android 操作系统的内存回收机制》 — Atypical programmer&pic=http://cstsinghua.github.io/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&title=《Android 操作系统的内存回收机制》 — Atypical programmer&source=Android 操作系统的内存回收机制
Android系统是一款基于Linux内核，面向移动终端的操作系统。为适应其作为移动平台操作系统的特殊需要，谷歌对..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android 操作系统的内存回收机制》 — Atypical programmer&url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/&via=http://cstsinghua.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://cstsinghua.github.io/2017/02/09/Android 操作系统的内存回收机制/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1259817891&web_id=1259817891')

</script>

<script src="/js/main.min.js?v=1.6.16"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.6.16" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
